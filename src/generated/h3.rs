#![allow(non_camel_case_types, non_snake_case)]

use crate::ser::{Aligned, Bin1Serialize, Bin1Serializer, SerializeError};
use crate::types::variant::{StaticVariant, Variant, VariantDeserializer, DeserializeVariant, ZVariant};
use ecow::EcoString;
use crate::types::property::SEntityTemplateProperty;

use crate as hitman_bin1;

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct STemplateEntityFactory {
    #[serde(rename = "subType")]
    pub sub_type: i32,
    #[serde(rename = "blueprintIndexInResourceHeader")]
    pub blueprint_index_in_resource_header: i32,
    #[serde(rename = "rootEntityIndex")]
    pub root_entity_index: i32,
    #[serde(rename = "subEntities")]
    #[bin1(pad = 4)]
    pub sub_entities: Vec<STemplateFactorySubEntity>,
    #[serde(rename = "propertyOverrides")]
    pub property_overrides: Vec<SEntityTemplatePropertyOverride>,
    #[serde(rename = "externalSceneTypeIndicesInResourceHeader")]
    pub external_scene_type_indices_in_resource_header: Vec<i32>,
}

impl StaticVariant for STemplateEntityFactory {
     const TYPE_ID: &str = "STemplateEntityFactory";
}

impl StaticVariant for Vec<STemplateEntityFactory> {
     const TYPE_ID: &str = "TArray<STemplateEntityFactory>";
}

impl StaticVariant for Vec<Vec<STemplateEntityFactory>> {
     const TYPE_ID: &str = "TArray<TArray<STemplateEntityFactory>>";
}

impl Variant for STemplateEntityFactory {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("STemplateEntityFactory")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<STemplateEntityFactory>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<STemplateEntityFactory>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<STemplateEntityFactory>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct STemplateEntityBlueprint {
    #[serde(rename = "subType")]
    pub sub_type: i32,
    #[serde(rename = "rootEntityIndex")]
    pub root_entity_index: i32,
    #[serde(rename = "subEntities")]
    pub sub_entities: Vec<STemplateBlueprintSubEntity>,
    #[serde(rename = "externalSceneTypeIndicesInResourceHeader")]
    pub external_scene_type_indices_in_resource_header: Vec<i32>,
    #[serde(rename = "pinConnections")]
    pub pin_connections: Vec<SEntityTemplatePinConnection>,
    #[serde(rename = "inputPinForwardings")]
    pub input_pin_forwardings: Vec<SEntityTemplatePinConnection>,
    #[serde(rename = "outputPinForwardings")]
    pub output_pin_forwardings: Vec<SEntityTemplatePinConnection>,
    #[serde(rename = "overrideDeletes")]
    pub override_deletes: Vec<SEntityTemplateReference>,
    #[serde(rename = "pinConnectionOverrides")]
    pub pin_connection_overrides: Vec<SExternalEntityTemplatePinConnection>,
    #[serde(rename = "pinConnectionOverrideDeletes")]
    pub pin_connection_override_deletes: Vec<SExternalEntityTemplatePinConnection>,
}

impl StaticVariant for STemplateEntityBlueprint {
     const TYPE_ID: &str = "STemplateEntityBlueprint";
}

impl StaticVariant for Vec<STemplateEntityBlueprint> {
     const TYPE_ID: &str = "TArray<STemplateEntityBlueprint>";
}

impl StaticVariant for Vec<Vec<STemplateEntityBlueprint>> {
     const TYPE_ID: &str = "TArray<TArray<STemplateEntityBlueprint>>";
}

impl Variant for STemplateEntityBlueprint {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("STemplateEntityBlueprint")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<STemplateEntityBlueprint>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<STemplateEntityBlueprint>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<STemplateEntityBlueprint>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplateReference {
    #[serde(rename = "entityID")]
    pub entity_id: u64,
    #[serde(rename = "externalSceneIndex")]
    pub external_scene_index: i32,
    #[serde(rename = "entityIndex")]
    pub entity_index: i32,
    #[serde(rename = "exposedEntity")]
    pub exposed_entity: EcoString,
}

impl StaticVariant for SEntityTemplateReference {
     const TYPE_ID: &str = "SEntityTemplateReference";
}

impl StaticVariant for Vec<SEntityTemplateReference> {
     const TYPE_ID: &str = "TArray<SEntityTemplateReference>";
}

impl StaticVariant for Vec<Vec<SEntityTemplateReference>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplateReference>>";
}

impl Variant for SEntityTemplateReference {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplateReference")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplateReference>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplateReference>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplateReference>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SColorRGB {
    #[serde(rename = "r")]
    pub r: f32,
    #[serde(rename = "g")]
    pub g: f32,
    #[serde(rename = "b")]
    pub b: f32,
}

impl StaticVariant for SColorRGB {
     const TYPE_ID: &str = "SColorRGB";
}

impl StaticVariant for Vec<SColorRGB> {
     const TYPE_ID: &str = "TArray<SColorRGB>";
}

impl StaticVariant for Vec<Vec<SColorRGB>> {
     const TYPE_ID: &str = "TArray<TArray<SColorRGB>>";
}

impl Variant for SColorRGB {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SColorRGB")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SColorRGB>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SColorRGB>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SColorRGB>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SColorRGBA {
    #[serde(rename = "r")]
    pub r: f32,
    #[serde(rename = "g")]
    pub g: f32,
    #[serde(rename = "b")]
    pub b: f32,
    #[serde(rename = "a")]
    pub a: f32,
}

impl StaticVariant for SColorRGBA {
     const TYPE_ID: &str = "SColorRGBA";
}

impl StaticVariant for Vec<SColorRGBA> {
     const TYPE_ID: &str = "TArray<SColorRGBA>";
}

impl StaticVariant for Vec<Vec<SColorRGBA>> {
     const TYPE_ID: &str = "TArray<TArray<SColorRGBA>>";
}

impl Variant for SColorRGBA {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SColorRGBA")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SColorRGBA>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SColorRGBA>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SColorRGBA>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct ZGameTime {
    #[serde(rename = "m_nTicks")]
    pub ticks: i64,
}

impl StaticVariant for ZGameTime {
     const TYPE_ID: &str = "ZGameTime";
}

impl StaticVariant for Vec<ZGameTime> {
     const TYPE_ID: &str = "TArray<ZGameTime>";
}

impl StaticVariant for Vec<Vec<ZGameTime>> {
     const TYPE_ID: &str = "TArray<TArray<ZGameTime>>";
}

impl Variant for ZGameTime {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZGameTime")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<ZGameTime>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZGameTime>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZGameTime>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SMatrix43 {
    #[serde(rename = "XAxis")]
    pub x_axis: SVector3,
    #[serde(rename = "YAxis")]
    pub y_axis: SVector3,
    #[serde(rename = "ZAxis")]
    pub z_axis: SVector3,
    #[serde(rename = "Trans")]
    pub trans: SVector3,
}

impl StaticVariant for SMatrix43 {
     const TYPE_ID: &str = "SMatrix43";
}

impl StaticVariant for Vec<SMatrix43> {
     const TYPE_ID: &str = "TArray<SMatrix43>";
}

impl StaticVariant for Vec<Vec<SMatrix43>> {
     const TYPE_ID: &str = "TArray<TArray<SMatrix43>>";
}

impl Variant for SMatrix43 {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SMatrix43")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SMatrix43>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SMatrix43>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SMatrix43>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct STemplateFactorySubEntity {
    #[serde(rename = "logicalParent")]
    pub logical_parent: SEntityTemplateReference,
    #[serde(rename = "entityTypeResourceIndex")]
    pub entity_type_resource_index: i32,
    #[serde(rename = "propertyValues")]
    #[bin1(pad = 4)]
    pub property_values: Vec<SEntityTemplateProperty>,
    #[serde(rename = "postInitPropertyValues")]
    pub post_init_property_values: Vec<SEntityTemplateProperty>,
    #[serde(rename = "platformSpecificPropertyValues")]
    pub platform_specific_property_values: Vec<SEntityTemplatePlatformSpecificProperty>,
}

impl StaticVariant for STemplateFactorySubEntity {
     const TYPE_ID: &str = "STemplateFactorySubEntity";
}

impl StaticVariant for Vec<STemplateFactorySubEntity> {
     const TYPE_ID: &str = "TArray<STemplateFactorySubEntity>";
}

impl StaticVariant for Vec<Vec<STemplateFactorySubEntity>> {
     const TYPE_ID: &str = "TArray<TArray<STemplateFactorySubEntity>>";
}

impl Variant for STemplateFactorySubEntity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("STemplateFactorySubEntity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<STemplateFactorySubEntity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<STemplateFactorySubEntity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<STemplateFactorySubEntity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplatePropertyOverride {
    #[serde(rename = "propertyOwner")]
    pub property_owner: SEntityTemplateReference,
    #[serde(rename = "propertyValue")]
    pub property_value: SEntityTemplateProperty,
}

impl StaticVariant for SEntityTemplatePropertyOverride {
     const TYPE_ID: &str = "SEntityTemplatePropertyOverride";
}

impl StaticVariant for Vec<SEntityTemplatePropertyOverride> {
     const TYPE_ID: &str = "TArray<SEntityTemplatePropertyOverride>";
}

impl StaticVariant for Vec<Vec<SEntityTemplatePropertyOverride>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplatePropertyOverride>>";
}

impl Variant for SEntityTemplatePropertyOverride {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplatePropertyOverride")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplatePropertyOverride>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplatePropertyOverride>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplatePropertyOverride>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct STemplateBlueprintSubEntity {
    #[serde(rename = "logicalParent")]
    pub logical_parent: SEntityTemplateReference,
    #[serde(rename = "entityTypeResourceIndex")]
    pub entity_type_resource_index: i32,
    #[serde(rename = "entityId")]
    #[bin1(pad = 4)]
    pub entity_id: u64,
    #[serde(rename = "editorOnly")]
    pub editor_only: bool,
    #[serde(rename = "entityName")]
    #[bin1(pad = 7)]
    pub entity_name: EcoString,
    #[serde(rename = "propertyAliases")]
    pub property_aliases: Vec<SEntityTemplatePropertyAlias>,
    #[serde(rename = "exposedEntities")]
    pub exposed_entities: Vec<SEntityTemplateExposedEntity>,
    #[serde(rename = "exposedInterfaces")]
    pub exposed_interfaces: Vec<(EcoString, i32)>,
    #[serde(rename = "entitySubsets")]
    pub entity_subsets: Vec<(EcoString, SEntityTemplateEntitySubset)>,
}

impl StaticVariant for STemplateBlueprintSubEntity {
     const TYPE_ID: &str = "STemplateBlueprintSubEntity";
}

impl StaticVariant for Vec<STemplateBlueprintSubEntity> {
     const TYPE_ID: &str = "TArray<STemplateBlueprintSubEntity>";
}

impl StaticVariant for Vec<Vec<STemplateBlueprintSubEntity>> {
     const TYPE_ID: &str = "TArray<TArray<STemplateBlueprintSubEntity>>";
}

impl Variant for STemplateBlueprintSubEntity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("STemplateBlueprintSubEntity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<STemplateBlueprintSubEntity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<STemplateBlueprintSubEntity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<STemplateBlueprintSubEntity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplatePinConnection {
    #[serde(rename = "fromID")]
    pub from_id: i32,
    #[serde(rename = "toID")]
    pub to_id: i32,
    #[serde(rename = "fromPinName")]
    pub from_pin_name: EcoString,
    #[serde(rename = "toPinName")]
    pub to_pin_name: EcoString,
    #[serde(rename = "constantPinValue")]
    pub constant_pin_value: ZVariant,
}

impl StaticVariant for SEntityTemplatePinConnection {
     const TYPE_ID: &str = "SEntityTemplatePinConnection";
}

impl StaticVariant for Vec<SEntityTemplatePinConnection> {
     const TYPE_ID: &str = "TArray<SEntityTemplatePinConnection>";
}

impl StaticVariant for Vec<Vec<SEntityTemplatePinConnection>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplatePinConnection>>";
}

impl Variant for SEntityTemplatePinConnection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplatePinConnection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplatePinConnection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplatePinConnection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplatePinConnection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SExternalEntityTemplatePinConnection {
    #[serde(rename = "fromEntity")]
    pub from_entity: SEntityTemplateReference,
    #[serde(rename = "toEntity")]
    pub to_entity: SEntityTemplateReference,
    #[serde(rename = "fromPinName")]
    pub from_pin_name: EcoString,
    #[serde(rename = "toPinName")]
    pub to_pin_name: EcoString,
    #[serde(rename = "constantPinValue")]
    pub constant_pin_value: ZVariant,
}

impl StaticVariant for SExternalEntityTemplatePinConnection {
     const TYPE_ID: &str = "SExternalEntityTemplatePinConnection";
}

impl StaticVariant for Vec<SExternalEntityTemplatePinConnection> {
     const TYPE_ID: &str = "TArray<SExternalEntityTemplatePinConnection>";
}

impl StaticVariant for Vec<Vec<SExternalEntityTemplatePinConnection>> {
     const TYPE_ID: &str = "TArray<TArray<SExternalEntityTemplatePinConnection>>";
}

impl Variant for SExternalEntityTemplatePinConnection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SExternalEntityTemplatePinConnection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SExternalEntityTemplatePinConnection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SExternalEntityTemplatePinConnection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SExternalEntityTemplatePinConnection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SVector3 {
    #[serde(rename = "x")]
    pub x: f32,
    #[serde(rename = "y")]
    pub y: f32,
    #[serde(rename = "z")]
    pub z: f32,
}

impl StaticVariant for SVector3 {
     const TYPE_ID: &str = "SVector3";
}

impl StaticVariant for Vec<SVector3> {
     const TYPE_ID: &str = "TArray<SVector3>";
}

impl StaticVariant for Vec<Vec<SVector3>> {
     const TYPE_ID: &str = "TArray<TArray<SVector3>>";
}

impl Variant for SVector3 {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SVector3")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SVector3>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SVector3>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SVector3>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplatePlatformSpecificProperty {
    #[serde(rename = "propertyValue")]
    pub property_value: SEntityTemplateProperty,
    #[serde(rename = "platform")]
    pub platform: EVirtualPlatformID,
    #[serde(rename = "postInit")]
    pub post_init: bool,
}

impl StaticVariant for SEntityTemplatePlatformSpecificProperty {
     const TYPE_ID: &str = "SEntityTemplatePlatformSpecificProperty";
}

impl StaticVariant for Vec<SEntityTemplatePlatformSpecificProperty> {
     const TYPE_ID: &str = "TArray<SEntityTemplatePlatformSpecificProperty>";
}

impl StaticVariant for Vec<Vec<SEntityTemplatePlatformSpecificProperty>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplatePlatformSpecificProperty>>";
}

impl Variant for SEntityTemplatePlatformSpecificProperty {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplatePlatformSpecificProperty")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplatePlatformSpecificProperty>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplatePlatformSpecificProperty>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplatePlatformSpecificProperty>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplatePropertyAlias {
    #[serde(rename = "sAliasName")]
    pub alias_name: EcoString,
    #[serde(rename = "entityID")]
    pub entity_id: i32,
    #[serde(rename = "sPropertyName")]
    #[bin1(pad = 4)]
    pub property_name: EcoString,
}

impl StaticVariant for SEntityTemplatePropertyAlias {
     const TYPE_ID: &str = "SEntityTemplatePropertyAlias";
}

impl StaticVariant for Vec<SEntityTemplatePropertyAlias> {
     const TYPE_ID: &str = "TArray<SEntityTemplatePropertyAlias>";
}

impl StaticVariant for Vec<Vec<SEntityTemplatePropertyAlias>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplatePropertyAlias>>";
}

impl Variant for SEntityTemplatePropertyAlias {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplatePropertyAlias")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplatePropertyAlias>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplatePropertyAlias>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplatePropertyAlias>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplateExposedEntity {
    #[serde(rename = "sName")]
    pub name: EcoString,
    #[serde(rename = "bIsArray")]
    pub is_array: bool,
    #[serde(rename = "aTargets")]
    #[bin1(pad = 7)]
    pub targets: Vec<SEntityTemplateReference>,
}

impl StaticVariant for SEntityTemplateExposedEntity {
     const TYPE_ID: &str = "SEntityTemplateExposedEntity";
}

impl StaticVariant for Vec<SEntityTemplateExposedEntity> {
     const TYPE_ID: &str = "TArray<SEntityTemplateExposedEntity>";
}

impl StaticVariant for Vec<Vec<SEntityTemplateExposedEntity>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplateExposedEntity>>";
}

impl Variant for SEntityTemplateExposedEntity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplateExposedEntity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplateExposedEntity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplateExposedEntity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplateExposedEntity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, Bin1Serialize, serde::Serialize, serde::Deserialize)]
pub struct SEntityTemplateEntitySubset {
    #[serde(rename = "entities")]
    pub entities: Vec<i32>,
}

impl StaticVariant for SEntityTemplateEntitySubset {
     const TYPE_ID: &str = "SEntityTemplateEntitySubset";
}

impl StaticVariant for Vec<SEntityTemplateEntitySubset> {
     const TYPE_ID: &str = "TArray<SEntityTemplateEntitySubset>";
}

impl StaticVariant for Vec<Vec<SEntityTemplateEntitySubset>> {
     const TYPE_ID: &str = "TArray<TArray<SEntityTemplateEntitySubset>>";
}

impl Variant for SEntityTemplateEntitySubset {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SEntityTemplateEntitySubset")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        serde_json::to_value(self)
    }
}

inventory::submit!(&VariantDeserializer::<SEntityTemplateEntitySubset>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SEntityTemplateEntitySubset>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SEntityTemplateEntitySubset>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAIEventType {
    AIET_None,
    AIET_Ignore,
    AIET_PreventAutoPurge,
    AIET_ShootTarget,
    AIET_Hunting,
    AIET_Order_Target,
    AIET_END_BOOLEAN_EVENTS,
    AIET_LookedAt,
    AIET_Killer,
    AIET_Strangler,
    AIET_Suspicious,
    AIET_KnownBody,
    AIET_KnownBodyIsFoundOutsideNavmeshAndIgnored,
    AIET_KnownBodyIsHandled,
    AIET_KnownBodybag,
    AIET_KnownBodybagIsHandled,
    AIET_Dead,
    AIET_DisguiseSuspicious,
    AIET_DamagingMe,
    AIET_KnownInCloset,
    AIET_KnownInNpcUnreachableArea,
    AIET_Sense,
    AIET_HasBeenInCombat,
    AIET_ReportedByCamera,
    AIET_SOUNDEVENTS_LOW_LOUDNESS_BEGIN,
    AIET_SoundFootsteps,
    AIET_SoundThrownItemCollision,
    AIET_SoundGunSilenced,
    AIET_SoundHitmanGunSilenced,
    AIET_SoundLegalGunSilenced,
    AIET_SoundLegalHitmanGunSilenced,
    AIET_SoundEmptyGun,
    AIET_SoundCCBreakNeck,
    AIET_SoundCCChoke,
    AIET_SoundCCFiberwire,
    AIET_SoundBulletImpact,
    AIET_SoundLegalBulletImpact,
    AIET_SoundSpeakWarning,
    AIET_SoundSpeakAngry,
    AIET_SOUNDEVENTS_NORMAL_LOUDNESS_BEGIN,
    AIET_SoundRadio,
    AIET_SoundAlarm,
    AIET_SoundSpeakPainBehind,
    AIET_SoundCloseCombat,
    AIET_SoundSpeakPain,
    AIET_SoundSetpiece,
    AIET_SOUNDEVENTS_LOUD_LOUDNESS_BEGIN,
    AIET_SoundSpeakHelp,
    AIET_SoundSpeakHelpLoud,
    AIET_SoundGunShot,
    AIET_SoundHitmanGunShot,
    AIET_SoundLegalGunShot,
    AIET_SoundLegalHitmanGunShot,
    AIET_SoundExplosion,
    AIET_SoundAccident,
    AIET_SoundCurious,
    AIET_SoundCuriousItem,
    AIET_SoundInteresting,
    AIET_SoundCrowdCurious,
    AIET_SoundCrowdAlerted,
    AIET_SoundCrowdWantsArrest,
    AIET_SoundCrowdWantsArrestKiller,
    AIET_SOUNDEVENTS_END,
    AIET_SightReaction,
    AIET_SightInvestigation,
    AIET_PerceptibleEntityAware,
    AIET_InSight,
    AIET_SlowMovementInVegetationInSight,
    AIET_MediumMovementInVegetationInSight,
    AIET_FastMovementInVegetationInSight,
    AIET_VisualSetpiece,
    AIET_DirectSetpiece,
    AIET_Sick,
    AIET_MyFlashGrenadeExploded,
    AIET_StunnedByFlashGrenade,
    AIET_WasSlapped,
    AIET_Attention_Stage_1,
    AIET_Attention_Stage_2,
    AIET_AttentionFading,
    AIET_FullAttention,
    AIET_FullDisguiseAttention,
    AIET_ReactedTo,
    AIET_ReactTarget,
    AIET_ReactSuppressed,
    AIET_StanddownHolster,
    AIET_ForcedIllegal,
    AIET_HitByItem,
    AIET_HitByCoin,
    AIET_LTHitByItemOrCoin,
    AIET_HitByItemOrCoinTwice,
    AIET_HitByThis,
    AIET_SeenInAccident,
    AIET_Trespassing_Strike_1,
    AIET_Trespassing_Strike_2,
    AIET_Trespassing_Strike_3,
    AIET_DistractedByMovementInVegetation_Once,
    AIET_DistractedByMovementInVegetation_Twice,
    AIET_Investigate_Strike_1,
    AIET_Investigate_Strike_2,
    AIET_DisguiseEnforcer,
    AIET_Suspect,
    AIET_InSentryZone,
    AIET_MySentryZone,
    AIET_TriggerAlarm,
    AIET_LockdownIntruder,
    AIET_AccuseUnconscious,
    AIET_HasKnockMeDown,
    AIET_HasKnockSomeoneDown,
    AIET_InMyPrivateArea,
    AIET_KnownNaked,
    AIET_KnownDraggingBodybag,
    AIET_InvestigateOrder,
    AIET_ReactedSurprised,
    AIET_ReportGotShot,
    AIET_HasReportedDeadBodySituation,
    AIET_Social_TooClose,
    AIET_Social_Privacy,
    AIET_Social_Silly,
    AIET_ReactedToSituation,
    AIET_SeeAttached,
    AIET_WasInvisible,
    AIET_BlameHitman,
    AIET_BlamedByUnconscious,
    AIET_DontCareAboutBlaming,
    AIET_Combat_PropagatedBy,
    AIET_Combat_WithinPropagationField,
    AIET_Combat_MarkedAsDiscardable,
    AIET_Combat_AttackWitness,
    AIET_Combat_HomingAttackOrigin,
    AIET_Combat_VIPWasAttackedFromPosition,
    AIET_ReactedToSniperKnowledge,
    AIET_SniperCombatTarget,
    AIET_SniperCombatAimTarget,
    AIET_CantReachTarget,
    AIET_HuntingSniper,
    AIET_NeedCover,
    AIET_WaitingForSniper,
    AIET_HeardSniperShooting,
    AIET_KnownHidden,
    AIET_SituationTarget,
    AIET_TalkingToHitman,
    AIET_SuspiciousAction,
    AIET_RadioCallHelpingActor,
    AIET_WeaponContextKnown,
    AIET_IdleStandDown,
    AIET_IgnoreInvestigation,
    AIET_NewDisguiseTarget,
    AIET_SocialTarget,
    AIET_SecurityCamBroken,
    AIET_HeWoundedMeLongDistance,
    AIET_HeWoundedMeShortDistance,
    AIET_HeWoundedMeCC,
    AIET_HeAimedAtMe,
    AIET_BumpedIntoMe,
    AIET_ReactToDistraction,
    AIET_MovingToTarget,
    AIET_ReachedTarget,
    AIET_DistractionChainPart,
    AIET_NewDistractionChainPart,
    AIET_ChainFixed,
    AIET_SurprisePlayed,
    AIET_NewDistraction,
    AIET_WasSilly,
    AIET_Distraction_My_Leader,
    AIET_Distraction_My_Assistant,
    AIET_Distraction_Was_My_Assistant,
    AIET_AssitingWithSuitcase,
    AIET_SuitcaseAssistanceFaceToFace,
    AIET_SuitcaseAssistanceRadio,
    AIET_SC_CombatPosition,
    AIET_SC_CombatPositionMove,
    AIET_SC_CombatPositionFight,
    AIET_SC_PreventMovingThere,
    AIET_SC_JumpyReaction,
    AIET_DISTRACTION_TYPES_START,
    AIET_SeeInCoverDistraction,
    AIET_SeeSneakingDistraction,
    AIET_SeeStunnedDistraction,
    AIET_SeeSickDistraction,
    AIET_LegalItemDroppedDistraction,
    AIET_IllegalItemDroppedDistraction,
    AIET_BumpedDistraction,
    AIET_SightReactionDistraction,
    AIET_SightInvestigationDistraction,
    AIET_HearItemImpactDistraction,
    AIET_SeeCuriousPerceptibleDistraction,
    AIET_SeeCuriousItemDistraction,
    AIET_SeeFlyingItemDistraction,
    AIET_SeeThrowingDistraction,
    AIET_HitBySomethingDistraction,
    AIET_HearFootstepsDistraction,
    AIET_SeeAgility,
    AIET_SeeAgility_Vault,
    AIET_SeeAgility_Window,
    AIET_SeeHidding,
    AIET_HearStrangeSound,
    AIET_HearAlarm,
    AIET_HearRadio,
    AIET_HearAngry,
    AIET_HearHelp,
    AIET_HearAccident,
    AIET_HearCuriousCrowd,
    AIET_HearBulletImpact,
    AIET_HearPain,
    AIET_HearCuriousSound,
    AIET_HearCuriousItemSound,
    AIET_SecurityCameraBroken,
    AIET_SetpieceDistractionDefault,
    AIET_SeeItemTossDistraction,
    AIET_SetpieceDistractionDoor,
    AIET_SetpieceDistractionExperimental1,
    AIET_SetpieceDistractionExperimental2,
    AIET_SeeSuitcaseDistraction,
    AIET_Distraction_Silly,
    AIET_Distraction_TooClose,
    AIET_Distraction_Privacy,
    AIET_Distraction_MovementInVegetationBrief,
    AIET_Distraction_MovementInVegetationCurious,
    AIET_DISTRACTION_TYPES_END,
    AIET_ARREST_REASONS_START,
    AIET_ArrestReason_IllegalItem,
    AIET_ArrestReason_DragBody,
    AIET_ArrestReason_KnockDown,
    AIET_ARREST_REASONS_END,
    AIET_END_NORMAL_EVENTS,
    AIET_DEBUG_EVENTS_START,
    AIET_Debug_ThrowFlashbangHere,
    AIET_DEBUG_EVENTS_END,
}

impl Aligned for EAIEventType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAIEventType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIET_None => 0i32,
            Self::AIET_Ignore => 1i32,
            Self::AIET_PreventAutoPurge => 2i32,
            Self::AIET_ShootTarget => 3i32,
            Self::AIET_Hunting => 4i32,
            Self::AIET_Order_Target => 5i32,
            Self::AIET_END_BOOLEAN_EVENTS => 6i32,
            Self::AIET_LookedAt => 7i32,
            Self::AIET_Killer => 8i32,
            Self::AIET_Strangler => 9i32,
            Self::AIET_Suspicious => 10i32,
            Self::AIET_KnownBody => 11i32,
            Self::AIET_KnownBodyIsFoundOutsideNavmeshAndIgnored => 12i32,
            Self::AIET_KnownBodyIsHandled => 13i32,
            Self::AIET_KnownBodybag => 14i32,
            Self::AIET_KnownBodybagIsHandled => 15i32,
            Self::AIET_Dead => 16i32,
            Self::AIET_DisguiseSuspicious => 17i32,
            Self::AIET_DamagingMe => 18i32,
            Self::AIET_KnownInCloset => 19i32,
            Self::AIET_KnownInNpcUnreachableArea => 20i32,
            Self::AIET_Sense => 21i32,
            Self::AIET_HasBeenInCombat => 22i32,
            Self::AIET_ReportedByCamera => 23i32,
            Self::AIET_SOUNDEVENTS_LOW_LOUDNESS_BEGIN => 24i32,
            Self::AIET_SoundFootsteps => 25i32,
            Self::AIET_SoundThrownItemCollision => 26i32,
            Self::AIET_SoundGunSilenced => 27i32,
            Self::AIET_SoundHitmanGunSilenced => 28i32,
            Self::AIET_SoundLegalGunSilenced => 29i32,
            Self::AIET_SoundLegalHitmanGunSilenced => 30i32,
            Self::AIET_SoundEmptyGun => 31i32,
            Self::AIET_SoundCCBreakNeck => 32i32,
            Self::AIET_SoundCCChoke => 33i32,
            Self::AIET_SoundCCFiberwire => 34i32,
            Self::AIET_SoundBulletImpact => 35i32,
            Self::AIET_SoundLegalBulletImpact => 36i32,
            Self::AIET_SoundSpeakWarning => 37i32,
            Self::AIET_SoundSpeakAngry => 38i32,
            Self::AIET_SOUNDEVENTS_NORMAL_LOUDNESS_BEGIN => 39i32,
            Self::AIET_SoundRadio => 40i32,
            Self::AIET_SoundAlarm => 41i32,
            Self::AIET_SoundSpeakPainBehind => 42i32,
            Self::AIET_SoundCloseCombat => 43i32,
            Self::AIET_SoundSpeakPain => 44i32,
            Self::AIET_SoundSetpiece => 45i32,
            Self::AIET_SOUNDEVENTS_LOUD_LOUDNESS_BEGIN => 46i32,
            Self::AIET_SoundSpeakHelp => 47i32,
            Self::AIET_SoundSpeakHelpLoud => 48i32,
            Self::AIET_SoundGunShot => 49i32,
            Self::AIET_SoundHitmanGunShot => 50i32,
            Self::AIET_SoundLegalGunShot => 51i32,
            Self::AIET_SoundLegalHitmanGunShot => 52i32,
            Self::AIET_SoundExplosion => 53i32,
            Self::AIET_SoundAccident => 54i32,
            Self::AIET_SoundCurious => 55i32,
            Self::AIET_SoundCuriousItem => 56i32,
            Self::AIET_SoundInteresting => 57i32,
            Self::AIET_SoundCrowdCurious => 58i32,
            Self::AIET_SoundCrowdAlerted => 59i32,
            Self::AIET_SoundCrowdWantsArrest => 60i32,
            Self::AIET_SoundCrowdWantsArrestKiller => 61i32,
            Self::AIET_SOUNDEVENTS_END => 62i32,
            Self::AIET_SightReaction => 63i32,
            Self::AIET_SightInvestigation => 64i32,
            Self::AIET_PerceptibleEntityAware => 65i32,
            Self::AIET_InSight => 66i32,
            Self::AIET_SlowMovementInVegetationInSight => 67i32,
            Self::AIET_MediumMovementInVegetationInSight => 68i32,
            Self::AIET_FastMovementInVegetationInSight => 69i32,
            Self::AIET_VisualSetpiece => 70i32,
            Self::AIET_DirectSetpiece => 71i32,
            Self::AIET_Sick => 72i32,
            Self::AIET_MyFlashGrenadeExploded => 73i32,
            Self::AIET_StunnedByFlashGrenade => 74i32,
            Self::AIET_WasSlapped => 75i32,
            Self::AIET_Attention_Stage_1 => 76i32,
            Self::AIET_Attention_Stage_2 => 77i32,
            Self::AIET_AttentionFading => 78i32,
            Self::AIET_FullAttention => 79i32,
            Self::AIET_FullDisguiseAttention => 80i32,
            Self::AIET_ReactedTo => 81i32,
            Self::AIET_ReactTarget => 82i32,
            Self::AIET_ReactSuppressed => 83i32,
            Self::AIET_StanddownHolster => 84i32,
            Self::AIET_ForcedIllegal => 85i32,
            Self::AIET_HitByItem => 86i32,
            Self::AIET_HitByCoin => 87i32,
            Self::AIET_LTHitByItemOrCoin => 88i32,
            Self::AIET_HitByItemOrCoinTwice => 89i32,
            Self::AIET_HitByThis => 90i32,
            Self::AIET_SeenInAccident => 91i32,
            Self::AIET_Trespassing_Strike_1 => 92i32,
            Self::AIET_Trespassing_Strike_2 => 93i32,
            Self::AIET_Trespassing_Strike_3 => 94i32,
            Self::AIET_DistractedByMovementInVegetation_Once => 95i32,
            Self::AIET_DistractedByMovementInVegetation_Twice => 96i32,
            Self::AIET_Investigate_Strike_1 => 97i32,
            Self::AIET_Investigate_Strike_2 => 98i32,
            Self::AIET_DisguiseEnforcer => 99i32,
            Self::AIET_Suspect => 100i32,
            Self::AIET_InSentryZone => 101i32,
            Self::AIET_MySentryZone => 102i32,
            Self::AIET_TriggerAlarm => 103i32,
            Self::AIET_LockdownIntruder => 104i32,
            Self::AIET_AccuseUnconscious => 105i32,
            Self::AIET_HasKnockMeDown => 106i32,
            Self::AIET_HasKnockSomeoneDown => 107i32,
            Self::AIET_InMyPrivateArea => 108i32,
            Self::AIET_KnownNaked => 109i32,
            Self::AIET_KnownDraggingBodybag => 110i32,
            Self::AIET_InvestigateOrder => 111i32,
            Self::AIET_ReactedSurprised => 112i32,
            Self::AIET_ReportGotShot => 113i32,
            Self::AIET_HasReportedDeadBodySituation => 114i32,
            Self::AIET_Social_TooClose => 115i32,
            Self::AIET_Social_Privacy => 116i32,
            Self::AIET_Social_Silly => 117i32,
            Self::AIET_ReactedToSituation => 118i32,
            Self::AIET_SeeAttached => 119i32,
            Self::AIET_WasInvisible => 120i32,
            Self::AIET_BlameHitman => 121i32,
            Self::AIET_BlamedByUnconscious => 122i32,
            Self::AIET_DontCareAboutBlaming => 123i32,
            Self::AIET_Combat_PropagatedBy => 124i32,
            Self::AIET_Combat_WithinPropagationField => 125i32,
            Self::AIET_Combat_MarkedAsDiscardable => 126i32,
            Self::AIET_Combat_AttackWitness => 127i32,
            Self::AIET_Combat_HomingAttackOrigin => 128i32,
            Self::AIET_Combat_VIPWasAttackedFromPosition => 129i32,
            Self::AIET_ReactedToSniperKnowledge => 130i32,
            Self::AIET_SniperCombatTarget => 131i32,
            Self::AIET_SniperCombatAimTarget => 132i32,
            Self::AIET_CantReachTarget => 133i32,
            Self::AIET_HuntingSniper => 134i32,
            Self::AIET_NeedCover => 135i32,
            Self::AIET_WaitingForSniper => 136i32,
            Self::AIET_HeardSniperShooting => 137i32,
            Self::AIET_KnownHidden => 138i32,
            Self::AIET_SituationTarget => 139i32,
            Self::AIET_TalkingToHitman => 140i32,
            Self::AIET_SuspiciousAction => 141i32,
            Self::AIET_RadioCallHelpingActor => 142i32,
            Self::AIET_WeaponContextKnown => 143i32,
            Self::AIET_IdleStandDown => 144i32,
            Self::AIET_IgnoreInvestigation => 145i32,
            Self::AIET_NewDisguiseTarget => 146i32,
            Self::AIET_SocialTarget => 147i32,
            Self::AIET_SecurityCamBroken => 148i32,
            Self::AIET_HeWoundedMeLongDistance => 149i32,
            Self::AIET_HeWoundedMeShortDistance => 150i32,
            Self::AIET_HeWoundedMeCC => 151i32,
            Self::AIET_HeAimedAtMe => 152i32,
            Self::AIET_BumpedIntoMe => 153i32,
            Self::AIET_ReactToDistraction => 154i32,
            Self::AIET_MovingToTarget => 155i32,
            Self::AIET_ReachedTarget => 156i32,
            Self::AIET_DistractionChainPart => 157i32,
            Self::AIET_NewDistractionChainPart => 158i32,
            Self::AIET_ChainFixed => 159i32,
            Self::AIET_SurprisePlayed => 160i32,
            Self::AIET_NewDistraction => 161i32,
            Self::AIET_WasSilly => 162i32,
            Self::AIET_Distraction_My_Leader => 163i32,
            Self::AIET_Distraction_My_Assistant => 164i32,
            Self::AIET_Distraction_Was_My_Assistant => 165i32,
            Self::AIET_AssitingWithSuitcase => 166i32,
            Self::AIET_SuitcaseAssistanceFaceToFace => 167i32,
            Self::AIET_SuitcaseAssistanceRadio => 168i32,
            Self::AIET_SC_CombatPosition => 169i32,
            Self::AIET_SC_CombatPositionMove => 170i32,
            Self::AIET_SC_CombatPositionFight => 171i32,
            Self::AIET_SC_PreventMovingThere => 172i32,
            Self::AIET_SC_JumpyReaction => 173i32,
            Self::AIET_DISTRACTION_TYPES_START => 174i32,
            Self::AIET_SeeInCoverDistraction => 175i32,
            Self::AIET_SeeSneakingDistraction => 176i32,
            Self::AIET_SeeStunnedDistraction => 177i32,
            Self::AIET_SeeSickDistraction => 178i32,
            Self::AIET_LegalItemDroppedDistraction => 179i32,
            Self::AIET_IllegalItemDroppedDistraction => 180i32,
            Self::AIET_BumpedDistraction => 181i32,
            Self::AIET_SightReactionDistraction => 182i32,
            Self::AIET_SightInvestigationDistraction => 183i32,
            Self::AIET_HearItemImpactDistraction => 184i32,
            Self::AIET_SeeCuriousPerceptibleDistraction => 185i32,
            Self::AIET_SeeCuriousItemDistraction => 186i32,
            Self::AIET_SeeFlyingItemDistraction => 187i32,
            Self::AIET_SeeThrowingDistraction => 188i32,
            Self::AIET_HitBySomethingDistraction => 189i32,
            Self::AIET_HearFootstepsDistraction => 190i32,
            Self::AIET_SeeAgility => 191i32,
            Self::AIET_SeeAgility_Vault => 192i32,
            Self::AIET_SeeAgility_Window => 193i32,
            Self::AIET_SeeHidding => 194i32,
            Self::AIET_HearStrangeSound => 195i32,
            Self::AIET_HearAlarm => 196i32,
            Self::AIET_HearRadio => 197i32,
            Self::AIET_HearAngry => 198i32,
            Self::AIET_HearHelp => 199i32,
            Self::AIET_HearAccident => 200i32,
            Self::AIET_HearCuriousCrowd => 201i32,
            Self::AIET_HearBulletImpact => 202i32,
            Self::AIET_HearPain => 203i32,
            Self::AIET_HearCuriousSound => 204i32,
            Self::AIET_HearCuriousItemSound => 205i32,
            Self::AIET_SecurityCameraBroken => 206i32,
            Self::AIET_SetpieceDistractionDefault => 207i32,
            Self::AIET_SeeItemTossDistraction => 208i32,
            Self::AIET_SetpieceDistractionDoor => 209i32,
            Self::AIET_SetpieceDistractionExperimental1 => 210i32,
            Self::AIET_SetpieceDistractionExperimental2 => 211i32,
            Self::AIET_SeeSuitcaseDistraction => 212i32,
            Self::AIET_Distraction_Silly => 213i32,
            Self::AIET_Distraction_TooClose => 214i32,
            Self::AIET_Distraction_Privacy => 215i32,
            Self::AIET_Distraction_MovementInVegetationBrief => 216i32,
            Self::AIET_Distraction_MovementInVegetationCurious => 217i32,
            Self::AIET_DISTRACTION_TYPES_END => 218i32,
            Self::AIET_ARREST_REASONS_START => 219i32,
            Self::AIET_ArrestReason_IllegalItem => 220i32,
            Self::AIET_ArrestReason_DragBody => 221i32,
            Self::AIET_ArrestReason_KnockDown => 222i32,
            Self::AIET_ARREST_REASONS_END => 223i32,
            Self::AIET_END_NORMAL_EVENTS => 224i32,
            Self::AIET_DEBUG_EVENTS_START => 225i32,
            Self::AIET_Debug_ThrowFlashbangHere => 226i32,
            Self::AIET_DEBUG_EVENTS_END => 227i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAIEventType {
     const TYPE_ID: &str = "EAIEventType";
}

impl StaticVariant for Vec<EAIEventType> {
     const TYPE_ID: &str = "TArray<EAIEventType>";
}

impl StaticVariant for Vec<Vec<EAIEventType>> {
     const TYPE_ID: &str = "TArray<TArray<EAIEventType>>";
}

impl Variant for EAIEventType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAIEventType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAIEventType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAIEventType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAIEventType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAIEventType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AudioCurve {
    AudioCurve_Log3,
    AudioCurve_Sine,
    AudioCurve_Log1,
    AudioCurve_InvSCurve,
    AudioCurve_Linear,
    AudioCurve_SCurve,
    AudioCurve_Exp1,
    AudioCurve_SineRecip,
    AudioCurve_Exp3,
    AudioCurve_LastFadeCurve,
    AudioCurve_Constant,
}

impl Aligned for AudioCurve {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for AudioCurve {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AudioCurve_Log3 => 0i8,
            Self::AudioCurve_Sine => 1i8,
            Self::AudioCurve_Log1 => 2i8,
            Self::AudioCurve_InvSCurve => 3i8,
            Self::AudioCurve_Linear => 4i8,
            Self::AudioCurve_SCurve => 5i8,
            Self::AudioCurve_Exp1 => 6i8,
            Self::AudioCurve_SineRecip => 7i8,
            Self::AudioCurve_Exp3 => 8i8,
            Self::AudioCurve_LastFadeCurve => 9i8,
            Self::AudioCurve_Constant => 10i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for AudioCurve {
     const TYPE_ID: &str = "AudioCurve";
}

impl StaticVariant for Vec<AudioCurve> {
     const TYPE_ID: &str = "TArray<AudioCurve>";
}

impl StaticVariant for Vec<Vec<AudioCurve>> {
     const TYPE_ID: &str = "TArray<TArray<AudioCurve>>";
}

impl Variant for AudioCurve {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("AudioCurve")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("AudioCurve".into()))
    }
}

inventory::submit!(&VariantDeserializer::<AudioCurve>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<AudioCurve>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<AudioCurve>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum AudioEventCullingBehavior {
    AutoSendStop,
    AutoSendStopAfterTriggered,
    NoAutoSendStop,
    NoDistanceCulling,
}

impl Aligned for AudioEventCullingBehavior {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for AudioEventCullingBehavior {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AutoSendStop => 0i8,
            Self::AutoSendStopAfterTriggered => 1i8,
            Self::NoAutoSendStop => 2i8,
            Self::NoDistanceCulling => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for AudioEventCullingBehavior {
     const TYPE_ID: &str = "AudioEventCullingBehavior";
}

impl StaticVariant for Vec<AudioEventCullingBehavior> {
     const TYPE_ID: &str = "TArray<AudioEventCullingBehavior>";
}

impl StaticVariant for Vec<Vec<AudioEventCullingBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<AudioEventCullingBehavior>>";
}

impl Variant for AudioEventCullingBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("AudioEventCullingBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("AudioEventCullingBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<AudioEventCullingBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<AudioEventCullingBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<AudioEventCullingBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum BoneId_Enum {
    GROUND,
    PELVIS,
    SPINE,
    SPINE_1,
    SPINE_2,
    NECK,
    NECK1,
    HEAD,
    LEFT_THIGH,
    LEFT_THIGH_TWIST,
    LEFT_THIGH_TWIST1,
    LEFT_THIGH_TWIST2,
    LEFT_CALF,
    LEFT_FOOT,
    LEFT_TOE,
    LEFT_TOENUB,
    RIGHT_THIGH,
    RIGHT_THIGH_TWIST,
    RIGHT_THIGH_TWIST1,
    RIGHT_THIGH_TWIST2,
    RIGHT_CALF,
    RIGHT_FOOT,
    RIGHT_TOE,
    RIGHT_TOENUB,
    LEFT_CLAVICLE,
    LEFT_UPPER_ARM,
    LEFT_UPPER_ARM_TWIST,
    LEFT_UPPER_ARM_TWIST1,
    LEFT_UPPER_ARM_TWIST2,
    LEFT_FOREARM,
    LEFT_FORETWIST,
    LEFT_FORETWIST1,
    LEFT_FORETWIST2,
    LEFT_HAND,
    LEFT_FINGER_0,
    LEFT_FINGER_01,
    LEFT_FINGER_02,
    LEFT_FINGER_1,
    LEFT_FINGER_11,
    LEFT_FINGER_12,
    LEFT_FINGER_2,
    LEFT_FINGER_21,
    LEFT_FINGER_22,
    LEFT_FINGER_3,
    LEFT_FINGER_31,
    LEFT_FINGER_32,
    LEFT_FINGER_4,
    LEFT_FINGER_41,
    LEFT_FINGER_42,
    RIGHT_CLAVICLE,
    RIGHT_UPPER_ARM,
    RIGHT_UPPER_ARM_TWIST,
    RIGHT_UPPER_ARM_TWIST1,
    RIGHT_UPPER_ARM_TWIST2,
    RIGHT_FOREARM,
    RIGHT_FORETWIST,
    RIGHT_FORETWIST1,
    RIGHT_FORETWIST2,
    RIGHT_HAND,
    RIGHT_FINGER_0,
    RIGHT_FINGER_01,
    RIGHT_FINGER_02,
    RIGHT_FINGER_1,
    RIGHT_FINGER_11,
    RIGHT_FINGER_12,
    RIGHT_FINGER_2,
    RIGHT_FINGER_21,
    RIGHT_FINGER_22,
    RIGHT_FINGER_3,
    RIGHT_FINGER_31,
    RIGHT_FINGER_32,
    RIGHT_FINGER_4,
    RIGHT_FINGER_41,
    RIGHT_FINGER_42,
    XTRA_MUS_R_HIP,
    XTRA_MUS_L_HIP,
    RIGHT_HAND_ATTACHER,
    LEFT_HAND_ATTACHER,
    HIP_ATTACHER,
    BACK_ATTACHER,
    FREE_ATTACHER,
    CAMERA_ATTACHER_01,
    CAMERA_ATTACHER_02,
    FREE_ATTACHER_PROP_01,
    FREE_ATTACHER_PROP_02,
    LEFT_EYE,
    LEFT_EYE_LID,
    RIGHT_EYE,
    RIGHT_EYE_LID,
    LOWER_LIP,
    JAW,
    HOLSTER_ATTACHER,
    LEFT_WRIST_EFFECTOR,
    LEFT_FINGER_0_EFFECTOR,
    LEFT_FINGER_1_EFFECTOR,
    LEFT_FINGER_2_EFFECTOR,
    LEFT_FINGER_3_EFFECTOR,
    LEFT_FINGER_4_EFFECTOR,
    RIGHT_WRIST_EFFECTOR,
    RIGHT_FINGER_0_EFFECTOR,
    RIGHT_FINGER_1_EFFECTOR,
    RIGHT_FINGER_2_EFFECTOR,
    RIGHT_FINGER_3_EFFECTOR,
    RIGHT_FINGER_4_EFFECTOR,
    XTRA_MUS_L_PEC,
    XTRA_MUS_R_PEC,
    XTRA_MUS_NECK,
    XTRA_MUS_L_ELBOW,
    XTRA_MUS_R_ELBOW,
    XTRA_MUS_L_ASS,
    XTRA_MUS_R_ASS,
    XTRA_MUS_L_TOE,
    XTRA_MUS_L_KNEE,
    XTRA_MUS_L_FOOT,
    XTRA_MUS_R_TOE,
    XTRA_MUS_R_KNEE,
    XTRA_MUS_R_FOOT,
    XTRA_TARGET_R_FOOT,
    XTRA_PIVOT_R_HEEL,
    XTRA_TARGET_R_KNEE,
    XTRA_ALIGN_R_KNEE,
    XTRA_TARGET_L_FOOT,
    XTRA_PIVOT_L_HEEL,
    XTRA_TARGET_L_KNEE,
    XTRA_ALIGN_L_KNEE,
    XTRA_TARGET_R_ASS,
    XTRA_TARGET_L_ASS,
    XTRA_ALIGN_L_ASS,
    XTRA_ALIGN_R_ASS,
    XTRA_UP_THIGH,
    XTRA_TARGET_R_PEC,
    XTRA_ALIGN_R_ELBOW,
    XTRA_TARGET_R_ELBOW,
    XTRA_TARGET_L_PEC,
    XTRA_ALIGN_L_ELBOW,
    XTRA_TARGET_L_ELBOW,
    XTRA_ALIGN_L_PEC,
    XTRA_UP_PEC,
    XTRA_ALIGN_R_PEC,
    XTRA_ALIGN_NECK,
    HEAD_ATTACHER,
    RIFLE_HOLSTER_ATTACHER,
    SPINE1_ATTACHER,
    PISTOL_HOLSTER_ATTACHER,
    BONEID_LAST,
}

impl Aligned for BoneId_Enum {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for BoneId_Enum {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GROUND => 0i32,
            Self::PELVIS => 1i32,
            Self::SPINE => 2i32,
            Self::SPINE_1 => 3i32,
            Self::SPINE_2 => 4i32,
            Self::NECK => 5i32,
            Self::NECK1 => 6i32,
            Self::HEAD => 7i32,
            Self::LEFT_THIGH => 8i32,
            Self::LEFT_THIGH_TWIST => 9i32,
            Self::LEFT_THIGH_TWIST1 => 10i32,
            Self::LEFT_THIGH_TWIST2 => 11i32,
            Self::LEFT_CALF => 12i32,
            Self::LEFT_FOOT => 13i32,
            Self::LEFT_TOE => 14i32,
            Self::LEFT_TOENUB => 15i32,
            Self::RIGHT_THIGH => 16i32,
            Self::RIGHT_THIGH_TWIST => 17i32,
            Self::RIGHT_THIGH_TWIST1 => 18i32,
            Self::RIGHT_THIGH_TWIST2 => 19i32,
            Self::RIGHT_CALF => 20i32,
            Self::RIGHT_FOOT => 21i32,
            Self::RIGHT_TOE => 22i32,
            Self::RIGHT_TOENUB => 23i32,
            Self::LEFT_CLAVICLE => 24i32,
            Self::LEFT_UPPER_ARM => 25i32,
            Self::LEFT_UPPER_ARM_TWIST => 26i32,
            Self::LEFT_UPPER_ARM_TWIST1 => 27i32,
            Self::LEFT_UPPER_ARM_TWIST2 => 28i32,
            Self::LEFT_FOREARM => 29i32,
            Self::LEFT_FORETWIST => 30i32,
            Self::LEFT_FORETWIST1 => 31i32,
            Self::LEFT_FORETWIST2 => 32i32,
            Self::LEFT_HAND => 33i32,
            Self::LEFT_FINGER_0 => 34i32,
            Self::LEFT_FINGER_01 => 35i32,
            Self::LEFT_FINGER_02 => 36i32,
            Self::LEFT_FINGER_1 => 37i32,
            Self::LEFT_FINGER_11 => 38i32,
            Self::LEFT_FINGER_12 => 39i32,
            Self::LEFT_FINGER_2 => 40i32,
            Self::LEFT_FINGER_21 => 41i32,
            Self::LEFT_FINGER_22 => 42i32,
            Self::LEFT_FINGER_3 => 43i32,
            Self::LEFT_FINGER_31 => 44i32,
            Self::LEFT_FINGER_32 => 45i32,
            Self::LEFT_FINGER_4 => 46i32,
            Self::LEFT_FINGER_41 => 47i32,
            Self::LEFT_FINGER_42 => 48i32,
            Self::RIGHT_CLAVICLE => 49i32,
            Self::RIGHT_UPPER_ARM => 50i32,
            Self::RIGHT_UPPER_ARM_TWIST => 51i32,
            Self::RIGHT_UPPER_ARM_TWIST1 => 52i32,
            Self::RIGHT_UPPER_ARM_TWIST2 => 53i32,
            Self::RIGHT_FOREARM => 54i32,
            Self::RIGHT_FORETWIST => 55i32,
            Self::RIGHT_FORETWIST1 => 56i32,
            Self::RIGHT_FORETWIST2 => 57i32,
            Self::RIGHT_HAND => 58i32,
            Self::RIGHT_FINGER_0 => 59i32,
            Self::RIGHT_FINGER_01 => 60i32,
            Self::RIGHT_FINGER_02 => 61i32,
            Self::RIGHT_FINGER_1 => 62i32,
            Self::RIGHT_FINGER_11 => 63i32,
            Self::RIGHT_FINGER_12 => 64i32,
            Self::RIGHT_FINGER_2 => 65i32,
            Self::RIGHT_FINGER_21 => 66i32,
            Self::RIGHT_FINGER_22 => 67i32,
            Self::RIGHT_FINGER_3 => 68i32,
            Self::RIGHT_FINGER_31 => 69i32,
            Self::RIGHT_FINGER_32 => 70i32,
            Self::RIGHT_FINGER_4 => 71i32,
            Self::RIGHT_FINGER_41 => 72i32,
            Self::RIGHT_FINGER_42 => 73i32,
            Self::XTRA_MUS_R_HIP => 74i32,
            Self::XTRA_MUS_L_HIP => 75i32,
            Self::RIGHT_HAND_ATTACHER => 76i32,
            Self::LEFT_HAND_ATTACHER => 77i32,
            Self::HIP_ATTACHER => 78i32,
            Self::BACK_ATTACHER => 79i32,
            Self::FREE_ATTACHER => 80i32,
            Self::CAMERA_ATTACHER_01 => 81i32,
            Self::CAMERA_ATTACHER_02 => 82i32,
            Self::FREE_ATTACHER_PROP_01 => 83i32,
            Self::FREE_ATTACHER_PROP_02 => 84i32,
            Self::LEFT_EYE => 85i32,
            Self::LEFT_EYE_LID => 86i32,
            Self::RIGHT_EYE => 87i32,
            Self::RIGHT_EYE_LID => 88i32,
            Self::LOWER_LIP => 89i32,
            Self::JAW => 90i32,
            Self::HOLSTER_ATTACHER => 91i32,
            Self::LEFT_WRIST_EFFECTOR => 92i32,
            Self::LEFT_FINGER_0_EFFECTOR => 93i32,
            Self::LEFT_FINGER_1_EFFECTOR => 94i32,
            Self::LEFT_FINGER_2_EFFECTOR => 95i32,
            Self::LEFT_FINGER_3_EFFECTOR => 96i32,
            Self::LEFT_FINGER_4_EFFECTOR => 97i32,
            Self::RIGHT_WRIST_EFFECTOR => 98i32,
            Self::RIGHT_FINGER_0_EFFECTOR => 99i32,
            Self::RIGHT_FINGER_1_EFFECTOR => 100i32,
            Self::RIGHT_FINGER_2_EFFECTOR => 101i32,
            Self::RIGHT_FINGER_3_EFFECTOR => 102i32,
            Self::RIGHT_FINGER_4_EFFECTOR => 103i32,
            Self::XTRA_MUS_L_PEC => 104i32,
            Self::XTRA_MUS_R_PEC => 105i32,
            Self::XTRA_MUS_NECK => 106i32,
            Self::XTRA_MUS_L_ELBOW => 107i32,
            Self::XTRA_MUS_R_ELBOW => 108i32,
            Self::XTRA_MUS_L_ASS => 109i32,
            Self::XTRA_MUS_R_ASS => 110i32,
            Self::XTRA_MUS_L_TOE => 111i32,
            Self::XTRA_MUS_L_KNEE => 112i32,
            Self::XTRA_MUS_L_FOOT => 113i32,
            Self::XTRA_MUS_R_TOE => 114i32,
            Self::XTRA_MUS_R_KNEE => 115i32,
            Self::XTRA_MUS_R_FOOT => 116i32,
            Self::XTRA_TARGET_R_FOOT => 117i32,
            Self::XTRA_PIVOT_R_HEEL => 118i32,
            Self::XTRA_TARGET_R_KNEE => 119i32,
            Self::XTRA_ALIGN_R_KNEE => 120i32,
            Self::XTRA_TARGET_L_FOOT => 121i32,
            Self::XTRA_PIVOT_L_HEEL => 122i32,
            Self::XTRA_TARGET_L_KNEE => 123i32,
            Self::XTRA_ALIGN_L_KNEE => 124i32,
            Self::XTRA_TARGET_R_ASS => 125i32,
            Self::XTRA_TARGET_L_ASS => 126i32,
            Self::XTRA_ALIGN_L_ASS => 127i32,
            Self::XTRA_ALIGN_R_ASS => 128i32,
            Self::XTRA_UP_THIGH => 129i32,
            Self::XTRA_TARGET_R_PEC => 130i32,
            Self::XTRA_ALIGN_R_ELBOW => 131i32,
            Self::XTRA_TARGET_R_ELBOW => 132i32,
            Self::XTRA_TARGET_L_PEC => 133i32,
            Self::XTRA_ALIGN_L_ELBOW => 134i32,
            Self::XTRA_TARGET_L_ELBOW => 135i32,
            Self::XTRA_ALIGN_L_PEC => 136i32,
            Self::XTRA_UP_PEC => 137i32,
            Self::XTRA_ALIGN_R_PEC => 138i32,
            Self::XTRA_ALIGN_NECK => 139i32,
            Self::HEAD_ATTACHER => 140i32,
            Self::RIFLE_HOLSTER_ATTACHER => 141i32,
            Self::SPINE1_ATTACHER => 142i32,
            Self::PISTOL_HOLSTER_ATTACHER => 143i32,
            Self::BONEID_LAST => 144i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for BoneId_Enum {
     const TYPE_ID: &str = "BoneId_Enum";
}

impl StaticVariant for Vec<BoneId_Enum> {
     const TYPE_ID: &str = "TArray<BoneId_Enum>";
}

impl StaticVariant for Vec<Vec<BoneId_Enum>> {
     const TYPE_ID: &str = "TArray<TArray<BoneId_Enum>>";
}

impl Variant for BoneId_Enum {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("BoneId_Enum")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("BoneId_Enum".into()))
    }
}

inventory::submit!(&VariantDeserializer::<BoneId_Enum>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<BoneId_Enum>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<BoneId_Enum>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdMapImpl_CellFlags {
    CELLFLAG_RESTRICTED_A,
    CELLFLAG_RESTRICTED_B,
    CELLFLAG_RESTRICTED_C,
    CELLFLAG_WALKABLE,
    CELLFLAG_TELEPORT_IN,
    CELLFLAG_TELEPORT_OUT,
    CELLFLAG_UNUSED,
    CELLFLAG_PANIC_ONLY,
}

impl Aligned for CrowdMapImpl_CellFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdMapImpl_CellFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CELLFLAG_RESTRICTED_A => 1i32,
            Self::CELLFLAG_RESTRICTED_B => 2i32,
            Self::CELLFLAG_RESTRICTED_C => 4i32,
            Self::CELLFLAG_WALKABLE => 8i32,
            Self::CELLFLAG_TELEPORT_IN => 16i32,
            Self::CELLFLAG_TELEPORT_OUT => 32i32,
            Self::CELLFLAG_UNUSED => 64i32,
            Self::CELLFLAG_PANIC_ONLY => 128i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdMapImpl_CellFlags {
     const TYPE_ID: &str = "CrowdMapImpl_CellFlags";
}

impl StaticVariant for Vec<CrowdMapImpl_CellFlags> {
     const TYPE_ID: &str = "TArray<CrowdMapImpl_CellFlags>";
}

impl StaticVariant for Vec<Vec<CrowdMapImpl_CellFlags>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdMapImpl_CellFlags>>";
}

impl Variant for CrowdMapImpl_CellFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdMapImpl_CellFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdMapImpl_CellFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdMapImpl_CellFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdMapImpl_CellFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdMapImpl_CellFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdReactionAIEventType {
    CROWDAIEVENT_NONE,
    CROWDAIEVENT_CURIOUS,
    CROWDAIEVENT_ALERTED,
    CROWDAIEVENT_BLAME_FOR_WEAPON,
    CROWDAIEVENT_BLAME_FOR_KILL,
}

impl Aligned for CrowdReactionAIEventType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdReactionAIEventType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CROWDAIEVENT_NONE => 0i32,
            Self::CROWDAIEVENT_CURIOUS => 1i32,
            Self::CROWDAIEVENT_ALERTED => 2i32,
            Self::CROWDAIEVENT_BLAME_FOR_WEAPON => 3i32,
            Self::CROWDAIEVENT_BLAME_FOR_KILL => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdReactionAIEventType {
     const TYPE_ID: &str = "CrowdReactionAIEventType";
}

impl StaticVariant for Vec<CrowdReactionAIEventType> {
     const TYPE_ID: &str = "TArray<CrowdReactionAIEventType>";
}

impl StaticVariant for Vec<Vec<CrowdReactionAIEventType>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdReactionAIEventType>>";
}

impl Variant for CrowdReactionAIEventType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdReactionAIEventType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdReactionAIEventType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdReactionAIEventType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdReactionAIEventType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdReactionAIEventType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdRegionType {
    CROWDSPHERE_NONE,
    CROWDSPHERE_SAFE,
    CROWDSPHERE_POI,
    CROWDSPHERE_AVOID,
    CROWDSPHERE_RELOCATE,
    CROWDSPHERE_STOP,
    CROWDSPHERE_ALERT,
    CROWDSPHERE_SCARE,
    CROWDSPHERE_GETDOWN,
    CROWDSPHERE_DIE,
}

impl Aligned for CrowdRegionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdRegionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CROWDSPHERE_NONE => 0i32,
            Self::CROWDSPHERE_SAFE => 1i32,
            Self::CROWDSPHERE_POI => 2i32,
            Self::CROWDSPHERE_AVOID => 3i32,
            Self::CROWDSPHERE_RELOCATE => 4i32,
            Self::CROWDSPHERE_STOP => 5i32,
            Self::CROWDSPHERE_ALERT => 6i32,
            Self::CROWDSPHERE_SCARE => 7i32,
            Self::CROWDSPHERE_GETDOWN => 8i32,
            Self::CROWDSPHERE_DIE => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdRegionType {
     const TYPE_ID: &str = "CrowdRegionType";
}

impl StaticVariant for Vec<CrowdRegionType> {
     const TYPE_ID: &str = "TArray<CrowdRegionType>";
}

impl StaticVariant for Vec<Vec<CrowdRegionType>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdRegionType>>";
}

impl Variant for CrowdRegionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdRegionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdRegionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdRegionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdRegionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdRegionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_ECrowdActorMood {
    CM_AMBIENT,
    CM_ALERTED,
    CM_SCARED,
    CM_PANICED,
    CM_DEAD,
    CM_DISABLED,
    NUM_ACTOR_MOOD_TYPES,
}

impl Aligned for CrowdUtil_ECrowdActorMood {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_ECrowdActorMood {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CM_AMBIENT => 0i32,
            Self::CM_ALERTED => 1i32,
            Self::CM_SCARED => 2i32,
            Self::CM_PANICED => 3i32,
            Self::CM_DEAD => 4i32,
            Self::CM_DISABLED => 5i32,
            Self::NUM_ACTOR_MOOD_TYPES => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_ECrowdActorMood {
     const TYPE_ID: &str = "CrowdUtil_ECrowdActorMood";
}

impl StaticVariant for Vec<CrowdUtil_ECrowdActorMood> {
     const TYPE_ID: &str = "TArray<CrowdUtil_ECrowdActorMood>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_ECrowdActorMood>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_ECrowdActorMood>>";
}

impl Variant for CrowdUtil_ECrowdActorMood {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_ECrowdActorMood")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_ECrowdActorMood".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_ECrowdActorMood>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_ECrowdActorMood>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_ECrowdActorMood>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_ECrowdDirection {
    NORTH,
    EAST,
    SOUTH,
    WEST,
}

impl Aligned for CrowdUtil_ECrowdDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_ECrowdDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NORTH => 0i32,
            Self::EAST => 1i32,
            Self::SOUTH => 2i32,
            Self::WEST => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_ECrowdDirection {
     const TYPE_ID: &str = "CrowdUtil_ECrowdDirection";
}

impl StaticVariant for Vec<CrowdUtil_ECrowdDirection> {
     const TYPE_ID: &str = "TArray<CrowdUtil_ECrowdDirection>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_ECrowdDirection>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_ECrowdDirection>>";
}

impl Variant for CrowdUtil_ECrowdDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_ECrowdDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_ECrowdDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_ECrowdDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_ECrowdDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_ECrowdDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_ECrowdFacing {
    FRONT,
    BACK,
}

impl Aligned for CrowdUtil_ECrowdFacing {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_ECrowdFacing {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FRONT => 0i32,
            Self::BACK => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_ECrowdFacing {
     const TYPE_ID: &str = "CrowdUtil_ECrowdFacing";
}

impl StaticVariant for Vec<CrowdUtil_ECrowdFacing> {
     const TYPE_ID: &str = "TArray<CrowdUtil_ECrowdFacing>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_ECrowdFacing>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_ECrowdFacing>>";
}

impl Variant for CrowdUtil_ECrowdFacing {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_ECrowdFacing")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_ECrowdFacing".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_ECrowdFacing>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_ECrowdFacing>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_ECrowdFacing>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_ECrowdSide {
    LEFT,
    RIGHT,
}

impl Aligned for CrowdUtil_ECrowdSide {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_ECrowdSide {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LEFT => 0i32,
            Self::RIGHT => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_ECrowdSide {
     const TYPE_ID: &str = "CrowdUtil_ECrowdSide";
}

impl StaticVariant for Vec<CrowdUtil_ECrowdSide> {
     const TYPE_ID: &str = "TArray<CrowdUtil_ECrowdSide>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_ECrowdSide>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_ECrowdSide>>";
}

impl Variant for CrowdUtil_ECrowdSide {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_ECrowdSide")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_ECrowdSide".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_ECrowdSide>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_ECrowdSide>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_ECrowdSide>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_ECrowdStandingPush {
    PUSH_FRONT,
    PUSH_FRONT_LEFT,
    PUSH_LEFT,
    PUSH_BACK_LEFT,
    PUSH_BACK,
    PUSH_BACK_RIGHT,
    PUSH_RIGHT,
    PUSH_FRONT_RIGHT,
}

impl Aligned for CrowdUtil_ECrowdStandingPush {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_ECrowdStandingPush {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PUSH_FRONT => 0i32,
            Self::PUSH_FRONT_LEFT => 1i32,
            Self::PUSH_LEFT => 2i32,
            Self::PUSH_BACK_LEFT => 3i32,
            Self::PUSH_BACK => 4i32,
            Self::PUSH_BACK_RIGHT => 5i32,
            Self::PUSH_RIGHT => 6i32,
            Self::PUSH_FRONT_RIGHT => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_ECrowdStandingPush {
     const TYPE_ID: &str = "CrowdUtil_ECrowdStandingPush";
}

impl StaticVariant for Vec<CrowdUtil_ECrowdStandingPush> {
     const TYPE_ID: &str = "TArray<CrowdUtil_ECrowdStandingPush>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_ECrowdStandingPush>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_ECrowdStandingPush>>";
}

impl Variant for CrowdUtil_ECrowdStandingPush {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_ECrowdStandingPush")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_ECrowdStandingPush".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_ECrowdStandingPush>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_ECrowdStandingPush>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_ECrowdStandingPush>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_EDefaultStateTypes {
    STATE_IDLE,
    STATE_WALK,
    STATE_PENDINGWALK,
    STATE_DEAD,
    STATE_SCARED,
    STATE_PENDINGSCARED,
    STATE_POSSESSED,
    STATE_ALERT,
    STATE_PRONE,
    STATE_RELOCATE,
    STATE_PENDINGRELOCATE,
    NUM_DEFAULT_STATES,
}

impl Aligned for CrowdUtil_EDefaultStateTypes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_EDefaultStateTypes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::STATE_IDLE => 0i32,
            Self::STATE_WALK => 1i32,
            Self::STATE_PENDINGWALK => 2i32,
            Self::STATE_DEAD => 3i32,
            Self::STATE_SCARED => 4i32,
            Self::STATE_PENDINGSCARED => 5i32,
            Self::STATE_POSSESSED => 6i32,
            Self::STATE_ALERT => 7i32,
            Self::STATE_PRONE => 8i32,
            Self::STATE_RELOCATE => 9i32,
            Self::STATE_PENDINGRELOCATE => 10i32,
            Self::NUM_DEFAULT_STATES => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_EDefaultStateTypes {
     const TYPE_ID: &str = "CrowdUtil_EDefaultStateTypes";
}

impl StaticVariant for Vec<CrowdUtil_EDefaultStateTypes> {
     const TYPE_ID: &str = "TArray<CrowdUtil_EDefaultStateTypes>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_EDefaultStateTypes>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_EDefaultStateTypes>>";
}

impl Variant for CrowdUtil_EDefaultStateTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_EDefaultStateTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_EDefaultStateTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_EDefaultStateTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_EDefaultStateTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_EDefaultStateTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum CrowdUtil_EGenderReq {
    eGender_Any,
    eGender_Male,
    eGender_Female,
}

impl Aligned for CrowdUtil_EGenderReq {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for CrowdUtil_EGenderReq {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGender_Any => 0i32,
            Self::eGender_Male => 1i32,
            Self::eGender_Female => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for CrowdUtil_EGenderReq {
     const TYPE_ID: &str = "CrowdUtil_EGenderReq";
}

impl StaticVariant for Vec<CrowdUtil_EGenderReq> {
     const TYPE_ID: &str = "TArray<CrowdUtil_EGenderReq>";
}

impl StaticVariant for Vec<Vec<CrowdUtil_EGenderReq>> {
     const TYPE_ID: &str = "TArray<TArray<CrowdUtil_EGenderReq>>";
}

impl Variant for CrowdUtil_EGenderReq {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("CrowdUtil_EGenderReq")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("CrowdUtil_EGenderReq".into()))
    }
}

inventory::submit!(&VariantDeserializer::<CrowdUtil_EGenderReq>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<CrowdUtil_EGenderReq>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<CrowdUtil_EGenderReq>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAIFormationMemberSpeed {
    eFMS_Slow,
    eFMS_Normal,
    eFMS_Fast,
}

impl Aligned for EAIFormationMemberSpeed {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAIFormationMemberSpeed {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFMS_Slow => 0i32,
            Self::eFMS_Normal => 1i32,
            Self::eFMS_Fast => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAIFormationMemberSpeed {
     const TYPE_ID: &str = "EAIFormationMemberSpeed";
}

impl StaticVariant for Vec<EAIFormationMemberSpeed> {
     const TYPE_ID: &str = "TArray<EAIFormationMemberSpeed>";
}

impl StaticVariant for Vec<Vec<EAIFormationMemberSpeed>> {
     const TYPE_ID: &str = "TArray<TArray<EAIFormationMemberSpeed>>";
}

impl Variant for EAIFormationMemberSpeed {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAIFormationMemberSpeed")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAIFormationMemberSpeed".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAIFormationMemberSpeed>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAIFormationMemberSpeed>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAIFormationMemberSpeed>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAIGoal {
    AIG_Kill,
    AIG_Arrest,
    AIG_FightSniper,
    AIG_HelpCivilian,
    AIG_HelpCivilianWeapon,
    AIG_Investigate,
    AIG_InvestigateDisguise,
    AIG_StandOffInvestigateDisguise,
    AIG_InvestigateDeadBody,
    AIG_HandleTrespasser,
    AIG_InvestigateCautious,
    AIG_HandleDistraction,
    AIG_AssistDistraction,
    AIG_GuardAssistDistraction,
    AIG_HandleSuitcase,
    AIG_InvestigateWeapon,
    AIG_DetectedInPrivate,
    AIG_RecoverUnconscious,
    AIG_RecoverUnconsciousAlerted,
    AIG_DeliverWeapon,
    AIG_AvoidExplosion,
    AIG_Hunt,
    AIG_Frisk,
    AIG_GuardBody,
    AIG_DragBody,
    AIG_LookAtAccident,
    AIG_Sentry,
    AIG_HelpGeneric,
    AIG_Evacuate,
    AIG_Entourage,
    AIG_AvoidDangerousArea,
    AIG_Spectator,
    AIG_Infected,
    AIG_SC_Combat,
    AIG_SC_Alerted,
    AIG_None,
}

impl Aligned for EAIGoal {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAIGoal {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIG_Kill => 0i32,
            Self::AIG_Arrest => 1i32,
            Self::AIG_FightSniper => 2i32,
            Self::AIG_HelpCivilian => 3i32,
            Self::AIG_HelpCivilianWeapon => 4i32,
            Self::AIG_Investigate => 5i32,
            Self::AIG_InvestigateDisguise => 6i32,
            Self::AIG_StandOffInvestigateDisguise => 7i32,
            Self::AIG_InvestigateDeadBody => 8i32,
            Self::AIG_HandleTrespasser => 9i32,
            Self::AIG_InvestigateCautious => 10i32,
            Self::AIG_HandleDistraction => 11i32,
            Self::AIG_AssistDistraction => 12i32,
            Self::AIG_GuardAssistDistraction => 13i32,
            Self::AIG_HandleSuitcase => 14i32,
            Self::AIG_InvestigateWeapon => 15i32,
            Self::AIG_DetectedInPrivate => 16i32,
            Self::AIG_RecoverUnconscious => 17i32,
            Self::AIG_RecoverUnconsciousAlerted => 18i32,
            Self::AIG_DeliverWeapon => 19i32,
            Self::AIG_AvoidExplosion => 20i32,
            Self::AIG_Hunt => 21i32,
            Self::AIG_Frisk => 22i32,
            Self::AIG_GuardBody => 23i32,
            Self::AIG_DragBody => 24i32,
            Self::AIG_LookAtAccident => 25i32,
            Self::AIG_Sentry => 26i32,
            Self::AIG_HelpGeneric => 27i32,
            Self::AIG_Evacuate => 28i32,
            Self::AIG_Entourage => 29i32,
            Self::AIG_AvoidDangerousArea => 30i32,
            Self::AIG_Spectator => 31i32,
            Self::AIG_Infected => 32i32,
            Self::AIG_SC_Combat => 33i32,
            Self::AIG_SC_Alerted => 34i32,
            Self::AIG_None => 35i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAIGoal {
     const TYPE_ID: &str = "EAIGoal";
}

impl StaticVariant for Vec<EAIGoal> {
     const TYPE_ID: &str = "TArray<EAIGoal>";
}

impl StaticVariant for Vec<Vec<EAIGoal>> {
     const TYPE_ID: &str = "TArray<TArray<EAIGoal>>";
}

impl Variant for EAIGoal {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAIGoal")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAIGoal".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAIGoal>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAIGoal>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAIGoal>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAILegalType {
    AILT_Weapon,
    AILT_Shooting,
    AILT_Aiming,
    AILT_CloseCombat,
    AILT_ChangeOutfit,
    AILT_Count,
}

impl Aligned for EAILegalType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAILegalType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AILT_Weapon => 0i32,
            Self::AILT_Shooting => 1i32,
            Self::AILT_Aiming => 2i32,
            Self::AILT_CloseCombat => 3i32,
            Self::AILT_ChangeOutfit => 4i32,
            Self::AILT_Count => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAILegalType {
     const TYPE_ID: &str = "EAILegalType";
}

impl StaticVariant for Vec<EAILegalType> {
     const TYPE_ID: &str = "TArray<EAILegalType>";
}

impl StaticVariant for Vec<Vec<EAILegalType>> {
     const TYPE_ID: &str = "TArray<TArray<EAILegalType>>";
}

impl Variant for EAILegalType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAILegalType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAILegalType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAILegalType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAILegalType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAILegalType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAIModifierScope {
    AIMS_Volume,
    AIMS_Behavior,
    AIMS_Role,
    AIMS_Item,
    AIMS_Situation,
    AIMS_Outfit,
    AIMS_Override,
    AIMS_Status,
}

impl Aligned for EAIModifierScope {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAIModifierScope {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIMS_Volume => 0i32,
            Self::AIMS_Behavior => 1i32,
            Self::AIMS_Role => 2i32,
            Self::AIMS_Item => 3i32,
            Self::AIMS_Situation => 4i32,
            Self::AIMS_Outfit => 5i32,
            Self::AIMS_Override => 6i32,
            Self::AIMS_Status => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAIModifierScope {
     const TYPE_ID: &str = "EAIModifierScope";
}

impl StaticVariant for Vec<EAIModifierScope> {
     const TYPE_ID: &str = "TArray<EAIModifierScope>";
}

impl StaticVariant for Vec<Vec<EAIModifierScope>> {
     const TYPE_ID: &str = "TArray<TArray<EAIModifierScope>>";
}

impl Variant for EAIModifierScope {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAIModifierScope")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAIModifierScope".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAIModifierScope>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAIModifierScope>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAIModifierScope>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAIModifiers {
    AIM_Invalid,
    AIM_IgnoreLowNoise,
    AIM_IgnoreHitmanPropToss,
    AIM_IgnoreAnnoyingHitman,
    AIM_IgnoreSneakyHitman,
    AIM_IgnoreAgileHitman,
    AIM_IgnoreSillyHitman,
    AIM_PreferredInvestigator,
    AIM_AccidentShy,
    AIM_PreferredAccidentInvestigator,
    AIM_BlockFiberWireInteraction,
    AIM_BlockCloseCombatInteraction,
    AIM_BlockDragBodyInteraction,
    AIM_BlockAllInteractions,
    AIM_IgnoreDistractions,
    AIM_IgnoreTrespassing,
    AIM_IgnoreWeapons,
    AIM_IgnoreLockdown,
    AIM_DisableHelpCivilian,
    AIM_WantsPrivacy,
    AIM_ConversationHelper,
    AIM_ConversationHelperFast,
    AIM_OneHitpoint,
    AIM_BlockDeadlyThrow,
    AIM_SuppressSocialGreeting,
    AIM_NeverInvestigateAccidents,
    AIM_BlockDeath,
    AIM_IgnoreDeadBody,
    AIM_NeverSpectate,
    AIM_DisableDeadBodySensor,
    AIM_DeafAndBlind,
}

impl Aligned for EAIModifiers {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAIModifiers {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIM_Invalid => 0i32,
            Self::AIM_IgnoreLowNoise => 1i32,
            Self::AIM_IgnoreHitmanPropToss => 2i32,
            Self::AIM_IgnoreAnnoyingHitman => 4i32,
            Self::AIM_IgnoreSneakyHitman => 8i32,
            Self::AIM_IgnoreAgileHitman => 16i32,
            Self::AIM_IgnoreSillyHitman => 30i32,
            Self::AIM_PreferredInvestigator => 32i32,
            Self::AIM_AccidentShy => 64i32,
            Self::AIM_PreferredAccidentInvestigator => 128i32,
            Self::AIM_BlockFiberWireInteraction => 256i32,
            Self::AIM_BlockCloseCombatInteraction => 512i32,
            Self::AIM_BlockDragBodyInteraction => 1024i32,
            Self::AIM_BlockAllInteractions => 1792i32,
            Self::AIM_IgnoreDistractions => 2048i32,
            Self::AIM_IgnoreTrespassing => 4096i32,
            Self::AIM_IgnoreWeapons => 8192i32,
            Self::AIM_IgnoreLockdown => 16384i32,
            Self::AIM_DisableHelpCivilian => 32768i32,
            Self::AIM_WantsPrivacy => 65536i32,
            Self::AIM_ConversationHelper => 131072i32,
            Self::AIM_ConversationHelperFast => 262144i32,
            Self::AIM_OneHitpoint => 524288i32,
            Self::AIM_BlockDeadlyThrow => 1048576i32,
            Self::AIM_SuppressSocialGreeting => 2097152i32,
            Self::AIM_NeverInvestigateAccidents => 4194304i32,
            Self::AIM_BlockDeath => 8388608i32,
            Self::AIM_IgnoreDeadBody => 16777216i32,
            Self::AIM_NeverSpectate => 33554432i32,
            Self::AIM_DisableDeadBodySensor => 67108864i32,
            Self::AIM_DeafAndBlind => 134217728i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAIModifiers {
     const TYPE_ID: &str = "EAIModifiers";
}

impl StaticVariant for Vec<EAIModifiers> {
     const TYPE_ID: &str = "TArray<EAIModifiers>";
}

impl StaticVariant for Vec<Vec<EAIModifiers>> {
     const TYPE_ID: &str = "TArray<TArray<EAIModifiers>>";
}

impl Variant for EAIModifiers {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAIModifiers")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAIModifiers".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAIModifiers>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAIModifiers>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAIModifiers>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAISharedEventType {
    AISET_None,
    AISET_StandOffCrowdReactionDone,
    AISET_Shoot,
    AISET_ShootBlind,
    AISET_Scared,
    AISET_CloseCombatRunIn,
    AISET_CloseCombatArrest,
    AISET_ReadyForCloseCombatArrest,
    AISET_DeadByAccident,
    AISET_SituationConversation,
    AISET_LAST_BOOLEAN_EVENT,
    AISET_IllegalBehavior,
    AISET_BeingWatched,
    AISET_Sneaking,
    AISET_Squatting,
    AISET_Agility,
    AISET_IllegalAgility,
    AISET_ChangingOutfit,
    AISET_ChangedOutfit,
    AISET_CoverToCover,
    AISET_Trespassing,
    AISET_InTrespassZone,
    AISET_InDisguiseZone,
    AISET_DraggingBody,
    AISET_KillingWithFiberwire,
    AISET_KillingWithPull,
    AISET_KillingWithPush,
    AISET_KillingWithKick,
    AISET_KillingWithKnife,
    AISET_KillingWithDeadlyThrow,
    AISET_PullingFromLedge,
    AISET_PacifyingWithPull,
    AISET_PacifyingWithPush,
    AISET_PacifyingWithKick,
    AISET_PacifyingWithKnockDownThrow,
    AISET_PacifyingWithStrangle,
    AISET_PacifyingWithKnife,
    AISET_ThrowingSomething,
    AISET_ThrowingExplosives,
    AISET_KnockingDown,
    AISET_InCloset,
    AISET_InNpcUnreachableArea,
    AISET_Peeking,
    AISET_EnteringCloset,
    AISET_ExitingCloset,
    AISET_InCover,
    AISET_MovingInCover,
    AISET_HiddenInCover,
    AISET_HasWeapon,
    AISET_WeaponEquipped,
    AISET_WeaponFired,
    AISET_WeaponReloading,
    AISET_Aiming,
    AISET_GuardDisguise,
    AISET_PulledByHitmanOnLedge,
    AISET_CombatNoHold,
    AISET_CombatFireAtWill,
    AISET_InOrderedPosition,
    AISET_ORDERS_BEGIN,
    AISET_Order_Act,
    AISET_Order_Investigate,
    AISET_Order_SearchPosition,
    AISET_Order_Approach,
    AISET_Order_GetHelp,
    AISET_Order_StandDown,
    AISET_Order_Escalate,
    AISET_Order_Arrest,
    AISET_Order_Avoid,
    AISET_Order_Flee,
    AISET_Order_Patrol,
    AISET_Order_Reposition,
    AISET_Order_Chase,
    AISET_Order_AimFromPosition,
    AISET_Order_HoldPosition,
    AISET_Order_HoldCoverPosition,
    AISET_Order_FightFromCover,
    AISET_Order_FightFromPosition,
    AISET_Order_ShootFromPosition,
    AISET_Order_GuardPosition,
    AISET_Order_GuardBody,
    AISET_Order_WakeUpUnconscious,
    AISET_Order_DragBody,
    AISET_Order_TriggerAlarm,
    AISET_Order_DispatchSuspectInfo,
    AISET_Order_RecieveSuspectInfo,
    AISET_Order_RequestBackup,
    AISET_Order_ThrowFlashGrenade,
    AISET_Order_CheckLastPosition,
    AISET_Order_StandoffLastWarning,
    AISET_Order_Evacuate,
    AISET_Order_AgitatedBystander,
    AISET_Order_CuriousBystander,
    AISET_Order_Face,
    AISET_Order_Holster,
    AISET_Order_Unholster,
    AISET_Order_MoveTo,
    AISET_Order_JumpTo,
    AISET_Order_FormationMove,
    AISET_Order_SentryFrisk,
    AISET_Order_SentryWarning,
    AISET_Order_SentryGreeting,
    AISET_Order_SentryCheckItem,
    AISET_Order_SentryDemandPickUpItem,
    AISET_Order_DeliverWeapon,
    AISET_Order_RecoverUnconscious,
    AISET_Order_GetOutfit,
    AISET_Order_LockdownWarning,
    AISET_Order_VIPEvacuateIdle,
    AISET_Order_VIPSafeRoom,
    AISET_Order_VIPSafeRoomTrespasser,
    AISET_Order_VIPScared,
    AISET_Order_DefendVIP,
    AISET_Order_CautiousVIP,
    AISET_Order_CautiousGuardVIP,
    AISET_Order_EscortOut,
    AISET_Order_MoveInCover,
    AISET_Order_MoveToCover,
    AISET_Order_Conversation,
    AISET_Order_AttentionToPerson,
    AISET_Order_WaitForItemHandled,
    AISET_ORDERS_END,
    AISET_IMPULSES_BEGIN,
    AISET_Impulse_ReceiveHuntTarget,
    AISET_Impulse_AckHuntTarget,
    AISET_Impulse_TransmitHuntTarget,
    AISET_Impulse_ActiveRadioCall,
    AISET_IMPULSES_END,
    AISET_ForceFullAttention,
    AISET_InCameraView2D,
    AISET_BeingLookedAt,
    AISET_BeingAimedAt,
    AISET_WasAimedAtRecently,
    AISET_BeingShotAt,
    AISET_BeingActuallyShotAt,
    AISET_BeingFlanked,
    AISET_BeingTouched,
    AISET_BeingBumped,
    AISET_BeingEscortedOut,
    AISET_EscortingOut,
    AISET_EscortOutFarewell,
    AISET_HMTrespassing,
    AISET_HMInEntryArea,
    AISET_HMTakingDamage,
    AISET_HumanShield,
    AISET_IllegalAction,
    AISET_IllegalActionSevere,
    AISET_TakingKeyCard,
    AISET_TakingSecurityTape,
    AISET_DumpingBody,
    AISET_Shooting,
    AISET_BlindFire,
    AISET_ShootingBallet,
    AISET_Running,
    AISET_Walking,
    AISET_UsingKeyCard,
    AISET_WeaponDropped,
    AISET_WeaponPickedUp,
    AISET_ItemPickedUp,
    AISET_ItemDropped,
    AISET_Surrendering,
    AISET_RequestSurrender,
    AISET_StandOffEscalated,
    AISET_StandOffInvestigateSevere,
    AISET_Standing,
    AISET_Enforcer,
    AISET_DisguiseEnforcer,
    AISET_Dead,
    AISET_DeadByUnnoticed,
    AISET_DeadBySniper,
    AISET_InMorgue,
    AISET_InAccident,
    AISET_Dying,
    AISET_InInvestigateDisguise,
    AISET_InArrest,
    AISET_Arrestor,
    AISET_InCombat,
    AISET_InCombatWithGuards,
    AISET_Hunted,
    AISET_ForceHunted,
    AISET_CloseCombat,
    AISET_CloseCombatSlashing,
    AISET_TakingProjectileDamage,
    AISET_TakingHeadshotDamage,
    AISET_TakingExplosionDamage,
    AISET_TakingThrowDamage,
    AISET_ForceKillHM,
    AISET_Armed,
    AISET_BeingHumanShield,
    AISET_BeingPulledOutOfWindow,
    AISET_BeingPushedOverRail,
    AISET_BeingFiberwired,
    AISET_BeingPulledFromLedge,
    AISET_BeingDragged,
    AISET_OnScreen,
    AISET_ExplosionImminent,
    AISET_DisguiseSafeZone,
    AISET_DisguiseCanBlendIn,
    AISET_DisguiseBlendIn,
    AISET_DisguiseBroken,
    AISET_InWarZone,
    AISET_HearLockdownAlarm,
    AISET_InCrowd,
    AISET_InCrowdHighDensity,
    AISET_InCrowdAlert,
    AISET_InCrowdPanic,
    AISET_HiddenByCrowd,
    AISET_CrowdDisguise,
    AISET_BeingStrangled,
    AISET_BeingSnapNecked,
    AISET_BeingKnockedDown,
    AISET_BeingContextKilled,
    AISET_CloseCombatTakedown,
    AISET_ContextKill,
    AISET_ExecutePistol,
    AISET_PickingUpGuardedItem,
    AISET_SedativePoison,
    AISET_SpawnedActor,
    AISET_SoundRadio,
    AISET_Weapon,
    AISET_Item,
    AISET_ItemThrown,
    AISET_OwnedByHM,
    AISET_Coin,
    AISET_InLimitVisionAreaZone,
    AISET_InsideLimitVisionArea,
    AISET_BlockedByLimitVisionArea,
    AISET_AmbientOnly,
    AISET_HasBeenInCombat,
    AISET_HitByItem,
    AISET_CloseCombatAllowed,
    AISET_CollateralTarget,
    AISET_HuntAct,
    AISET_Sick,
    AISET_Stunned,
    AISET_Naked,
    AISET_Investigated,
    AISET_FreshBody,
    AISET_SeenDeadlyThrowVictim,
    AISET_IWillBeDeadlyThrowVictim,
    AISET_Suspect,
    AISET_BeingFrisked,
    AISET_RequestFrisk,
    AISET_FriskComplying,
    AISET_FriskApproachReady,
    AISET_FriskReady,
    AISET_Frisked,
    AISET_FriskFailed,
    AISET_FriskFoundWeapon,
    AISET_AntiSocial,
    AISET_Introvert,
    AISET_InLockdownZone,
    AISET_EnteringLockdownZone,
    AISET_InSentryZone,
    AISET_InSentryWarningZone,
    AISET_InSentryFriskWarningZone,
    AISET_SuppressTrespassing,
    AISET_ReportedDisturbance,
    AISET_InLockdown,
    AISET_ToldToEvacuate,
    AISET_CurrentTarget,
    AISET_RequestShowItem,
    AISET_RequestComplying,
    AISET_WokenByNPC,
    AISET_Silly,
    AISET_TriggerLockDownAlarm,
    AISET_CombatFromEvacuate,
    AISET_DontMakeFunPlease,
    AISET_TempCrowdKnowledge,
    AISET_Attached,
    AISET_DontReact,
    AISET_Sentry,
    AISET_HardSentry,
    AISET_FriskingSentry,
    AISET_Guarded,
    AISET_CloseCombatFinisher,
    AISET_WasInCloseCombatSawAggressor,
    AISET_Pacified,
    AISET_SomeoneIsSniping,
    AISET_FlashpointSeen,
    AISET_SniperLocation,
    AISET_WeaponContextKnown,
    AISET_Distracted,
    AISET_LockedInAgility,
    AISET_ActorAlreadyAlive,
    AISET_DraggingBodyBag,
    AISET_UncosciousBlamingFailed,
    AISET_VaultingOverObstacle,
    AISET_ClimbingWindow,
    AISET_Combat_Brave,
    AISET_Combat_OneTimeBrave,
    AISET_Combat_PrimaryRange,
    AISET_Combat_ThrewFlashGrenade,
    AISET_Combat_CloseToGuards,
    AISET_Combat_RecentlySeen,
    AISET_Combat_TargetSeenAtLeastOnce,
    AISET_InTheAirDeadly,
    AISET_InTheAir,
    AISET_Landing,
    AISET_InSentrySituation,
    AISET_LeftDramaWithHM,
    AISET_Wounded,
    AISET_RecoveredFromWounded,
    AISET_ReactedToTossAlerted,
    AISET_ReactedToHitAlerted,
    AISET_GettingHelp,
    AISET_HelpingCivilian,
    AISET_InvestigatingMurder,
    AISET_InvestigatingMurderOrGunshot,
    AISET_InvestigateDisguiseGroupLeader,
    AISET_InvestigateDisguiseMovingBack,
    AISET_BodyguardVIPDead,
    AISET_SilentlyKilled,
    AISET_SilentlyKilling,
    AISET_SoundGunShot,
    AISET_SoundHitmanGunShot,
    AISET_SoundHitmanGunShotSilenced,
    AISET_ChangingOutfitFromBody,
    AISET_SpeedBoost,
    AISET_ManhuntMember,
    AISET_InvestigateDisguiseMember,
    AISET_EvacuateAfterRecover,
    AISET_Woozy,
    AISET_HasAmbientEscort,
    AISET_IsEscortingVIP,
    AISET_StrangleVictim,
    AISET_DontStandDownIfIdling,
    AISET_Jumping,
    AISET_GetHelpDone,
    AISET_VIPHandleOwnCuriousInvestigation,
    AISET_InDangerousArea,
    AISET_RadioCallHelpComming,
    AISET_RadioCallHelpFailed,
    AISET_RadioCallHelpArrived,
    AISET_SocialCooldown,
    AISET_VIPAtEscapeNode,
    AISET_VIPEscaping,
    AISET_InterestingLocation,
    AISET_SeeDeathExplained,
    AISET_HMHasVictim,
    AISET_PrivateSituationLeader,
    AISET_LongTermMemorySetGoal,
    AISET_ThrownByHitman,
    AISET_Dropped,
    AISET_InterestingItem,
    AISET_InEvacuateTrespassGroup,
    AISET_InRecoverUnconsciousGroup,
    AISET_Revived,
    AISET_IsBeggingForLife,
    AISET_HMStunnedByNPCFlashGrenade,
    AISET_Situation_Role_Leader,
    AISET_Situation_Role_Assistant,
    AISET_Situation_Role_AssitingGuard,
    AISET_ReadytoPlayInvestigationConversation,
    AISET_ReadytoPlayStandDownConversation,
    AISET_ForcedLeader,
    AISET_PropagatedByCivilian,
    AISET_Distraction_State_LeaderSelected,
    AISET_Distraction_State_Investigated,
    AISET_Distraction_State_Resolved,
    AISET_Distraction_State_Canceled,
    AISET_Distraction_Target_BeingHandled,
    AISET_Arrest_State_Approaching,
    AISET_Arrest_State_Escorting,
    AISET_Arrest_State_Guarding,
    AISET_Arrest_ArrestReason,
    AISET_Arrest_Warning_1,
    AISET_Arrest_Warning_2,
    AISET_Arrest_Warning_3,
    AISET_Arrest_Warning_Delay,
    AISET_SC_Escalating,
    AISET_SC_InCombatPosition,
    AISET_SC_Shoot,
    AISET_SC_PreventShooting,
    AISET_SC_PreventChangeCombatPosition,
    AISET_SC_CombatAct,
    AISET_SC_InCombat,
    AISET_SC_Investigator,
    AISET_Infected,
    AISET_Infected_Stage2,
    AISET_Infected_Stage3,
    AISET_Infection_Cured,
    AISET_ENFORCER_DISABLE_FLAG_BEGIN,
    AISET_Enforcer_Disable_HideInPlainSight,
    AISET_ENFORCER_DISABLE_FLAG_END,
    AISET_DYNAMIC_ENFORCER_FLAG_BEGIN,
    AISET_DynamicEnforcer_SharedHitmanSensor,
    AISET_DynamicEnforcer_NakedActor,
    AISET_DynamicEnforcer_SeenItemThrown,
    AISET_DynamicEnforcer_HitByItemOrCoin,
    AISET_DynamicEnforcer_Setpiece,
    AISET_DynamicEnforcer_SillyHitman,
    AISET_DynamicEnforcer_PrivateArea,
    AISET_DynamicEnforcer_SuspiciousMovement,
    AISET_DYNAMIC_ENFORCER_FLAG_INCA_BEGIN,
    AISET_DynamicEnforcer_Explosion,
    AISET_DynamicEnforcer_GunshotSound,
    AISET_DynamicEnforcer_BulletImpactSound,
    AISET_DynamicEnforcer_CloseCombatSound,
    AISET_DynamicEnforcer_DeadlyThrowVictim,
    AISET_DynamicEnforcer_PacifyingThrowVictim,
    AISET_DynamicEnforcer_SeenMurderVictimNotHeardGunshot,
    AISET_DynamicEnforcer_SeenMurderVictimHeardGunshot,
    AISET_DynamicEnforcer_MurderAttempt,
    AISET_DynamicEnforcer_DeadBody,
    AISET_DynamicEnforcer_PacifiedBody,
    AISET_DynamicEnforcer_Hunt,
    AISET_DYNAMIC_ENFORCER_FLAG_INCA_END,
    AISET_DYNAMIC_ENFORCER_FLAG_END,
    AISET_DYNAMIC_ENFORCER_DISABLE_FLAG_BEGIN,
    AISET_DynamicEnforcer_Disable_CivilianInInvestigateCautious,
    AISET_DYNAMIC_ENFORCER_DISABLE_FLAG_END,
    AISET_DYNAMIC_ENFORCER_CIVILIAN_DISGUISE_ONLY_FLAG_BEGIN,
    AISET_DynamicEnforcer_InvestigateWeapon,
    AISET_DYNAMIC_ENFORCER_CIVILIAN_DISGUISE_ONLY_FLAG_END,
    AISET_DYNAMIC_ENFORCER_ARREST_REASON_BEGIN,
    AISET_DynamicEnforcer_ArrestReason_Murder,
    AISET_DynamicEnforcer_ArrestReason_MurderAttempt,
    AISET_DynamicEnforcer_ArrestReason_HitByItemOrCoin,
    AISET_DynamicEnforcer_ArrestReason_NearDeadBody,
    AISET_DynamicEnforcer_ArrestReason_NearPacifiedBody,
    AISET_DynamicEnforcer_ArrestReason_GunshotSound,
    AISET_DynamicEnforcer_ArrestReason_CloseCombatSound,
    AISET_DynamicEnforcer_ArrestReason_BulletImpactSound,
    AISET_DynamicEnforcer_ArrestReason_Hunt,
    AISET_DynamicEnforcer_ArrestReason_Explosion,
    AISET_DynamicEnforcer_ArrestReason_PrivateArea,
    AISET_DynamicEnforcer_ArrestReason_Weapon,
    AISET_DynamicEnforcer_ArrestReason_Setpiece,
    AISET_DynamicEnforcer_ArrestReason_KnockdownThrow,
    AISET_DynamicEnforcer_ArrestReason_SillyHitman,
    AISET_DYNAMIC_ENFORCER_ARREST_REASON_END,
}

impl Aligned for EAISharedEventType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAISharedEventType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AISET_None => 0i32,
            Self::AISET_StandOffCrowdReactionDone => 1i32,
            Self::AISET_Shoot => 2i32,
            Self::AISET_ShootBlind => 3i32,
            Self::AISET_Scared => 4i32,
            Self::AISET_CloseCombatRunIn => 5i32,
            Self::AISET_CloseCombatArrest => 6i32,
            Self::AISET_ReadyForCloseCombatArrest => 7i32,
            Self::AISET_DeadByAccident => 8i32,
            Self::AISET_SituationConversation => 9i32,
            Self::AISET_LAST_BOOLEAN_EVENT => 10i32,
            Self::AISET_IllegalBehavior => 11i32,
            Self::AISET_BeingWatched => 12i32,
            Self::AISET_Sneaking => 13i32,
            Self::AISET_Squatting => 14i32,
            Self::AISET_Agility => 15i32,
            Self::AISET_IllegalAgility => 16i32,
            Self::AISET_ChangingOutfit => 17i32,
            Self::AISET_ChangedOutfit => 18i32,
            Self::AISET_CoverToCover => 19i32,
            Self::AISET_Trespassing => 20i32,
            Self::AISET_InTrespassZone => 21i32,
            Self::AISET_InDisguiseZone => 22i32,
            Self::AISET_DraggingBody => 23i32,
            Self::AISET_KillingWithFiberwire => 24i32,
            Self::AISET_KillingWithPull => 25i32,
            Self::AISET_KillingWithPush => 26i32,
            Self::AISET_KillingWithKick => 27i32,
            Self::AISET_KillingWithKnife => 28i32,
            Self::AISET_KillingWithDeadlyThrow => 29i32,
            Self::AISET_PullingFromLedge => 30i32,
            Self::AISET_PacifyingWithPull => 31i32,
            Self::AISET_PacifyingWithPush => 32i32,
            Self::AISET_PacifyingWithKick => 33i32,
            Self::AISET_PacifyingWithKnockDownThrow => 34i32,
            Self::AISET_PacifyingWithStrangle => 35i32,
            Self::AISET_PacifyingWithKnife => 36i32,
            Self::AISET_ThrowingSomething => 37i32,
            Self::AISET_ThrowingExplosives => 38i32,
            Self::AISET_KnockingDown => 39i32,
            Self::AISET_InCloset => 40i32,
            Self::AISET_InNpcUnreachableArea => 41i32,
            Self::AISET_Peeking => 42i32,
            Self::AISET_EnteringCloset => 43i32,
            Self::AISET_ExitingCloset => 44i32,
            Self::AISET_InCover => 45i32,
            Self::AISET_MovingInCover => 46i32,
            Self::AISET_HiddenInCover => 47i32,
            Self::AISET_HasWeapon => 48i32,
            Self::AISET_WeaponEquipped => 49i32,
            Self::AISET_WeaponFired => 50i32,
            Self::AISET_WeaponReloading => 51i32,
            Self::AISET_Aiming => 52i32,
            Self::AISET_GuardDisguise => 53i32,
            Self::AISET_PulledByHitmanOnLedge => 54i32,
            Self::AISET_CombatNoHold => 55i32,
            Self::AISET_CombatFireAtWill => 56i32,
            Self::AISET_InOrderedPosition => 57i32,
            Self::AISET_ORDERS_BEGIN => 58i32,
            Self::AISET_Order_Act => 59i32,
            Self::AISET_Order_Investigate => 60i32,
            Self::AISET_Order_SearchPosition => 61i32,
            Self::AISET_Order_Approach => 62i32,
            Self::AISET_Order_GetHelp => 63i32,
            Self::AISET_Order_StandDown => 64i32,
            Self::AISET_Order_Escalate => 65i32,
            Self::AISET_Order_Arrest => 66i32,
            Self::AISET_Order_Avoid => 67i32,
            Self::AISET_Order_Flee => 68i32,
            Self::AISET_Order_Patrol => 69i32,
            Self::AISET_Order_Reposition => 70i32,
            Self::AISET_Order_Chase => 71i32,
            Self::AISET_Order_AimFromPosition => 72i32,
            Self::AISET_Order_HoldPosition => 73i32,
            Self::AISET_Order_HoldCoverPosition => 74i32,
            Self::AISET_Order_FightFromCover => 75i32,
            Self::AISET_Order_FightFromPosition => 76i32,
            Self::AISET_Order_ShootFromPosition => 77i32,
            Self::AISET_Order_GuardPosition => 78i32,
            Self::AISET_Order_GuardBody => 79i32,
            Self::AISET_Order_WakeUpUnconscious => 80i32,
            Self::AISET_Order_DragBody => 81i32,
            Self::AISET_Order_TriggerAlarm => 82i32,
            Self::AISET_Order_DispatchSuspectInfo => 83i32,
            Self::AISET_Order_RecieveSuspectInfo => 84i32,
            Self::AISET_Order_RequestBackup => 85i32,
            Self::AISET_Order_ThrowFlashGrenade => 86i32,
            Self::AISET_Order_CheckLastPosition => 87i32,
            Self::AISET_Order_StandoffLastWarning => 88i32,
            Self::AISET_Order_Evacuate => 89i32,
            Self::AISET_Order_AgitatedBystander => 90i32,
            Self::AISET_Order_CuriousBystander => 91i32,
            Self::AISET_Order_Face => 92i32,
            Self::AISET_Order_Holster => 93i32,
            Self::AISET_Order_Unholster => 94i32,
            Self::AISET_Order_MoveTo => 95i32,
            Self::AISET_Order_JumpTo => 96i32,
            Self::AISET_Order_FormationMove => 97i32,
            Self::AISET_Order_SentryFrisk => 98i32,
            Self::AISET_Order_SentryWarning => 99i32,
            Self::AISET_Order_SentryGreeting => 100i32,
            Self::AISET_Order_SentryCheckItem => 101i32,
            Self::AISET_Order_SentryDemandPickUpItem => 102i32,
            Self::AISET_Order_DeliverWeapon => 103i32,
            Self::AISET_Order_RecoverUnconscious => 104i32,
            Self::AISET_Order_GetOutfit => 105i32,
            Self::AISET_Order_LockdownWarning => 106i32,
            Self::AISET_Order_VIPEvacuateIdle => 107i32,
            Self::AISET_Order_VIPSafeRoom => 108i32,
            Self::AISET_Order_VIPSafeRoomTrespasser => 109i32,
            Self::AISET_Order_VIPScared => 110i32,
            Self::AISET_Order_DefendVIP => 111i32,
            Self::AISET_Order_CautiousVIP => 112i32,
            Self::AISET_Order_CautiousGuardVIP => 113i32,
            Self::AISET_Order_EscortOut => 114i32,
            Self::AISET_Order_MoveInCover => 115i32,
            Self::AISET_Order_MoveToCover => 116i32,
            Self::AISET_Order_Conversation => 117i32,
            Self::AISET_Order_AttentionToPerson => 118i32,
            Self::AISET_Order_WaitForItemHandled => 119i32,
            Self::AISET_ORDERS_END => 120i32,
            Self::AISET_IMPULSES_BEGIN => 121i32,
            Self::AISET_Impulse_ReceiveHuntTarget => 122i32,
            Self::AISET_Impulse_AckHuntTarget => 123i32,
            Self::AISET_Impulse_TransmitHuntTarget => 124i32,
            Self::AISET_Impulse_ActiveRadioCall => 125i32,
            Self::AISET_IMPULSES_END => 126i32,
            Self::AISET_ForceFullAttention => 127i32,
            Self::AISET_InCameraView2D => 128i32,
            Self::AISET_BeingLookedAt => 129i32,
            Self::AISET_BeingAimedAt => 130i32,
            Self::AISET_WasAimedAtRecently => 131i32,
            Self::AISET_BeingShotAt => 132i32,
            Self::AISET_BeingActuallyShotAt => 133i32,
            Self::AISET_BeingFlanked => 134i32,
            Self::AISET_BeingTouched => 135i32,
            Self::AISET_BeingBumped => 136i32,
            Self::AISET_BeingEscortedOut => 137i32,
            Self::AISET_EscortingOut => 138i32,
            Self::AISET_EscortOutFarewell => 139i32,
            Self::AISET_HMTrespassing => 140i32,
            Self::AISET_HMInEntryArea => 141i32,
            Self::AISET_HMTakingDamage => 142i32,
            Self::AISET_HumanShield => 143i32,
            Self::AISET_IllegalAction => 144i32,
            Self::AISET_IllegalActionSevere => 145i32,
            Self::AISET_TakingKeyCard => 146i32,
            Self::AISET_TakingSecurityTape => 147i32,
            Self::AISET_DumpingBody => 148i32,
            Self::AISET_Shooting => 149i32,
            Self::AISET_BlindFire => 150i32,
            Self::AISET_ShootingBallet => 151i32,
            Self::AISET_Running => 152i32,
            Self::AISET_Walking => 153i32,
            Self::AISET_UsingKeyCard => 154i32,
            Self::AISET_WeaponDropped => 155i32,
            Self::AISET_WeaponPickedUp => 156i32,
            Self::AISET_ItemPickedUp => 157i32,
            Self::AISET_ItemDropped => 158i32,
            Self::AISET_Surrendering => 159i32,
            Self::AISET_RequestSurrender => 160i32,
            Self::AISET_StandOffEscalated => 161i32,
            Self::AISET_StandOffInvestigateSevere => 162i32,
            Self::AISET_Standing => 163i32,
            Self::AISET_Enforcer => 164i32,
            Self::AISET_DisguiseEnforcer => 165i32,
            Self::AISET_Dead => 166i32,
            Self::AISET_DeadByUnnoticed => 167i32,
            Self::AISET_DeadBySniper => 168i32,
            Self::AISET_InMorgue => 169i32,
            Self::AISET_InAccident => 170i32,
            Self::AISET_Dying => 171i32,
            Self::AISET_InInvestigateDisguise => 172i32,
            Self::AISET_InArrest => 173i32,
            Self::AISET_Arrestor => 174i32,
            Self::AISET_InCombat => 175i32,
            Self::AISET_InCombatWithGuards => 176i32,
            Self::AISET_Hunted => 177i32,
            Self::AISET_ForceHunted => 178i32,
            Self::AISET_CloseCombat => 179i32,
            Self::AISET_CloseCombatSlashing => 180i32,
            Self::AISET_TakingProjectileDamage => 181i32,
            Self::AISET_TakingHeadshotDamage => 182i32,
            Self::AISET_TakingExplosionDamage => 183i32,
            Self::AISET_TakingThrowDamage => 184i32,
            Self::AISET_ForceKillHM => 185i32,
            Self::AISET_Armed => 186i32,
            Self::AISET_BeingHumanShield => 187i32,
            Self::AISET_BeingPulledOutOfWindow => 188i32,
            Self::AISET_BeingPushedOverRail => 189i32,
            Self::AISET_BeingFiberwired => 190i32,
            Self::AISET_BeingPulledFromLedge => 191i32,
            Self::AISET_BeingDragged => 192i32,
            Self::AISET_OnScreen => 193i32,
            Self::AISET_ExplosionImminent => 194i32,
            Self::AISET_DisguiseSafeZone => 195i32,
            Self::AISET_DisguiseCanBlendIn => 196i32,
            Self::AISET_DisguiseBlendIn => 197i32,
            Self::AISET_DisguiseBroken => 198i32,
            Self::AISET_InWarZone => 199i32,
            Self::AISET_HearLockdownAlarm => 200i32,
            Self::AISET_InCrowd => 201i32,
            Self::AISET_InCrowdHighDensity => 202i32,
            Self::AISET_InCrowdAlert => 203i32,
            Self::AISET_InCrowdPanic => 204i32,
            Self::AISET_HiddenByCrowd => 205i32,
            Self::AISET_CrowdDisguise => 206i32,
            Self::AISET_BeingStrangled => 207i32,
            Self::AISET_BeingSnapNecked => 208i32,
            Self::AISET_BeingKnockedDown => 209i32,
            Self::AISET_BeingContextKilled => 210i32,
            Self::AISET_CloseCombatTakedown => 211i32,
            Self::AISET_ContextKill => 212i32,
            Self::AISET_ExecutePistol => 213i32,
            Self::AISET_PickingUpGuardedItem => 214i32,
            Self::AISET_SedativePoison => 215i32,
            Self::AISET_SpawnedActor => 216i32,
            Self::AISET_SoundRadio => 217i32,
            Self::AISET_Weapon => 218i32,
            Self::AISET_Item => 219i32,
            Self::AISET_ItemThrown => 220i32,
            Self::AISET_OwnedByHM => 221i32,
            Self::AISET_Coin => 222i32,
            Self::AISET_InLimitVisionAreaZone => 223i32,
            Self::AISET_InsideLimitVisionArea => 224i32,
            Self::AISET_BlockedByLimitVisionArea => 225i32,
            Self::AISET_AmbientOnly => 226i32,
            Self::AISET_HasBeenInCombat => 227i32,
            Self::AISET_HitByItem => 228i32,
            Self::AISET_CloseCombatAllowed => 229i32,
            Self::AISET_CollateralTarget => 230i32,
            Self::AISET_HuntAct => 231i32,
            Self::AISET_Sick => 232i32,
            Self::AISET_Stunned => 233i32,
            Self::AISET_Naked => 234i32,
            Self::AISET_Investigated => 235i32,
            Self::AISET_FreshBody => 236i32,
            Self::AISET_SeenDeadlyThrowVictim => 237i32,
            Self::AISET_IWillBeDeadlyThrowVictim => 238i32,
            Self::AISET_Suspect => 239i32,
            Self::AISET_BeingFrisked => 240i32,
            Self::AISET_RequestFrisk => 241i32,
            Self::AISET_FriskComplying => 242i32,
            Self::AISET_FriskApproachReady => 243i32,
            Self::AISET_FriskReady => 244i32,
            Self::AISET_Frisked => 245i32,
            Self::AISET_FriskFailed => 246i32,
            Self::AISET_FriskFoundWeapon => 247i32,
            Self::AISET_AntiSocial => 248i32,
            Self::AISET_Introvert => 249i32,
            Self::AISET_InLockdownZone => 250i32,
            Self::AISET_EnteringLockdownZone => 251i32,
            Self::AISET_InSentryZone => 252i32,
            Self::AISET_InSentryWarningZone => 253i32,
            Self::AISET_InSentryFriskWarningZone => 254i32,
            Self::AISET_SuppressTrespassing => 255i32,
            Self::AISET_ReportedDisturbance => 256i32,
            Self::AISET_InLockdown => 257i32,
            Self::AISET_ToldToEvacuate => 258i32,
            Self::AISET_CurrentTarget => 259i32,
            Self::AISET_RequestShowItem => 260i32,
            Self::AISET_RequestComplying => 261i32,
            Self::AISET_WokenByNPC => 262i32,
            Self::AISET_Silly => 263i32,
            Self::AISET_TriggerLockDownAlarm => 264i32,
            Self::AISET_CombatFromEvacuate => 265i32,
            Self::AISET_DontMakeFunPlease => 266i32,
            Self::AISET_TempCrowdKnowledge => 267i32,
            Self::AISET_Attached => 268i32,
            Self::AISET_DontReact => 269i32,
            Self::AISET_Sentry => 270i32,
            Self::AISET_HardSentry => 271i32,
            Self::AISET_FriskingSentry => 272i32,
            Self::AISET_Guarded => 273i32,
            Self::AISET_CloseCombatFinisher => 274i32,
            Self::AISET_WasInCloseCombatSawAggressor => 275i32,
            Self::AISET_Pacified => 276i32,
            Self::AISET_SomeoneIsSniping => 277i32,
            Self::AISET_FlashpointSeen => 278i32,
            Self::AISET_SniperLocation => 279i32,
            Self::AISET_WeaponContextKnown => 280i32,
            Self::AISET_Distracted => 281i32,
            Self::AISET_LockedInAgility => 282i32,
            Self::AISET_ActorAlreadyAlive => 283i32,
            Self::AISET_DraggingBodyBag => 284i32,
            Self::AISET_UncosciousBlamingFailed => 285i32,
            Self::AISET_VaultingOverObstacle => 286i32,
            Self::AISET_ClimbingWindow => 287i32,
            Self::AISET_Combat_Brave => 288i32,
            Self::AISET_Combat_OneTimeBrave => 289i32,
            Self::AISET_Combat_PrimaryRange => 290i32,
            Self::AISET_Combat_ThrewFlashGrenade => 291i32,
            Self::AISET_Combat_CloseToGuards => 292i32,
            Self::AISET_Combat_RecentlySeen => 293i32,
            Self::AISET_Combat_TargetSeenAtLeastOnce => 294i32,
            Self::AISET_InTheAirDeadly => 295i32,
            Self::AISET_InTheAir => 296i32,
            Self::AISET_Landing => 297i32,
            Self::AISET_InSentrySituation => 298i32,
            Self::AISET_LeftDramaWithHM => 299i32,
            Self::AISET_Wounded => 300i32,
            Self::AISET_RecoveredFromWounded => 301i32,
            Self::AISET_ReactedToTossAlerted => 302i32,
            Self::AISET_ReactedToHitAlerted => 303i32,
            Self::AISET_GettingHelp => 304i32,
            Self::AISET_HelpingCivilian => 305i32,
            Self::AISET_InvestigatingMurder => 306i32,
            Self::AISET_InvestigatingMurderOrGunshot => 307i32,
            Self::AISET_InvestigateDisguiseGroupLeader => 308i32,
            Self::AISET_InvestigateDisguiseMovingBack => 309i32,
            Self::AISET_BodyguardVIPDead => 310i32,
            Self::AISET_SilentlyKilled => 311i32,
            Self::AISET_SilentlyKilling => 312i32,
            Self::AISET_SoundGunShot => 313i32,
            Self::AISET_SoundHitmanGunShot => 314i32,
            Self::AISET_SoundHitmanGunShotSilenced => 315i32,
            Self::AISET_ChangingOutfitFromBody => 316i32,
            Self::AISET_SpeedBoost => 317i32,
            Self::AISET_ManhuntMember => 318i32,
            Self::AISET_InvestigateDisguiseMember => 319i32,
            Self::AISET_EvacuateAfterRecover => 320i32,
            Self::AISET_Woozy => 321i32,
            Self::AISET_HasAmbientEscort => 322i32,
            Self::AISET_IsEscortingVIP => 323i32,
            Self::AISET_StrangleVictim => 324i32,
            Self::AISET_DontStandDownIfIdling => 325i32,
            Self::AISET_Jumping => 326i32,
            Self::AISET_GetHelpDone => 327i32,
            Self::AISET_VIPHandleOwnCuriousInvestigation => 328i32,
            Self::AISET_InDangerousArea => 329i32,
            Self::AISET_RadioCallHelpComming => 330i32,
            Self::AISET_RadioCallHelpFailed => 331i32,
            Self::AISET_RadioCallHelpArrived => 332i32,
            Self::AISET_SocialCooldown => 333i32,
            Self::AISET_VIPAtEscapeNode => 334i32,
            Self::AISET_VIPEscaping => 335i32,
            Self::AISET_InterestingLocation => 336i32,
            Self::AISET_SeeDeathExplained => 337i32,
            Self::AISET_HMHasVictim => 338i32,
            Self::AISET_PrivateSituationLeader => 339i32,
            Self::AISET_LongTermMemorySetGoal => 340i32,
            Self::AISET_ThrownByHitman => 341i32,
            Self::AISET_Dropped => 342i32,
            Self::AISET_InterestingItem => 343i32,
            Self::AISET_InEvacuateTrespassGroup => 344i32,
            Self::AISET_InRecoverUnconsciousGroup => 345i32,
            Self::AISET_Revived => 346i32,
            Self::AISET_IsBeggingForLife => 347i32,
            Self::AISET_HMStunnedByNPCFlashGrenade => 348i32,
            Self::AISET_Situation_Role_Leader => 349i32,
            Self::AISET_Situation_Role_Assistant => 350i32,
            Self::AISET_Situation_Role_AssitingGuard => 351i32,
            Self::AISET_ReadytoPlayInvestigationConversation => 352i32,
            Self::AISET_ReadytoPlayStandDownConversation => 353i32,
            Self::AISET_ForcedLeader => 354i32,
            Self::AISET_PropagatedByCivilian => 355i32,
            Self::AISET_Distraction_State_LeaderSelected => 356i32,
            Self::AISET_Distraction_State_Investigated => 357i32,
            Self::AISET_Distraction_State_Resolved => 358i32,
            Self::AISET_Distraction_State_Canceled => 359i32,
            Self::AISET_Distraction_Target_BeingHandled => 360i32,
            Self::AISET_Arrest_State_Approaching => 361i32,
            Self::AISET_Arrest_State_Escorting => 362i32,
            Self::AISET_Arrest_State_Guarding => 363i32,
            Self::AISET_Arrest_ArrestReason => 364i32,
            Self::AISET_Arrest_Warning_1 => 365i32,
            Self::AISET_Arrest_Warning_2 => 366i32,
            Self::AISET_Arrest_Warning_3 => 367i32,
            Self::AISET_Arrest_Warning_Delay => 368i32,
            Self::AISET_SC_Escalating => 369i32,
            Self::AISET_SC_InCombatPosition => 370i32,
            Self::AISET_SC_Shoot => 371i32,
            Self::AISET_SC_PreventShooting => 372i32,
            Self::AISET_SC_PreventChangeCombatPosition => 373i32,
            Self::AISET_SC_CombatAct => 374i32,
            Self::AISET_SC_InCombat => 375i32,
            Self::AISET_SC_Investigator => 376i32,
            Self::AISET_Infected => 377i32,
            Self::AISET_Infected_Stage2 => 378i32,
            Self::AISET_Infected_Stage3 => 379i32,
            Self::AISET_Infection_Cured => 380i32,
            Self::AISET_ENFORCER_DISABLE_FLAG_BEGIN => 381i32,
            Self::AISET_Enforcer_Disable_HideInPlainSight => 382i32,
            Self::AISET_ENFORCER_DISABLE_FLAG_END => 383i32,
            Self::AISET_DYNAMIC_ENFORCER_FLAG_BEGIN => 384i32,
            Self::AISET_DynamicEnforcer_SharedHitmanSensor => 385i32,
            Self::AISET_DynamicEnforcer_NakedActor => 386i32,
            Self::AISET_DynamicEnforcer_SeenItemThrown => 387i32,
            Self::AISET_DynamicEnforcer_HitByItemOrCoin => 388i32,
            Self::AISET_DynamicEnforcer_Setpiece => 389i32,
            Self::AISET_DynamicEnforcer_SillyHitman => 390i32,
            Self::AISET_DynamicEnforcer_PrivateArea => 391i32,
            Self::AISET_DynamicEnforcer_SuspiciousMovement => 392i32,
            Self::AISET_DYNAMIC_ENFORCER_FLAG_INCA_BEGIN => 393i32,
            Self::AISET_DynamicEnforcer_Explosion => 394i32,
            Self::AISET_DynamicEnforcer_GunshotSound => 395i32,
            Self::AISET_DynamicEnforcer_BulletImpactSound => 396i32,
            Self::AISET_DynamicEnforcer_CloseCombatSound => 397i32,
            Self::AISET_DynamicEnforcer_DeadlyThrowVictim => 398i32,
            Self::AISET_DynamicEnforcer_PacifyingThrowVictim => 399i32,
            Self::AISET_DynamicEnforcer_SeenMurderVictimNotHeardGunshot => 400i32,
            Self::AISET_DynamicEnforcer_SeenMurderVictimHeardGunshot => 401i32,
            Self::AISET_DynamicEnforcer_MurderAttempt => 402i32,
            Self::AISET_DynamicEnforcer_DeadBody => 403i32,
            Self::AISET_DynamicEnforcer_PacifiedBody => 404i32,
            Self::AISET_DynamicEnforcer_Hunt => 405i32,
            Self::AISET_DYNAMIC_ENFORCER_FLAG_INCA_END => 406i32,
            Self::AISET_DYNAMIC_ENFORCER_FLAG_END => 407i32,
            Self::AISET_DYNAMIC_ENFORCER_DISABLE_FLAG_BEGIN => 408i32,
            Self::AISET_DynamicEnforcer_Disable_CivilianInInvestigateCautious => 409i32,
            Self::AISET_DYNAMIC_ENFORCER_DISABLE_FLAG_END => 410i32,
            Self::AISET_DYNAMIC_ENFORCER_CIVILIAN_DISGUISE_ONLY_FLAG_BEGIN => 411i32,
            Self::AISET_DynamicEnforcer_InvestigateWeapon => 412i32,
            Self::AISET_DYNAMIC_ENFORCER_CIVILIAN_DISGUISE_ONLY_FLAG_END => 413i32,
            Self::AISET_DYNAMIC_ENFORCER_ARREST_REASON_BEGIN => 414i32,
            Self::AISET_DynamicEnforcer_ArrestReason_Murder => 415i32,
            Self::AISET_DynamicEnforcer_ArrestReason_MurderAttempt => 416i32,
            Self::AISET_DynamicEnforcer_ArrestReason_HitByItemOrCoin => 417i32,
            Self::AISET_DynamicEnforcer_ArrestReason_NearDeadBody => 418i32,
            Self::AISET_DynamicEnforcer_ArrestReason_NearPacifiedBody => 419i32,
            Self::AISET_DynamicEnforcer_ArrestReason_GunshotSound => 420i32,
            Self::AISET_DynamicEnforcer_ArrestReason_CloseCombatSound => 421i32,
            Self::AISET_DynamicEnforcer_ArrestReason_BulletImpactSound => 422i32,
            Self::AISET_DynamicEnforcer_ArrestReason_Hunt => 423i32,
            Self::AISET_DynamicEnforcer_ArrestReason_Explosion => 424i32,
            Self::AISET_DynamicEnforcer_ArrestReason_PrivateArea => 425i32,
            Self::AISET_DynamicEnforcer_ArrestReason_Weapon => 426i32,
            Self::AISET_DynamicEnforcer_ArrestReason_Setpiece => 427i32,
            Self::AISET_DynamicEnforcer_ArrestReason_KnockdownThrow => 428i32,
            Self::AISET_DynamicEnforcer_ArrestReason_SillyHitman => 429i32,
            Self::AISET_DYNAMIC_ENFORCER_ARREST_REASON_END => 430i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAISharedEventType {
     const TYPE_ID: &str = "EAISharedEventType";
}

impl StaticVariant for Vec<EAISharedEventType> {
     const TYPE_ID: &str = "TArray<EAISharedEventType>";
}

impl StaticVariant for Vec<Vec<EAISharedEventType>> {
     const TYPE_ID: &str = "TArray<TArray<EAISharedEventType>>";
}

impl Variant for EAISharedEventType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAISharedEventType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAISharedEventType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAISharedEventType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAISharedEventType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAISharedEventType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAISituation {
    AIS_GENERIC,
    AIS_SPECIAL,
    AIS_SENSOR,
    AIS_TRESPASSING,
    AIS_STANDOFF,
    AIS_SMUGGLE,
    AIS_GET_HELP,
    AIS_CONVERSTION_GROUP,
    AIS_PROTO_COMBAT,
    AIS_SENTRY,
    AIS_LEAD_ESCORT,
    AIS_INVESTIGATE_WEAPON,
    AIS_INVESTIGATE_STANDING,
    AIS_INVESTIGATE_CURIOUS,
    AIS_INVESTIGATE_CAUTIOUS,
    AIS_HERO_ESCORT,
    AIS_EVACUATE,
    AIS_ESCORT,
    AIS_ENTOURAGE,
    AIS_DRAMA,
    AIS_DISGUISE,
    AIS_DEAD_BODY,
    AIS_COMBAT,
    AIS_CLOSE_COMBAT,
    AIS_AVOID_EXPLOSION,
    AIS_ACCIDENT,
    AIS_PRIVATE,
    AIS_GUARD_BODY,
    AIS_RECOVER_UNC,
    AIS_SNIPER,
}

impl Aligned for EAISituation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAISituation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIS_GENERIC => 0i32,
            Self::AIS_SPECIAL => 1i32,
            Self::AIS_SENSOR => 2i32,
            Self::AIS_TRESPASSING => 3i32,
            Self::AIS_STANDOFF => 4i32,
            Self::AIS_SMUGGLE => 5i32,
            Self::AIS_GET_HELP => 6i32,
            Self::AIS_CONVERSTION_GROUP => 7i32,
            Self::AIS_PROTO_COMBAT => 8i32,
            Self::AIS_SENTRY => 9i32,
            Self::AIS_LEAD_ESCORT => 10i32,
            Self::AIS_INVESTIGATE_WEAPON => 11i32,
            Self::AIS_INVESTIGATE_STANDING => 12i32,
            Self::AIS_INVESTIGATE_CURIOUS => 13i32,
            Self::AIS_INVESTIGATE_CAUTIOUS => 14i32,
            Self::AIS_HERO_ESCORT => 15i32,
            Self::AIS_EVACUATE => 16i32,
            Self::AIS_ESCORT => 17i32,
            Self::AIS_ENTOURAGE => 18i32,
            Self::AIS_DRAMA => 19i32,
            Self::AIS_DISGUISE => 20i32,
            Self::AIS_DEAD_BODY => 21i32,
            Self::AIS_COMBAT => 22i32,
            Self::AIS_CLOSE_COMBAT => 23i32,
            Self::AIS_AVOID_EXPLOSION => 24i32,
            Self::AIS_ACCIDENT => 25i32,
            Self::AIS_PRIVATE => 26i32,
            Self::AIS_GUARD_BODY => 27i32,
            Self::AIS_RECOVER_UNC => 28i32,
            Self::AIS_SNIPER => 29i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAISituation {
     const TYPE_ID: &str = "EAISituation";
}

impl StaticVariant for Vec<EAISituation> {
     const TYPE_ID: &str = "TArray<EAISituation>";
}

impl StaticVariant for Vec<Vec<EAISituation>> {
     const TYPE_ID: &str = "TArray<TArray<EAISituation>>";
}

impl Variant for EAISituation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAISituation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAISituation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAISituation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAISituation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAISituation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAISituationEvent {
    AISE_Any,
    AISE_ActorJoined,
    AISE_ActorLeft,
    AISE_Data,
}

impl Aligned for EAISituationEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAISituationEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AISE_Any => 0i32,
            Self::AISE_ActorJoined => 1i32,
            Self::AISE_ActorLeft => 2i32,
            Self::AISE_Data => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAISituationEvent {
     const TYPE_ID: &str = "EAISituationEvent";
}

impl StaticVariant for Vec<EAISituationEvent> {
     const TYPE_ID: &str = "TArray<EAISituationEvent>";
}

impl StaticVariant for Vec<Vec<EAISituationEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EAISituationEvent>>";
}

impl Variant for EAISituationEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAISituationEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAISituationEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAISituationEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAISituationEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAISituationEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAccidentDeathContext {
    eADC_DeathByAccident,
    eADC_DeathBySniper,
    eADC_DeathByPoison,
    eADC_DeathByShot,
}

impl Aligned for EAccidentDeathContext {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAccidentDeathContext {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eADC_DeathByAccident => 0i32,
            Self::eADC_DeathBySniper => 1i32,
            Self::eADC_DeathByPoison => 2i32,
            Self::eADC_DeathByShot => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAccidentDeathContext {
     const TYPE_ID: &str = "EAccidentDeathContext";
}

impl StaticVariant for Vec<EAccidentDeathContext> {
     const TYPE_ID: &str = "TArray<EAccidentDeathContext>";
}

impl StaticVariant for Vec<Vec<EAccidentDeathContext>> {
     const TYPE_ID: &str = "TArray<TArray<EAccidentDeathContext>>";
}

impl Variant for EAccidentDeathContext {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAccidentDeathContext")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAccidentDeathContext".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAccidentDeathContext>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAccidentDeathContext>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAccidentDeathContext>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAccidentScaleContext {
    eASC_Standard,
    eASC_Unsafe,
    eASC_Dangerous,
}

impl Aligned for EAccidentScaleContext {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAccidentScaleContext {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eASC_Standard => 0i32,
            Self::eASC_Unsafe => 1i32,
            Self::eASC_Dangerous => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAccidentScaleContext {
     const TYPE_ID: &str = "EAccidentScaleContext";
}

impl StaticVariant for Vec<EAccidentScaleContext> {
     const TYPE_ID: &str = "TArray<EAccidentScaleContext>";
}

impl StaticVariant for Vec<Vec<EAccidentScaleContext>> {
     const TYPE_ID: &str = "TArray<TArray<EAccidentScaleContext>>";
}

impl Variant for EAccidentScaleContext {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAccidentScaleContext")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAccidentScaleContext".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAccidentScaleContext>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAccidentScaleContext>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAccidentScaleContext>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActBodyType {
    ABT_UpperBodyOnly,
    ABT_FullBodyWithLeadIn,
    ABT_FullBodyOnly,
}

impl Aligned for EActBodyType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActBodyType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ABT_UpperBodyOnly => 0i32,
            Self::ABT_FullBodyWithLeadIn => 1i32,
            Self::ABT_FullBodyOnly => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActBodyType {
     const TYPE_ID: &str = "EActBodyType";
}

impl StaticVariant for Vec<EActBodyType> {
     const TYPE_ID: &str = "TArray<EActBodyType>";
}

impl StaticVariant for Vec<Vec<EActBodyType>> {
     const TYPE_ID: &str = "TArray<TArray<EActBodyType>>";
}

impl Variant for EActBodyType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActBodyType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActBodyType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActBodyType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActBodyType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActBodyType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActionPromptState {
    eActionPromptState_Disabled,
    eActionPromptState_Enabled,
    eActionPromptState_Activated,
    eActionPromptState_Held,
}

impl Aligned for EActionPromptState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActionPromptState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActionPromptState_Disabled => 0i32,
            Self::eActionPromptState_Enabled => 1i32,
            Self::eActionPromptState_Activated => 2i32,
            Self::eActionPromptState_Held => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActionPromptState {
     const TYPE_ID: &str = "EActionPromptState";
}

impl StaticVariant for Vec<EActionPromptState> {
     const TYPE_ID: &str = "TArray<EActionPromptState>";
}

impl StaticVariant for Vec<Vec<EActionPromptState>> {
     const TYPE_ID: &str = "TArray<TArray<EActionPromptState>>";
}

impl Variant for EActionPromptState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActionPromptState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActionPromptState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActionPromptState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActionPromptState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActionPromptState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActionRadialArcIconType {
    EARAIT_NoIcon,
    EARAIT_Locked,
    EARAIT_NeedTool,
    EARAIT_IsRunning,
    EARAIT_Crowbar,
    EARAIT_Wrench,
    EARAIT_Card,
    EARAIT_Lockpick,
    EARAIT_Screwdriver,
    EARAIT_AmmoBullet,
    EARAIT_Flower,
    EARAIT_ChemicalTube,
    EARAIT_Golfball,
    EARAIT_Keypad,
    EARAIT_Key,
    EARAIT_Coin,
    EARAIT_Poison,
    EARAIT_Exsplosive,
}

impl Aligned for EActionRadialArcIconType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActionRadialArcIconType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EARAIT_NoIcon => 0i32,
            Self::EARAIT_Locked => 1i32,
            Self::EARAIT_NeedTool => 2i32,
            Self::EARAIT_IsRunning => 3i32,
            Self::EARAIT_Crowbar => 4i32,
            Self::EARAIT_Wrench => 5i32,
            Self::EARAIT_Card => 6i32,
            Self::EARAIT_Lockpick => 7i32,
            Self::EARAIT_Screwdriver => 8i32,
            Self::EARAIT_AmmoBullet => 9i32,
            Self::EARAIT_Flower => 10i32,
            Self::EARAIT_ChemicalTube => 11i32,
            Self::EARAIT_Golfball => 12i32,
            Self::EARAIT_Keypad => 13i32,
            Self::EARAIT_Key => 14i32,
            Self::EARAIT_Coin => 15i32,
            Self::EARAIT_Poison => 16i32,
            Self::EARAIT_Exsplosive => 17i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActionRadialArcIconType {
     const TYPE_ID: &str = "EActionRadialArcIconType";
}

impl StaticVariant for Vec<EActionRadialArcIconType> {
     const TYPE_ID: &str = "TArray<EActionRadialArcIconType>";
}

impl StaticVariant for Vec<Vec<EActionRadialArcIconType>> {
     const TYPE_ID: &str = "TArray<TArray<EActionRadialArcIconType>>";
}

impl Variant for EActionRadialArcIconType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActionRadialArcIconType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActionRadialArcIconType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActionRadialArcIconType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActionRadialArcIconType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActionRadialArcIconType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActionType {
    AT_INVALID,
    AT_OPENDOOR,
    AT_CLOSEDOOR,
    AT_PICKUP,
    AT_GENERIC,
    AT_REMOTE,
    AT_OUTFIT,
    AT_CLOTHBUNDLE,
    AT_DRAGBODY,
    AT_RETRIEVE_ITEM_FROM_CONTAINER,
    AT_HERO_MOVEMENT,
    AT_SWAPITEM,
    AT_DUMPBODY,
    AT_COUP_DE_GRACE,
    AT_INTERACTION_GROUP,
    AT_USE_NORMAL,
    AT_STASHPOINT_PICKUP,
    AT_ENTERCLOSET,
    AT_EXITCLOSET,
    AT_ENTERSAFEZONE,
    AT_EXITSAFEZONE,
    AT_CANCEL,
    AT_CONTAINERFLUSHBODY,
    AT_PLACE_ITEM_IN_CONTAINER,
    AT_USE_DOWN,
    AT_USE_HOLD,
    AT_CONTEXTACTION,
    AT_INTERRUPTIBLE_TAP,
    AT_ITEMCONTAINER,
    AT_USE_QUICK,
    AT_ITEM_INTERACTION,
}

impl Aligned for EActionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AT_INVALID => 0i32,
            Self::AT_OPENDOOR => 1i32,
            Self::AT_CLOSEDOOR => 2i32,
            Self::AT_PICKUP => 4i32,
            Self::AT_GENERIC => 8i32,
            Self::AT_REMOTE => 16i32,
            Self::AT_OUTFIT => 32i32,
            Self::AT_CLOTHBUNDLE => 64i32,
            Self::AT_DRAGBODY => 128i32,
            Self::AT_RETRIEVE_ITEM_FROM_CONTAINER => 256i32,
            Self::AT_HERO_MOVEMENT => 1024i32,
            Self::AT_SWAPITEM => 2048i32,
            Self::AT_DUMPBODY => 4096i32,
            Self::AT_COUP_DE_GRACE => 8192i32,
            Self::AT_INTERACTION_GROUP => 16384i32,
            Self::AT_USE_NORMAL => 32768i32,
            Self::AT_STASHPOINT_PICKUP => 65536i32,
            Self::AT_ENTERCLOSET => 131072i32,
            Self::AT_EXITCLOSET => 262144i32,
            Self::AT_ENTERSAFEZONE => 524288i32,
            Self::AT_EXITSAFEZONE => 1048576i32,
            Self::AT_CANCEL => 2097152i32,
            Self::AT_CONTAINERFLUSHBODY => 4194304i32,
            Self::AT_PLACE_ITEM_IN_CONTAINER => 16777216i32,
            Self::AT_USE_DOWN => 33554432i32,
            Self::AT_USE_HOLD => 67108864i32,
            Self::AT_CONTEXTACTION => 134217728i32,
            Self::AT_INTERRUPTIBLE_TAP => 268435456i32,
            Self::AT_ITEMCONTAINER => 536870912i32,
            Self::AT_USE_QUICK => 1073741824i32,
            Self::AT_ITEM_INTERACTION => -2147483648i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActionType {
     const TYPE_ID: &str = "EActionType";
}

impl StaticVariant for Vec<EActionType> {
     const TYPE_ID: &str = "TArray<EActionType>";
}

impl StaticVariant for Vec<Vec<EActionType>> {
     const TYPE_ID: &str = "TArray<TArray<EActionType>>";
}

impl Variant for EActionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActivationPriority {
    eActivatable_First,
    eActivatable_PlayModeAddedPhysics,
    eActivatable_DestructiblePhysics,
    eActivatable_PhysicsWind,
    eActivatable_Physics,
    eActivatable_PhysicsDone,
    eActivatable_Keywords,
    eActivatable_EventChannel,
    eActivatable_Items,
    eActivatable_Actor,
    eActivatable_Hitman,
    eActivatable_AnimPlayer,
    eActivatable_Sequence,
    eActivatable_SpawnPoint,
    eActivatable_CoverPlane,
    eActivatable_GuardPoint,
    eActivatable_Guide,
    eActivatable_CombatAct,
    eActivatable_CombatAttractor,
    eActivatable_SequenceController,
    eActivatable_KnownEntityAspects,
    eActivatable_AIReasoningGrid,
    eActivatable_HM5Zone,
    eActivatable_Crowds,
    eActivatable_ChildNetworkAct,
    eActivatable_Door,
    eActivatable_UI_Setup,
    eActivatable_NormalGameplay,
    eActivatable_NormalGameplay_Condition,
    eActivatable_NormalGameplay_Values,
    eActivatable_NormalGameplay_State,
    eActivatable_HeroSpawns,
    eActivatable_UI,
    eActivatable_Locomotion,
    eActivatable_Timers,
    eActivatable_AreaTriggers,
    eActivatable_Default,
    eActivatable_GameEventListener,
    eLAST_ACTIVATION_PRIORITY,
}

impl Aligned for EActivationPriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActivationPriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActivatable_First => 0i32,
            Self::eActivatable_PlayModeAddedPhysics => 1i32,
            Self::eActivatable_DestructiblePhysics => 2i32,
            Self::eActivatable_PhysicsWind => 3i32,
            Self::eActivatable_Physics => 4i32,
            Self::eActivatable_PhysicsDone => 5i32,
            Self::eActivatable_Keywords => 6i32,
            Self::eActivatable_EventChannel => 7i32,
            Self::eActivatable_Items => 8i32,
            Self::eActivatable_Actor => 9i32,
            Self::eActivatable_Hitman => 10i32,
            Self::eActivatable_AnimPlayer => 11i32,
            Self::eActivatable_Sequence => 12i32,
            Self::eActivatable_SpawnPoint => 13i32,
            Self::eActivatable_CoverPlane => 14i32,
            Self::eActivatable_GuardPoint => 15i32,
            Self::eActivatable_Guide => 16i32,
            Self::eActivatable_CombatAct => 17i32,
            Self::eActivatable_CombatAttractor => 18i32,
            Self::eActivatable_SequenceController => 19i32,
            Self::eActivatable_KnownEntityAspects => 20i32,
            Self::eActivatable_AIReasoningGrid => 21i32,
            Self::eActivatable_HM5Zone => 22i32,
            Self::eActivatable_Crowds => 23i32,
            Self::eActivatable_ChildNetworkAct => 24i32,
            Self::eActivatable_Door => 25i32,
            Self::eActivatable_UI_Setup => 26i32,
            Self::eActivatable_NormalGameplay => 27i32,
            Self::eActivatable_NormalGameplay_Condition => 28i32,
            Self::eActivatable_NormalGameplay_Values => 29i32,
            Self::eActivatable_NormalGameplay_State => 30i32,
            Self::eActivatable_HeroSpawns => 31i32,
            Self::eActivatable_UI => 32i32,
            Self::eActivatable_Locomotion => 33i32,
            Self::eActivatable_Timers => 34i32,
            Self::eActivatable_AreaTriggers => 35i32,
            Self::eActivatable_Default => 36i32,
            Self::eActivatable_GameEventListener => 37i32,
            Self::eLAST_ACTIVATION_PRIORITY => 38i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActivationPriority {
     const TYPE_ID: &str = "EActivationPriority";
}

impl StaticVariant for Vec<EActivationPriority> {
     const TYPE_ID: &str = "TArray<EActivationPriority>";
}

impl StaticVariant for Vec<Vec<EActivationPriority>> {
     const TYPE_ID: &str = "TArray<TArray<EActivationPriority>>";
}

impl Variant for EActivationPriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActivationPriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActivationPriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActivationPriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActivationPriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActivationPriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorAIDot {
    eAAID_None,
    eAAID_Distracted,
    eAAID_PotentialThreat,
    eAAID_PotentialThreatDistracted,
    eAAID_Aggressive,
    eAAID_EscortingOut,
    eAAID_Fleeing,
    eAAID_Unconscious,
    eAAID_Stunned,
    eAAID_Grenade,
    eAAID_PotentialThreatDisabled,
}

impl Aligned for EActorAIDot {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorAIDot {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAAID_None => 0i32,
            Self::eAAID_Distracted => 1i32,
            Self::eAAID_PotentialThreat => 2i32,
            Self::eAAID_PotentialThreatDistracted => 3i32,
            Self::eAAID_Aggressive => 4i32,
            Self::eAAID_EscortingOut => 5i32,
            Self::eAAID_Fleeing => 6i32,
            Self::eAAID_Unconscious => 7i32,
            Self::eAAID_Stunned => 8i32,
            Self::eAAID_Grenade => 9i32,
            Self::eAAID_PotentialThreatDisabled => 100i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorAIDot {
     const TYPE_ID: &str = "EActorAIDot";
}

impl StaticVariant for Vec<EActorAIDot> {
     const TYPE_ID: &str = "TArray<EActorAIDot>";
}

impl StaticVariant for Vec<Vec<EActorAIDot>> {
     const TYPE_ID: &str = "TArray<TArray<EActorAIDot>>";
}

impl Variant for EActorAIDot {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorAIDot")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorAIDot".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorAIDot>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorAIDot>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorAIDot>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorAIState {
    eAAIS_None,
    eAAIS_Distracted,
    eAAIS_PotentialThreat,
    eAAIS_PotentialThreatDistracted,
    eAAIS_PotentialThreatDisabled,
    eAAIS_Aggressive,
    eAAIS_EscortingOut,
    eAAIS_Fleeing,
    eAAIS_Unconscious,
    eAAIS_Stunned,
    eAAIS_Grenade,
    eAAIS_DisabledInCombat,
    eAAIS_Disabled,
    eAAIS_Max,
}

impl Aligned for EActorAIState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorAIState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAAIS_None => 0i32,
            Self::eAAIS_Distracted => 1i32,
            Self::eAAIS_PotentialThreat => 2i32,
            Self::eAAIS_PotentialThreatDistracted => 3i32,
            Self::eAAIS_PotentialThreatDisabled => 4i32,
            Self::eAAIS_Aggressive => 5i32,
            Self::eAAIS_EscortingOut => 6i32,
            Self::eAAIS_Fleeing => 7i32,
            Self::eAAIS_Unconscious => 8i32,
            Self::eAAIS_Stunned => 9i32,
            Self::eAAIS_Grenade => 10i32,
            Self::eAAIS_DisabledInCombat => 11i32,
            Self::eAAIS_Disabled => 12i32,
            Self::eAAIS_Max => 13i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorAIState {
     const TYPE_ID: &str = "EActorAIState";
}

impl StaticVariant for Vec<EActorAIState> {
     const TYPE_ID: &str = "TArray<EActorAIState>";
}

impl StaticVariant for Vec<Vec<EActorAIState>> {
     const TYPE_ID: &str = "TArray<TArray<EActorAIState>>";
}

impl Variant for EActorAIState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorAIState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorAIState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorAIState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorAIState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorAIState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorAnimationOrder {
    AAO_None,
    AAO_Stand,
    AAO_Move,
    AAO_React,
    AAO_Act,
    AAO_MoveToAct,
    AAO_MoveToCover,
    AAO_ShootFromCover,
    AAO_PeekFromCover,
    AAO_Death,
    AAO_Impact,
    AAO_Controlled,
}

impl Aligned for EActorAnimationOrder {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorAnimationOrder {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AAO_None => 0i32,
            Self::AAO_Stand => 1i32,
            Self::AAO_Move => 2i32,
            Self::AAO_React => 3i32,
            Self::AAO_Act => 4i32,
            Self::AAO_MoveToAct => 5i32,
            Self::AAO_MoveToCover => 6i32,
            Self::AAO_ShootFromCover => 7i32,
            Self::AAO_PeekFromCover => 8i32,
            Self::AAO_Death => 9i32,
            Self::AAO_Impact => 10i32,
            Self::AAO_Controlled => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorAnimationOrder {
     const TYPE_ID: &str = "EActorAnimationOrder";
}

impl StaticVariant for Vec<EActorAnimationOrder> {
     const TYPE_ID: &str = "TArray<EActorAnimationOrder>";
}

impl StaticVariant for Vec<Vec<EActorAnimationOrder>> {
     const TYPE_ID: &str = "TArray<TArray<EActorAnimationOrder>>";
}

impl Variant for EActorAnimationOrder {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorAnimationOrder")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorAnimationOrder".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorAnimationOrder>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorAnimationOrder>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorAnimationOrder>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorBumpType {
    EABT_NONE,
    EABT_UPPERBODY,
    EABT_HEAD,
}

impl Aligned for EActorBumpType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorBumpType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EABT_NONE => 0i32,
            Self::EABT_UPPERBODY => 1i32,
            Self::EABT_HEAD => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorBumpType {
     const TYPE_ID: &str = "EActorBumpType";
}

impl StaticVariant for Vec<EActorBumpType> {
     const TYPE_ID: &str = "TArray<EActorBumpType>";
}

impl StaticVariant for Vec<Vec<EActorBumpType>> {
     const TYPE_ID: &str = "TArray<TArray<EActorBumpType>>";
}

impl Variant for EActorBumpType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorBumpType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorBumpType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorBumpType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorBumpType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorBumpType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorCCPreset {
    ACCP_CivilianFemale,
    ACCP_CivilianeMale,
    ACCP_GuardMale,
    ACCP_GuardMaleElite,
    ACCP_GuardMaleSuperElite,
    ACCP_Ignore,
    ACCP_None,
}

impl Aligned for EActorCCPreset {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorCCPreset {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ACCP_CivilianFemale => 0i32,
            Self::ACCP_CivilianeMale => 1i32,
            Self::ACCP_GuardMale => 2i32,
            Self::ACCP_GuardMaleElite => 3i32,
            Self::ACCP_GuardMaleSuperElite => 4i32,
            Self::ACCP_Ignore => 5i32,
            Self::ACCP_None => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorCCPreset {
     const TYPE_ID: &str = "EActorCCPreset";
}

impl StaticVariant for Vec<EActorCCPreset> {
     const TYPE_ID: &str = "TArray<EActorCCPreset>";
}

impl StaticVariant for Vec<Vec<EActorCCPreset>> {
     const TYPE_ID: &str = "TArray<TArray<EActorCCPreset>>";
}

impl Variant for EActorCCPreset {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorCCPreset")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorCCPreset".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorCCPreset>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorCCPreset>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorCCPreset>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorEmotionState {
    AES_Ambient,
    AES_Alerted,
    AES_Scared,
    AES_Hunt,
    AES_Combat,
    AES_None,
}

impl Aligned for EActorEmotionState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorEmotionState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AES_Ambient => 0i32,
            Self::AES_Alerted => 1i32,
            Self::AES_Scared => 2i32,
            Self::AES_Hunt => 3i32,
            Self::AES_Combat => 4i32,
            Self::AES_None => 268435455i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorEmotionState {
     const TYPE_ID: &str = "EActorEmotionState";
}

impl StaticVariant for Vec<EActorEmotionState> {
     const TYPE_ID: &str = "TArray<EActorEmotionState>";
}

impl StaticVariant for Vec<Vec<EActorEmotionState>> {
     const TYPE_ID: &str = "TArray<TArray<EActorEmotionState>>";
}

impl Variant for EActorEmotionState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorEmotionState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorEmotionState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorEmotionState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorEmotionState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorEmotionState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorEventTypes {
    eAET_OnAlive,
    eAET_OnPacified,
    eAET_OnMurdered,
    eAET_OnAccidentDeath,
    eAET_OnUnnoticableKill,
    eAET_OnBodyNoticed,
    eAET_OnBodyBagged,
    eAET_OnDying,
    eAET_OnDead,
    eAET_OnBodyHidden,
    eAET_OnBodyFlushed,
    eAET_OnBodyDumped,
    eAET_OnDelete,
}

impl Aligned for EActorEventTypes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorEventTypes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAET_OnAlive => 0i32,
            Self::eAET_OnPacified => 1i32,
            Self::eAET_OnMurdered => 2i32,
            Self::eAET_OnAccidentDeath => 3i32,
            Self::eAET_OnUnnoticableKill => 4i32,
            Self::eAET_OnBodyNoticed => 5i32,
            Self::eAET_OnBodyBagged => 6i32,
            Self::eAET_OnDying => 7i32,
            Self::eAET_OnDead => 8i32,
            Self::eAET_OnBodyHidden => 9i32,
            Self::eAET_OnBodyFlushed => 10i32,
            Self::eAET_OnBodyDumped => 11i32,
            Self::eAET_OnDelete => 12i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorEventTypes {
     const TYPE_ID: &str = "EActorEventTypes";
}

impl StaticVariant for Vec<EActorEventTypes> {
     const TYPE_ID: &str = "TArray<EActorEventTypes>";
}

impl StaticVariant for Vec<Vec<EActorEventTypes>> {
     const TYPE_ID: &str = "TArray<TArray<EActorEventTypes>>";
}

impl Variant for EActorEventTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorEventTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorEventTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorEventTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorEventTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorEventTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorFaction {
    eActorFaction_Default,
    eActorFaction_VIP_1,
    eActorFaction_VIP_2,
    eActorFaction_VIP_3,
    eActorFaction_VIP_4,
    eActorFaction_VIP_5,
    eActorFaction_VIP_6,
    eActorFaction_VIP_7,
    eActorFaction_VIP_8,
    eActorFaction_VIP_9,
    eActorFaction_VIP_10,
    eActorFaction_VIP_11,
    eActorFaction_VIP_12,
    eActorFaction_VIP_13,
    eActorFaction_VIP_14,
    eActorFaction_VIP_15,
    eActorFaction_VIP_16,
    eActorFaction_VIP_17,
}

impl Aligned for EActorFaction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorFaction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActorFaction_Default => 0i32,
            Self::eActorFaction_VIP_1 => 1i32,
            Self::eActorFaction_VIP_2 => 2i32,
            Self::eActorFaction_VIP_3 => 3i32,
            Self::eActorFaction_VIP_4 => 4i32,
            Self::eActorFaction_VIP_5 => 5i32,
            Self::eActorFaction_VIP_6 => 6i32,
            Self::eActorFaction_VIP_7 => 7i32,
            Self::eActorFaction_VIP_8 => 8i32,
            Self::eActorFaction_VIP_9 => 9i32,
            Self::eActorFaction_VIP_10 => 10i32,
            Self::eActorFaction_VIP_11 => 11i32,
            Self::eActorFaction_VIP_12 => 12i32,
            Self::eActorFaction_VIP_13 => 13i32,
            Self::eActorFaction_VIP_14 => 14i32,
            Self::eActorFaction_VIP_15 => 15i32,
            Self::eActorFaction_VIP_16 => 16i32,
            Self::eActorFaction_VIP_17 => 17i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorFaction {
     const TYPE_ID: &str = "EActorFaction";
}

impl StaticVariant for Vec<EActorFaction> {
     const TYPE_ID: &str = "TArray<EActorFaction>";
}

impl StaticVariant for Vec<Vec<EActorFaction>> {
     const TYPE_ID: &str = "TArray<TArray<EActorFaction>>";
}

impl Variant for EActorFaction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorFaction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorFaction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorFaction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorFaction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorFaction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorGroup {
    eAG_Group_A,
    eAG_Group_B,
    eAG_Group_C,
    eAG_Group_D,
    eAG_Count,
}

impl Aligned for EActorGroup {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorGroup {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAG_Group_A => 0i32,
            Self::eAG_Group_B => 1i32,
            Self::eAG_Group_C => 2i32,
            Self::eAG_Group_D => 3i32,
            Self::eAG_Count => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorGroup {
     const TYPE_ID: &str = "EActorGroup";
}

impl StaticVariant for Vec<EActorGroup> {
     const TYPE_ID: &str = "TArray<EActorGroup>";
}

impl StaticVariant for Vec<Vec<EActorGroup>> {
     const TYPE_ID: &str = "TArray<TArray<EActorGroup>>";
}

impl Variant for EActorGroup {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorGroup")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorGroup".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorGroup>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorGroup>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorGroup>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorLookAtPriority {
    eALAPriority_Ambient,
    eALAPriority_AmbientHigh,
    eALAPriority_Alert,
    eALAPriority_AlertHigh,
    eALAPriority_Hunt,
    eALAPriority_HuntHigh,
    eALAPriority_Combat,
    eALAPriority_CombatHigh,
}

impl Aligned for EActorLookAtPriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorLookAtPriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eALAPriority_Ambient => 0i32,
            Self::eALAPriority_AmbientHigh => 1i32,
            Self::eALAPriority_Alert => 2i32,
            Self::eALAPriority_AlertHigh => 3i32,
            Self::eALAPriority_Hunt => 4i32,
            Self::eALAPriority_HuntHigh => 5i32,
            Self::eALAPriority_Combat => 6i32,
            Self::eALAPriority_CombatHigh => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorLookAtPriority {
     const TYPE_ID: &str = "EActorLookAtPriority";
}

impl StaticVariant for Vec<EActorLookAtPriority> {
     const TYPE_ID: &str = "TArray<EActorLookAtPriority>";
}

impl StaticVariant for Vec<Vec<EActorLookAtPriority>> {
     const TYPE_ID: &str = "TArray<TArray<EActorLookAtPriority>>";
}

impl Variant for EActorLookAtPriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorLookAtPriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorLookAtPriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorLookAtPriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorLookAtPriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorLookAtPriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorLookAtStopReason {
    eSR_Unknown,
    eSR_Disabled,
    eSR_DurationExpired,
    eSR_OutOfRange,
    eSR_OutOfSight,
    eSR_OutOfRemainingPathDistance,
    eSR_Interrupted,
    eSR_TargetRemoved,
    eSR_HigherPriorityProfile,
    eSR_HideInPlainSight,
}

impl Aligned for EActorLookAtStopReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorLookAtStopReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSR_Unknown => 0i32,
            Self::eSR_Disabled => 1i32,
            Self::eSR_DurationExpired => 2i32,
            Self::eSR_OutOfRange => 3i32,
            Self::eSR_OutOfSight => 4i32,
            Self::eSR_OutOfRemainingPathDistance => 5i32,
            Self::eSR_Interrupted => 6i32,
            Self::eSR_TargetRemoved => 7i32,
            Self::eSR_HigherPriorityProfile => 8i32,
            Self::eSR_HideInPlainSight => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorLookAtStopReason {
     const TYPE_ID: &str = "EActorLookAtStopReason";
}

impl StaticVariant for Vec<EActorLookAtStopReason> {
     const TYPE_ID: &str = "TArray<EActorLookAtStopReason>";
}

impl StaticVariant for Vec<Vec<EActorLookAtStopReason>> {
     const TYPE_ID: &str = "TArray<TArray<EActorLookAtStopReason>>";
}

impl Variant for EActorLookAtStopReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorLookAtStopReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorLookAtStopReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorLookAtStopReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorLookAtStopReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorLookAtStopReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorLookAtTargetType {
    eALAT_Invalid,
    eALAT_PositionTarget,
    eALAT_KnownEntityType,
    eALAT_PointOfInterest,
    eALAT_Hero,
    eALAT_Screenplay,
    eALAPT_Max,
}

impl Aligned for EActorLookAtTargetType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorLookAtTargetType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eALAT_Invalid => 0i32,
            Self::eALAT_PositionTarget => 1i32,
            Self::eALAT_KnownEntityType => 2i32,
            Self::eALAT_PointOfInterest => 3i32,
            Self::eALAT_Hero => 4i32,
            Self::eALAT_Screenplay => 5i32,
            Self::eALAPT_Max => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorLookAtTargetType {
     const TYPE_ID: &str = "EActorLookAtTargetType";
}

impl StaticVariant for Vec<EActorLookAtTargetType> {
     const TYPE_ID: &str = "TArray<EActorLookAtTargetType>";
}

impl StaticVariant for Vec<Vec<EActorLookAtTargetType>> {
     const TYPE_ID: &str = "TArray<TArray<EActorLookAtTargetType>>";
}

impl Variant for EActorLookAtTargetType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorLookAtTargetType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorLookAtTargetType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorLookAtTargetType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorLookAtTargetType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorLookAtTargetType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorObstacleBlockage {
    eAOB_Guard,
    eAOB_Civilian,
    eAOB_Threat,
    eAOB_Combat,
    eAOB_Suspect,
    eAOB_Lookout,
}

impl Aligned for EActorObstacleBlockage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorObstacleBlockage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAOB_Guard => 0i32,
            Self::eAOB_Civilian => 1i32,
            Self::eAOB_Threat => 2i32,
            Self::eAOB_Combat => 3i32,
            Self::eAOB_Suspect => 4i32,
            Self::eAOB_Lookout => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorObstacleBlockage {
     const TYPE_ID: &str = "EActorObstacleBlockage";
}

impl StaticVariant for Vec<EActorObstacleBlockage> {
     const TYPE_ID: &str = "TArray<EActorObstacleBlockage>";
}

impl StaticVariant for Vec<Vec<EActorObstacleBlockage>> {
     const TYPE_ID: &str = "TArray<TArray<EActorObstacleBlockage>>";
}

impl Variant for EActorObstacleBlockage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorObstacleBlockage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorObstacleBlockage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorObstacleBlockage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorObstacleBlockage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorObstacleBlockage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorPerceptionSensitivity {
    APS_AMBIENT_DEAFBLIND,
    APS_AMBIENT_SLEEPING,
    APS_AMBIENT_PREOCCUPIED,
    APS_AMBIENT,
    APS_ALERT_LOW,
    APS_ALERT,
    APS_COMBAT,
    APS_SPIDER_SENSE,
}

impl Aligned for EActorPerceptionSensitivity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorPerceptionSensitivity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::APS_AMBIENT_DEAFBLIND => 0i32,
            Self::APS_AMBIENT_SLEEPING => 1i32,
            Self::APS_AMBIENT_PREOCCUPIED => 2i32,
            Self::APS_AMBIENT => 3i32,
            Self::APS_ALERT_LOW => 4i32,
            Self::APS_ALERT => 5i32,
            Self::APS_COMBAT => 6i32,
            Self::APS_SPIDER_SENSE => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorPerceptionSensitivity {
     const TYPE_ID: &str = "EActorPerceptionSensitivity";
}

impl StaticVariant for Vec<EActorPerceptionSensitivity> {
     const TYPE_ID: &str = "TArray<EActorPerceptionSensitivity>";
}

impl StaticVariant for Vec<Vec<EActorPerceptionSensitivity>> {
     const TYPE_ID: &str = "TArray<TArray<EActorPerceptionSensitivity>>";
}

impl Variant for EActorPerceptionSensitivity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorPerceptionSensitivity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorPerceptionSensitivity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorPerceptionSensitivity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorPerceptionSensitivity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorPerceptionSensitivity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorRank {
    AR_Default,
    AR_Elite,
    AR_Cop,
    AR_Goon,
}

impl Aligned for EActorRank {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorRank {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AR_Default => 0i32,
            Self::AR_Elite => 1i32,
            Self::AR_Cop => 2i32,
            Self::AR_Goon => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorRank {
     const TYPE_ID: &str = "EActorRank";
}

impl StaticVariant for Vec<EActorRank> {
     const TYPE_ID: &str = "TArray<EActorRank>";
}

impl StaticVariant for Vec<Vec<EActorRank>> {
     const TYPE_ID: &str = "TArray<TArray<EActorRank>>";
}

impl Variant for EActorRank {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorRank")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorRank".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorRank>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorRank>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorRank>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorRole {
    eActorRole_Default,
    eActorRole_Bodyguard,
    eActorRole_VIP,
}

impl Aligned for EActorRole {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorRole {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActorRole_Default => 0i32,
            Self::eActorRole_Bodyguard => 1i32,
            Self::eActorRole_VIP => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorRole {
     const TYPE_ID: &str = "EActorRole";
}

impl StaticVariant for Vec<EActorRole> {
     const TYPE_ID: &str = "TArray<EActorRole>";
}

impl StaticVariant for Vec<Vec<EActorRole>> {
     const TYPE_ID: &str = "TArray<TArray<EActorRole>>";
}

impl Variant for EActorRole {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorRole")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorRole".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorRole>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorRole>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorRole>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorSecondaryIconState {
    eSIS_Clear,
    eSIS_Infected,
    eSIS_Infected_Stage1,
    eSIS_Infected_Stage2,
    eSIS_Infected_Stage3,
}

impl Aligned for EActorSecondaryIconState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorSecondaryIconState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSIS_Clear => 0i32,
            Self::eSIS_Infected => 1i32,
            Self::eSIS_Infected_Stage1 => 2i32,
            Self::eSIS_Infected_Stage2 => 3i32,
            Self::eSIS_Infected_Stage3 => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorSecondaryIconState {
     const TYPE_ID: &str = "EActorSecondaryIconState";
}

impl StaticVariant for Vec<EActorSecondaryIconState> {
     const TYPE_ID: &str = "TArray<EActorSecondaryIconState>";
}

impl StaticVariant for Vec<Vec<EActorSecondaryIconState>> {
     const TYPE_ID: &str = "TArray<TArray<EActorSecondaryIconState>>";
}

impl Variant for EActorSecondaryIconState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorSecondaryIconState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorSecondaryIconState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorSecondaryIconState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorSecondaryIconState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorSecondaryIconState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorSoundDefs {
    _NoSound,
    Dth_BrkNck,
    Dth_Fll,
    Dth_GnSht,
    Dth_HdSht,
    Dth_Mpct,
    Dth_SltThrt,
    Dth_Strngl,
    Dth_Xplo,
    Dth_PrpF,
    Dth_Electro,
    Dth_Burn,
    Dth_Crush,
    Dth_Scrm,
    Dth_Hrt,
    Dth_SrpsGrab,
    Dth_HumShldStrain,
    Dth_Snore,
    Dth_Groan,
    Dth_Dump,
    Dth_PrpTssFrntAck,
    Dth_Headlock,
    Dth_Blinded,
    Dth_BeeSting,
    Dth_Grab,
    Gen_Grt47,
    Gen_GrtGrd47WGun,
    Gen_GrtTrgt,
    Gen_GrtTrgtRsp,
    Gen_NPC2NPCGrt,
    Gen_NPC2NPCRsp,
    Gen_GtHlp,
    Gen_GtHlpLd,
    Gen_GtHlp47Knwn,
    Gen_Mssng,
    Gen_HMHere,
    Gen_HMThere,
    Gen_SrpsLow,
    Gen_SrpsLowShort,
    Gen_Srps,
    Gen_SrpsLd,
    Gen_StndRsp,
    Gen_Stop,
    Gen_StopLd,
    Gen_Reveal,
    Gen_ThumbsUp,
    Gen_BrknAck,
    Gen_Ack,
    Gen_AckLd,
    Gen_AckNtnse,
    Gen_BumpAck,
    Gen_Curse,
    Gen_CurseLow,
    Gen_DrpGun,
    Gen_DrpCase,
    Gen_CoinCurse,
    Gen_TransportGreet,
    Gen_Thanks,
    Gen_ReturnItem2Guard,
    Gen_NoWay1,
    Gen_NoWay2Kidding,
    Gen_NoWay3Joke,
    Gen_NoWay44Real,
    Gen_NoWay5DntBeliv,
    Gen_NoWay6Serious,
    Gen_NoWay7Horrible,
    Gen_Way1,
    Gen_Way2Kidding,
    Gen_Way3Joke,
    Gen_Way44Real,
    Gen_Way5DntBeliv,
    Gen_Way6Serious,
    Gen_Way7Horrible,
    Gen_NkdRunAck,
    Gen_Grasp,
    Gen_Amused,
    Gen_Annoyed,
    Gen_BdygrdArrive,
    Gen_BdygrdMovOut,
    Gen_GiveUp,
    Gen_Off,
    Gen_On,
    Gen_PanicLow,
    Gen_Sick,
    Gen_SmellAck,
    Gen_SmrtPhnAct,
    Gen_PhoneAct,
    Gen_OutbreakInfect,
    Gen_OutbreakSick,
    Gen_OutbreakWhine,
    Gtag,
    ClsCmbt_Ack,
    ClsCmbt_Tnt,
    Cmbt_BackupCll,
    Cmbt_BadDsg,
    Cmbt_Beg,
    Cmbt_ClsAck,
    Cmbt_Fire,
    Cmbt_FireLdr,
    Cmbt_GtHit,
    Cmbt_HitHM,
    Cmbt_HMClsCmbtAck,
    Cmbt_HMCvr,
    Cmbt_HMFire,
    Cmbt_HMFlnk,
    Cmbt_HMHeadPopr,
    Cmbt_HMKll,
    Cmbt_HMKllCiv,
    Cmbt_HMKllName,
    Cmbt_HMKllPrpTss,
    Cmbt_HMMssTnt,
    Cmbt_HMShrpShtr,
    Cmbt_HMSpttd,
    Cmbt_HMVnshd,
    Cmbt_Hold,
    Cmbt_HoldLdr,
    Cmbt_HumShldRls1,
    Cmbt_HumShldRls2,
    Cmbt_HumShldRls3,
    Cmbt_HumShldRlsFem1,
    Cmbt_HumShldRlsFem2,
    Cmbt_HumShldRlsFem3,
    Cmbt_HumShldVctm,
    Cmbt_HumShldLdr,
    Cmbt_LngLst,
    Cmbt_LngLstRsp,
    Cmbt_LstMnStn,
    Cmbt_LstSght,
    Cmbt_LstSghtRsp,
    Cmbt_NdrAttck,
    Cmbt_Relod,
    Cmbt_Scrm,
    Cmbt_ThrowFlash,
    Cmbt_ThrowFlashMiss,
    Cmbt_ThrowFlashMiss2,
    Cmbt_ThrowFlashWin,
    Cmbt_ThrowFlashWin2,
    Cmbt_TkDwnLdr,
    Cmbt_VntAck,
    Cmbt_Whmp,
    Cmbt_StalemateHold,
    Cmbt_StalemateTnt,
    Cmbt_TriggerTheAlarm,
    Cmbt_47Mpty,
    Cmbt_47SuperSize,
    Evac_PrtTrgtSolo,
    Evac_PrtTrgtAck,
    Evac_PrtTrgtAckLdr,
    Evac_PrtTrgtEscrt,
    Evac_PrtTrgtStop,
    Evac_PrtTrgtStnd,
    Evac_PrtTrgtStndRsp,
    Evac_Cornered,
    Evac_MovOut,
    Evac_PathChange,
    Evac_PeelOff,
    Evac_LastPeelOff,
    Evac_ShltrArrv,
    Evac_ShltrBad,
    Evac_ShltrLdr,
    Evac_ShltrRsp,
    Evac_TrgtHitRsp,
    AvoidXplo_Ack,
    AvoidXplo_Stnd,
    Ar_47BadAction,
    Ar_47X,
    Ar_BadDsg,
    Ar_BlmeKll,
    Ar_BlameKnckDwn,
    Ar_BlameKnckDwnPT,
    Ar_BlameKllPT,
    Ar_47BadActionPT,
    Ar_DrgBody,
    Ar_FkeSrrdrTnt,
    Ar_HMDoor,
    Ar_Strangle,
    Ar_Trspss,
    Ar_WeapWrn1,
    Ar_WeapWrn2,
    Ar_Wrn1,
    Ar_Wrn2,
    Ar_Wrn3,
    Ar_VictimAck,
    Ar_Thief,
    Ar_Rsp,
    Sniper_Ack,
    InCa_BackupCll,
    InCa_ChckCvr,
    InCa_CivRptFail,
    InCa_CivUpset,
    InCa_ClstTnt,
    InCa_HMTnt,
    InCa_Idle,
    InCa_NitiateHMKnwn,
    InCa_SrchLdr,
    InCa_Stnd,
    InCa_StndAgtd,
    InCa_StndAgtdLdr,
    InCa_StndAgtdHMKnwn,
    InCa_StndAgtdHMKnwnLdr,
    InCa_StndHMKnwn,
    InCa_StndHMKnwnLdr,
    InCa_StndLdr,
    InCa_StndRsp,
    InCa_StndLckDwnFlsAlrm,
    InCa_VntTnt,
    InCa_Brk2Civ,
    InCa_Brk2Grd,
    InCa_Brk2Rdo,
    InCa_BrkAsk,
    InCa_GhostAsk,
    InCa_TriggerTheAlarm,
    InCa_Xpln47Thief,
    InCa_DstrssInv,
    InCa_DstrssLdr,
    InCa_DstrssInvLdr,
    InCa_WakeAsk,
    InCa_47Rcall,
    InCa_WakerStnd,
    InCa_ClsCmbtAck,
    InCa_SeeDthInv,
    InCa_SeeDthInvLdr,
    InCa_SeeDthLdr,
    InCa_XploInv,
    InCa_XploInvLdr,
    InCa_XploLdr,
    InCa_AlarmAck,
    InCa_GnShtInv,
    InCa_GnShtInvLdr,
    InCa_GnShtLdr,
    InCa_RecurSvrInv,
    InCa_RecurSvrInvLdr,
    InCa_RecurSvrInvRsp,
    InCa_RecurSvrLdr,
    InCa_RecurSvrRsp,
    InCa_LckDwnGtOutLdr,
    InCa_LckDwnGtOutRsp,
    InCa_LckDwnWrn1,
    InCa_LckDwnWrn2,
    InCa_LckDwnWrn3,
    InCa_LckDwnCivCmnt,
    InCa_FrskAck,
    InCa_Frsk,
    InCa_FrskCln,
    InCa_FrskWpn,
    InCa_Xpln47Wpn,
    InCa_XplnAccdnt,
    InCa_XplnDedBdy,
    InCa_XplnDedBdyMassive,
    InCa_XplnDrgBdy,
    InCa_XplnDstrss,
    InCa_XplnExplo,
    InCa_XplnGhost,
    InCa_XplnGnsht,
    InCa_XplnNkdBdy,
    InCa_XplnPcfdBdy,
    InCa_XplnSeeDth,
    InCa_XplnTrspss,
    InCa_XplnX,
    InCa_XplnWpn,
    InCa_XplnDsg,
    InCa_XplnImposter,
    InCa_XplnRecurSvr,
    InCa_XplnRsp,
    InCa_XplnAckRdo,
    InCa_XplnKnckDwn,
    InCa_XplnKnckDwnVctm,
    InCa_XplnKnckDwnGhost,
    InCa_XplnSeeStrngl,
    InCa_XplnHuntTargetWin,
    InCa_XplnHuntTargetFail,
    InCa_VIPDownAck,
    InCa_VIPKillAck,
    Accdnt_Inv,
    InDedBdy_BloodPllAck,
    InDedBdy_Ack,
    InDedBdy_NkdAck,
    InDedBdy_Inv,
    InDedBdy_BllPllRpt,
    InDedBdy_Massive,
    InDedBdy_PcfdInv,
    InDedBdy_CntnAck,
    InDedBdy_Stnd,
    InDedBdy_CircleBdy,
    InDedBdy_CivCmnt,
    InDedBdy_PrmtrBrchWrn1,
    InDedBdy_PrmtrBrchWrn2,
    InDedBdy_47AsGrdAck,
    InDedBdy_BodyGone,
    InDedBdy_VctmRcvr,
    InDedBdy_WakerWake,
    InDedBdy_WakeRsp,
    InDedBdy_WakeNkdLdr,
    InDedBdy_WakeNkdRsp,
    Rcvr_Xpln47,
    Rcvr_XplnDsg,
    Rcvr_XplnKnckDwn,
    InDsg_FllwWrn1,
    InDsg_FllwWrn2,
    InDsg_FllwWrn3,
    InDsg_Pzzl,
    InDsg_Stnd,
    InDsg_StndDistance,
    InDsg_StndHidden,
    InDsg_HdNPlnSght,
    InDsg_FllwWrn1Ack,
    InDsg_FllwWrn1BadAction,
    InDsg_FllwWrn1Wpn,
    InDsg_FllwWrn1BadSound,
    InDsg_FllwWrnJoinr,
    InDsg_FllwWrn1ShadyItem,
    Trspss_Stnd,
    Trspss_Wrn1,
    Trspss_Wrn2,
    Trspss_Wrn3,
    Trspss_Rsp,
    Trspss_SrchAckLegal47,
    Trspss_EscortAck,
    Trspss_EscortRequest,
    Trspss_EscortRequestRepeat,
    Trspss_EscortStayClose,
    Trspss_EscortOk,
    Trspss_EscortStnd,
    Trspss_EscortArrest,
    Trspss_EscortExit,
    Trspss_EscortStayRequest,
    InCu_Brk2Rdo,
    InCu_CivCmnd,
    InCu_Stnd,
    InCu_CivRsp,
    InCu_BackupRqst,
    InCu_CrAlrmAck,
    InCu_CrAlrmLdr,
    InCu_CrAlrmStndRsp,
    InCu_FtStpsAck,
    InCu_FtStpsStnd,
    InCu_PrpTssHearAck,
    InCu_PrpTssHearInv,
    InCu_PrpTssHearLdr,
    InCu_PrpTssHearStndRsp,
    InCu_PrpTssSeeAck,
    InCu_PrpTssSeeInv,
    InCu_PrpTssSeeLdr,
    InCu_PrpTssSeeStndRsp,
    InCu_RdoAck,
    InCu_RdoInv,
    InCu_RdoLdr,
    InCu_RdoStndRsp,
    InCu_WpnInv,
    InCu_RecurAck,
    InCu_RecurInv,
    InCu_RecurLdr,
    InCu_RecurRsp,
    InCu_ItemAckLdr,
    InCu_CrAlrmStndStndRsp,
    InCu_EscrtTrgtRedLight,
    InCu_EscrtTrgtGreenLight,
    InSt_HMAglty,
    InSt_HMBz,
    InSt_HMBzStnd,
    InSt_HMEntXit,
    InSt_HMInCvr,
    InSt_HMSnkng,
    InSt_PrpTssSee,
    InSt_Stnd,
    InSt_Wrn,
    InSt_HM2Cls,
    InSt_SickAck,
    InSt_AdiosRequest,
    InSt_PQ,
    FseBx_Fixed,
    FseBx_Fixing,
    FseBx_GoFix,
    FseBx_SabAck,
    Sentry_DenyEntry,
    Sentry_Frsk,
    Sentry_FrskRequest,
    Sentry_ItemRequest,
    Sentry_Accepted,
    Sentry_FrskWpnAck,
    Sentry_47LoiterAck,
    Sentry_DenyDsg,
    Sentry_PostCommentLdr,
    Sentry_PostCommentRsp,
    VIP_MssgnA_Ldr,
    VIP_MssgnB_Rsp,
    VIP_MssgnC_Ldr,
    VIP_MssgnD_Rsp,
    VIP_MssngCallOut,
    Dth_Sick,
    Dth_Poison,
    Gen_Avoid,
    Gen_CloseCall,
    Gen_PhnPckUP,
    Gen_PhoneActLockdown,
    Cmbt_FlushOutLdr,
    Cmbt_HMPrptssKnckOut,
    InCa_FrskHeadsUpLdr,
    InCa_FrskHeadsUpRdo,
    InCa_XplnLOS,
    InCa_XplnGotShot,
    InDedBdy_CivCmntPhone,
    InDedBdy_NoFaulVctmXpln,
    InDsg_FllwWrn1Nkd,
    Ar_BlameKnckDwnMelee,
    Exp_Carry,
    Exp_ClearThroat,
    Exp_Cough,
    Exp_Drink,
    Exp_Exhale,
    Exp_Idle,
    Exp_Inhale,
    Exp_InhaleFast,
    Exp_Sniff,
    Exp_Swallow,
    Exp_Think,
    Exp_Scared,
    Exp_Gld,
    Exp_Dsppntd,
    Exp_InPain,
    InCa_AckBdy,
    InCa_AckBdyLdr,
    InDedBdy_CivCmntPcfd,
    InDedBdy_CivCmntPhonePcfd,
    Gen_SocialAck,
}

impl Aligned for EActorSoundDefs {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorSoundDefs {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::_NoSound => 0i32,
            Self::Dth_BrkNck => 1i32,
            Self::Dth_Fll => 2i32,
            Self::Dth_GnSht => 3i32,
            Self::Dth_HdSht => 4i32,
            Self::Dth_Mpct => 5i32,
            Self::Dth_SltThrt => 6i32,
            Self::Dth_Strngl => 7i32,
            Self::Dth_Xplo => 8i32,
            Self::Dth_PrpF => 9i32,
            Self::Dth_Electro => 10i32,
            Self::Dth_Burn => 11i32,
            Self::Dth_Crush => 12i32,
            Self::Dth_Scrm => 13i32,
            Self::Dth_Hrt => 14i32,
            Self::Dth_SrpsGrab => 15i32,
            Self::Dth_HumShldStrain => 16i32,
            Self::Dth_Snore => 17i32,
            Self::Dth_Groan => 18i32,
            Self::Dth_Dump => 19i32,
            Self::Dth_PrpTssFrntAck => 20i32,
            Self::Dth_Headlock => 21i32,
            Self::Dth_Blinded => 22i32,
            Self::Dth_BeeSting => 23i32,
            Self::Dth_Grab => 24i32,
            Self::Gen_Grt47 => 25i32,
            Self::Gen_GrtGrd47WGun => 26i32,
            Self::Gen_GrtTrgt => 27i32,
            Self::Gen_GrtTrgtRsp => 28i32,
            Self::Gen_NPC2NPCGrt => 29i32,
            Self::Gen_NPC2NPCRsp => 30i32,
            Self::Gen_GtHlp => 31i32,
            Self::Gen_GtHlpLd => 32i32,
            Self::Gen_GtHlp47Knwn => 33i32,
            Self::Gen_Mssng => 34i32,
            Self::Gen_HMHere => 35i32,
            Self::Gen_HMThere => 36i32,
            Self::Gen_SrpsLow => 37i32,
            Self::Gen_SrpsLowShort => 38i32,
            Self::Gen_Srps => 39i32,
            Self::Gen_SrpsLd => 40i32,
            Self::Gen_StndRsp => 41i32,
            Self::Gen_Stop => 42i32,
            Self::Gen_StopLd => 43i32,
            Self::Gen_Reveal => 44i32,
            Self::Gen_ThumbsUp => 45i32,
            Self::Gen_BrknAck => 46i32,
            Self::Gen_Ack => 47i32,
            Self::Gen_AckLd => 48i32,
            Self::Gen_AckNtnse => 49i32,
            Self::Gen_BumpAck => 50i32,
            Self::Gen_Curse => 51i32,
            Self::Gen_CurseLow => 52i32,
            Self::Gen_DrpGun => 53i32,
            Self::Gen_DrpCase => 54i32,
            Self::Gen_CoinCurse => 55i32,
            Self::Gen_TransportGreet => 56i32,
            Self::Gen_Thanks => 57i32,
            Self::Gen_ReturnItem2Guard => 58i32,
            Self::Gen_NoWay1 => 59i32,
            Self::Gen_NoWay2Kidding => 60i32,
            Self::Gen_NoWay3Joke => 61i32,
            Self::Gen_NoWay44Real => 62i32,
            Self::Gen_NoWay5DntBeliv => 63i32,
            Self::Gen_NoWay6Serious => 64i32,
            Self::Gen_NoWay7Horrible => 65i32,
            Self::Gen_Way1 => 66i32,
            Self::Gen_Way2Kidding => 67i32,
            Self::Gen_Way3Joke => 68i32,
            Self::Gen_Way44Real => 69i32,
            Self::Gen_Way5DntBeliv => 70i32,
            Self::Gen_Way6Serious => 71i32,
            Self::Gen_Way7Horrible => 72i32,
            Self::Gen_NkdRunAck => 73i32,
            Self::Gen_Grasp => 74i32,
            Self::Gen_Amused => 75i32,
            Self::Gen_Annoyed => 76i32,
            Self::Gen_BdygrdArrive => 77i32,
            Self::Gen_BdygrdMovOut => 78i32,
            Self::Gen_GiveUp => 79i32,
            Self::Gen_Off => 80i32,
            Self::Gen_On => 81i32,
            Self::Gen_PanicLow => 82i32,
            Self::Gen_Sick => 83i32,
            Self::Gen_SmellAck => 84i32,
            Self::Gen_SmrtPhnAct => 85i32,
            Self::Gen_PhoneAct => 86i32,
            Self::Gen_OutbreakInfect => 87i32,
            Self::Gen_OutbreakSick => 88i32,
            Self::Gen_OutbreakWhine => 89i32,
            Self::Gtag => 90i32,
            Self::ClsCmbt_Ack => 91i32,
            Self::ClsCmbt_Tnt => 92i32,
            Self::Cmbt_BackupCll => 93i32,
            Self::Cmbt_BadDsg => 94i32,
            Self::Cmbt_Beg => 95i32,
            Self::Cmbt_ClsAck => 96i32,
            Self::Cmbt_Fire => 97i32,
            Self::Cmbt_FireLdr => 98i32,
            Self::Cmbt_GtHit => 99i32,
            Self::Cmbt_HitHM => 100i32,
            Self::Cmbt_HMClsCmbtAck => 101i32,
            Self::Cmbt_HMCvr => 102i32,
            Self::Cmbt_HMFire => 103i32,
            Self::Cmbt_HMFlnk => 104i32,
            Self::Cmbt_HMHeadPopr => 105i32,
            Self::Cmbt_HMKll => 106i32,
            Self::Cmbt_HMKllCiv => 107i32,
            Self::Cmbt_HMKllName => 108i32,
            Self::Cmbt_HMKllPrpTss => 109i32,
            Self::Cmbt_HMMssTnt => 110i32,
            Self::Cmbt_HMShrpShtr => 111i32,
            Self::Cmbt_HMSpttd => 112i32,
            Self::Cmbt_HMVnshd => 113i32,
            Self::Cmbt_Hold => 114i32,
            Self::Cmbt_HoldLdr => 115i32,
            Self::Cmbt_HumShldRls1 => 116i32,
            Self::Cmbt_HumShldRls2 => 117i32,
            Self::Cmbt_HumShldRls3 => 118i32,
            Self::Cmbt_HumShldRlsFem1 => 119i32,
            Self::Cmbt_HumShldRlsFem2 => 120i32,
            Self::Cmbt_HumShldRlsFem3 => 121i32,
            Self::Cmbt_HumShldVctm => 122i32,
            Self::Cmbt_HumShldLdr => 123i32,
            Self::Cmbt_LngLst => 124i32,
            Self::Cmbt_LngLstRsp => 125i32,
            Self::Cmbt_LstMnStn => 126i32,
            Self::Cmbt_LstSght => 127i32,
            Self::Cmbt_LstSghtRsp => 128i32,
            Self::Cmbt_NdrAttck => 129i32,
            Self::Cmbt_Relod => 130i32,
            Self::Cmbt_Scrm => 131i32,
            Self::Cmbt_ThrowFlash => 132i32,
            Self::Cmbt_ThrowFlashMiss => 133i32,
            Self::Cmbt_ThrowFlashMiss2 => 134i32,
            Self::Cmbt_ThrowFlashWin => 135i32,
            Self::Cmbt_ThrowFlashWin2 => 136i32,
            Self::Cmbt_TkDwnLdr => 137i32,
            Self::Cmbt_VntAck => 138i32,
            Self::Cmbt_Whmp => 139i32,
            Self::Cmbt_StalemateHold => 140i32,
            Self::Cmbt_StalemateTnt => 141i32,
            Self::Cmbt_TriggerTheAlarm => 142i32,
            Self::Cmbt_47Mpty => 143i32,
            Self::Cmbt_47SuperSize => 144i32,
            Self::Evac_PrtTrgtSolo => 145i32,
            Self::Evac_PrtTrgtAck => 146i32,
            Self::Evac_PrtTrgtAckLdr => 147i32,
            Self::Evac_PrtTrgtEscrt => 148i32,
            Self::Evac_PrtTrgtStop => 149i32,
            Self::Evac_PrtTrgtStnd => 150i32,
            Self::Evac_PrtTrgtStndRsp => 151i32,
            Self::Evac_Cornered => 152i32,
            Self::Evac_MovOut => 153i32,
            Self::Evac_PathChange => 154i32,
            Self::Evac_PeelOff => 155i32,
            Self::Evac_LastPeelOff => 156i32,
            Self::Evac_ShltrArrv => 157i32,
            Self::Evac_ShltrBad => 158i32,
            Self::Evac_ShltrLdr => 159i32,
            Self::Evac_ShltrRsp => 160i32,
            Self::Evac_TrgtHitRsp => 161i32,
            Self::AvoidXplo_Ack => 162i32,
            Self::AvoidXplo_Stnd => 163i32,
            Self::Ar_47BadAction => 164i32,
            Self::Ar_47X => 165i32,
            Self::Ar_BadDsg => 166i32,
            Self::Ar_BlmeKll => 167i32,
            Self::Ar_BlameKnckDwn => 168i32,
            Self::Ar_BlameKnckDwnPT => 169i32,
            Self::Ar_BlameKllPT => 170i32,
            Self::Ar_47BadActionPT => 171i32,
            Self::Ar_DrgBody => 172i32,
            Self::Ar_FkeSrrdrTnt => 173i32,
            Self::Ar_HMDoor => 174i32,
            Self::Ar_Strangle => 175i32,
            Self::Ar_Trspss => 176i32,
            Self::Ar_WeapWrn1 => 177i32,
            Self::Ar_WeapWrn2 => 178i32,
            Self::Ar_Wrn1 => 179i32,
            Self::Ar_Wrn2 => 180i32,
            Self::Ar_Wrn3 => 181i32,
            Self::Ar_VictimAck => 182i32,
            Self::Ar_Thief => 183i32,
            Self::Ar_Rsp => 184i32,
            Self::Sniper_Ack => 185i32,
            Self::InCa_BackupCll => 186i32,
            Self::InCa_ChckCvr => 187i32,
            Self::InCa_CivRptFail => 188i32,
            Self::InCa_CivUpset => 189i32,
            Self::InCa_ClstTnt => 190i32,
            Self::InCa_HMTnt => 191i32,
            Self::InCa_Idle => 192i32,
            Self::InCa_NitiateHMKnwn => 193i32,
            Self::InCa_SrchLdr => 194i32,
            Self::InCa_Stnd => 195i32,
            Self::InCa_StndAgtd => 196i32,
            Self::InCa_StndAgtdLdr => 197i32,
            Self::InCa_StndAgtdHMKnwn => 198i32,
            Self::InCa_StndAgtdHMKnwnLdr => 199i32,
            Self::InCa_StndHMKnwn => 200i32,
            Self::InCa_StndHMKnwnLdr => 201i32,
            Self::InCa_StndLdr => 202i32,
            Self::InCa_StndRsp => 203i32,
            Self::InCa_StndLckDwnFlsAlrm => 204i32,
            Self::InCa_VntTnt => 205i32,
            Self::InCa_Brk2Civ => 206i32,
            Self::InCa_Brk2Grd => 207i32,
            Self::InCa_Brk2Rdo => 208i32,
            Self::InCa_BrkAsk => 209i32,
            Self::InCa_GhostAsk => 210i32,
            Self::InCa_TriggerTheAlarm => 211i32,
            Self::InCa_Xpln47Thief => 212i32,
            Self::InCa_DstrssInv => 213i32,
            Self::InCa_DstrssLdr => 214i32,
            Self::InCa_DstrssInvLdr => 215i32,
            Self::InCa_WakeAsk => 216i32,
            Self::InCa_47Rcall => 217i32,
            Self::InCa_WakerStnd => 218i32,
            Self::InCa_ClsCmbtAck => 219i32,
            Self::InCa_SeeDthInv => 220i32,
            Self::InCa_SeeDthInvLdr => 221i32,
            Self::InCa_SeeDthLdr => 222i32,
            Self::InCa_XploInv => 223i32,
            Self::InCa_XploInvLdr => 224i32,
            Self::InCa_XploLdr => 225i32,
            Self::InCa_AlarmAck => 226i32,
            Self::InCa_GnShtInv => 227i32,
            Self::InCa_GnShtInvLdr => 228i32,
            Self::InCa_GnShtLdr => 229i32,
            Self::InCa_RecurSvrInv => 230i32,
            Self::InCa_RecurSvrInvLdr => 231i32,
            Self::InCa_RecurSvrInvRsp => 232i32,
            Self::InCa_RecurSvrLdr => 233i32,
            Self::InCa_RecurSvrRsp => 234i32,
            Self::InCa_LckDwnGtOutLdr => 235i32,
            Self::InCa_LckDwnGtOutRsp => 236i32,
            Self::InCa_LckDwnWrn1 => 237i32,
            Self::InCa_LckDwnWrn2 => 238i32,
            Self::InCa_LckDwnWrn3 => 239i32,
            Self::InCa_LckDwnCivCmnt => 240i32,
            Self::InCa_FrskAck => 241i32,
            Self::InCa_Frsk => 242i32,
            Self::InCa_FrskCln => 243i32,
            Self::InCa_FrskWpn => 244i32,
            Self::InCa_Xpln47Wpn => 245i32,
            Self::InCa_XplnAccdnt => 246i32,
            Self::InCa_XplnDedBdy => 247i32,
            Self::InCa_XplnDedBdyMassive => 248i32,
            Self::InCa_XplnDrgBdy => 249i32,
            Self::InCa_XplnDstrss => 250i32,
            Self::InCa_XplnExplo => 251i32,
            Self::InCa_XplnGhost => 252i32,
            Self::InCa_XplnGnsht => 253i32,
            Self::InCa_XplnNkdBdy => 254i32,
            Self::InCa_XplnPcfdBdy => 255i32,
            Self::InCa_XplnSeeDth => 256i32,
            Self::InCa_XplnTrspss => 257i32,
            Self::InCa_XplnX => 258i32,
            Self::InCa_XplnWpn => 259i32,
            Self::InCa_XplnDsg => 260i32,
            Self::InCa_XplnImposter => 261i32,
            Self::InCa_XplnRecurSvr => 262i32,
            Self::InCa_XplnRsp => 263i32,
            Self::InCa_XplnAckRdo => 264i32,
            Self::InCa_XplnKnckDwn => 265i32,
            Self::InCa_XplnKnckDwnVctm => 266i32,
            Self::InCa_XplnKnckDwnGhost => 267i32,
            Self::InCa_XplnSeeStrngl => 268i32,
            Self::InCa_XplnHuntTargetWin => 269i32,
            Self::InCa_XplnHuntTargetFail => 270i32,
            Self::InCa_VIPDownAck => 271i32,
            Self::InCa_VIPKillAck => 272i32,
            Self::Accdnt_Inv => 273i32,
            Self::InDedBdy_BloodPllAck => 274i32,
            Self::InDedBdy_Ack => 275i32,
            Self::InDedBdy_NkdAck => 276i32,
            Self::InDedBdy_Inv => 277i32,
            Self::InDedBdy_BllPllRpt => 278i32,
            Self::InDedBdy_Massive => 279i32,
            Self::InDedBdy_PcfdInv => 280i32,
            Self::InDedBdy_CntnAck => 281i32,
            Self::InDedBdy_Stnd => 282i32,
            Self::InDedBdy_CircleBdy => 283i32,
            Self::InDedBdy_CivCmnt => 284i32,
            Self::InDedBdy_PrmtrBrchWrn1 => 285i32,
            Self::InDedBdy_PrmtrBrchWrn2 => 286i32,
            Self::InDedBdy_47AsGrdAck => 287i32,
            Self::InDedBdy_BodyGone => 288i32,
            Self::InDedBdy_VctmRcvr => 289i32,
            Self::InDedBdy_WakerWake => 290i32,
            Self::InDedBdy_WakeRsp => 291i32,
            Self::InDedBdy_WakeNkdLdr => 292i32,
            Self::InDedBdy_WakeNkdRsp => 293i32,
            Self::Rcvr_Xpln47 => 294i32,
            Self::Rcvr_XplnDsg => 295i32,
            Self::Rcvr_XplnKnckDwn => 296i32,
            Self::InDsg_FllwWrn1 => 297i32,
            Self::InDsg_FllwWrn2 => 298i32,
            Self::InDsg_FllwWrn3 => 299i32,
            Self::InDsg_Pzzl => 300i32,
            Self::InDsg_Stnd => 301i32,
            Self::InDsg_StndDistance => 302i32,
            Self::InDsg_StndHidden => 303i32,
            Self::InDsg_HdNPlnSght => 304i32,
            Self::InDsg_FllwWrn1Ack => 305i32,
            Self::InDsg_FllwWrn1BadAction => 306i32,
            Self::InDsg_FllwWrn1Wpn => 307i32,
            Self::InDsg_FllwWrn1BadSound => 308i32,
            Self::InDsg_FllwWrnJoinr => 309i32,
            Self::InDsg_FllwWrn1ShadyItem => 310i32,
            Self::Trspss_Stnd => 311i32,
            Self::Trspss_Wrn1 => 312i32,
            Self::Trspss_Wrn2 => 313i32,
            Self::Trspss_Wrn3 => 314i32,
            Self::Trspss_Rsp => 315i32,
            Self::Trspss_SrchAckLegal47 => 316i32,
            Self::Trspss_EscortAck => 317i32,
            Self::Trspss_EscortRequest => 318i32,
            Self::Trspss_EscortRequestRepeat => 319i32,
            Self::Trspss_EscortStayClose => 320i32,
            Self::Trspss_EscortOk => 321i32,
            Self::Trspss_EscortStnd => 322i32,
            Self::Trspss_EscortArrest => 323i32,
            Self::Trspss_EscortExit => 324i32,
            Self::Trspss_EscortStayRequest => 325i32,
            Self::InCu_Brk2Rdo => 326i32,
            Self::InCu_CivCmnd => 327i32,
            Self::InCu_Stnd => 328i32,
            Self::InCu_CivRsp => 329i32,
            Self::InCu_BackupRqst => 330i32,
            Self::InCu_CrAlrmAck => 331i32,
            Self::InCu_CrAlrmLdr => 332i32,
            Self::InCu_CrAlrmStndRsp => 333i32,
            Self::InCu_FtStpsAck => 334i32,
            Self::InCu_FtStpsStnd => 335i32,
            Self::InCu_PrpTssHearAck => 336i32,
            Self::InCu_PrpTssHearInv => 337i32,
            Self::InCu_PrpTssHearLdr => 338i32,
            Self::InCu_PrpTssHearStndRsp => 339i32,
            Self::InCu_PrpTssSeeAck => 340i32,
            Self::InCu_PrpTssSeeInv => 341i32,
            Self::InCu_PrpTssSeeLdr => 342i32,
            Self::InCu_PrpTssSeeStndRsp => 343i32,
            Self::InCu_RdoAck => 344i32,
            Self::InCu_RdoInv => 345i32,
            Self::InCu_RdoLdr => 346i32,
            Self::InCu_RdoStndRsp => 347i32,
            Self::InCu_WpnInv => 348i32,
            Self::InCu_RecurAck => 349i32,
            Self::InCu_RecurInv => 350i32,
            Self::InCu_RecurLdr => 351i32,
            Self::InCu_RecurRsp => 352i32,
            Self::InCu_ItemAckLdr => 353i32,
            Self::InCu_CrAlrmStndStndRsp => 354i32,
            Self::InCu_EscrtTrgtRedLight => 355i32,
            Self::InCu_EscrtTrgtGreenLight => 356i32,
            Self::InSt_HMAglty => 357i32,
            Self::InSt_HMBz => 358i32,
            Self::InSt_HMBzStnd => 359i32,
            Self::InSt_HMEntXit => 360i32,
            Self::InSt_HMInCvr => 361i32,
            Self::InSt_HMSnkng => 362i32,
            Self::InSt_PrpTssSee => 363i32,
            Self::InSt_Stnd => 364i32,
            Self::InSt_Wrn => 365i32,
            Self::InSt_HM2Cls => 366i32,
            Self::InSt_SickAck => 367i32,
            Self::InSt_AdiosRequest => 368i32,
            Self::InSt_PQ => 369i32,
            Self::FseBx_Fixed => 370i32,
            Self::FseBx_Fixing => 371i32,
            Self::FseBx_GoFix => 372i32,
            Self::FseBx_SabAck => 373i32,
            Self::Sentry_DenyEntry => 374i32,
            Self::Sentry_Frsk => 375i32,
            Self::Sentry_FrskRequest => 376i32,
            Self::Sentry_ItemRequest => 377i32,
            Self::Sentry_Accepted => 378i32,
            Self::Sentry_FrskWpnAck => 379i32,
            Self::Sentry_47LoiterAck => 380i32,
            Self::Sentry_DenyDsg => 381i32,
            Self::Sentry_PostCommentLdr => 382i32,
            Self::Sentry_PostCommentRsp => 383i32,
            Self::VIP_MssgnA_Ldr => 384i32,
            Self::VIP_MssgnB_Rsp => 385i32,
            Self::VIP_MssgnC_Ldr => 386i32,
            Self::VIP_MssgnD_Rsp => 387i32,
            Self::VIP_MssngCallOut => 388i32,
            Self::Dth_Sick => 389i32,
            Self::Dth_Poison => 390i32,
            Self::Gen_Avoid => 391i32,
            Self::Gen_CloseCall => 392i32,
            Self::Gen_PhnPckUP => 393i32,
            Self::Gen_PhoneActLockdown => 394i32,
            Self::Cmbt_FlushOutLdr => 395i32,
            Self::Cmbt_HMPrptssKnckOut => 396i32,
            Self::InCa_FrskHeadsUpLdr => 397i32,
            Self::InCa_FrskHeadsUpRdo => 398i32,
            Self::InCa_XplnLOS => 399i32,
            Self::InCa_XplnGotShot => 400i32,
            Self::InDedBdy_CivCmntPhone => 401i32,
            Self::InDedBdy_NoFaulVctmXpln => 402i32,
            Self::InDsg_FllwWrn1Nkd => 403i32,
            Self::Ar_BlameKnckDwnMelee => 404i32,
            Self::Exp_Carry => 405i32,
            Self::Exp_ClearThroat => 406i32,
            Self::Exp_Cough => 407i32,
            Self::Exp_Drink => 408i32,
            Self::Exp_Exhale => 409i32,
            Self::Exp_Idle => 410i32,
            Self::Exp_Inhale => 411i32,
            Self::Exp_InhaleFast => 412i32,
            Self::Exp_Sniff => 413i32,
            Self::Exp_Swallow => 414i32,
            Self::Exp_Think => 415i32,
            Self::Exp_Scared => 416i32,
            Self::Exp_Gld => 417i32,
            Self::Exp_Dsppntd => 418i32,
            Self::Exp_InPain => 419i32,
            Self::InCa_AckBdy => 420i32,
            Self::InCa_AckBdyLdr => 421i32,
            Self::InDedBdy_CivCmntPcfd => 422i32,
            Self::InDedBdy_CivCmntPhonePcfd => 423i32,
            Self::Gen_SocialAck => 424i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorSoundDefs {
     const TYPE_ID: &str = "EActorSoundDefs";
}

impl StaticVariant for Vec<EActorSoundDefs> {
     const TYPE_ID: &str = "TArray<EActorSoundDefs>";
}

impl StaticVariant for Vec<Vec<EActorSoundDefs>> {
     const TYPE_ID: &str = "TArray<TArray<EActorSoundDefs>>";
}

impl Variant for EActorSoundDefs {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorSoundDefs")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorSoundDefs".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorSoundDefs>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorSoundDefs>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorSoundDefs>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorState {
    AS_DEACTIVATED,
    AS_ALIVE,
    AS_DYING,
    AS_DEAD,
    AS_DISABLED,
}

impl Aligned for EActorState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_DEACTIVATED => 0i32,
            Self::AS_ALIVE => 1i32,
            Self::AS_DYING => 2i32,
            Self::AS_DEAD => 3i32,
            Self::AS_DISABLED => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorState {
     const TYPE_ID: &str = "EActorState";
}

impl StaticVariant for Vec<EActorState> {
     const TYPE_ID: &str = "TArray<EActorState>";
}

impl StaticVariant for Vec<Vec<EActorState>> {
     const TYPE_ID: &str = "TArray<TArray<EActorState>>";
}

impl Variant for EActorState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorType {
    eAT_Civilian,
    eAT_Guard,
    eAT_Hitman,
    eAT_Last,
}

impl Aligned for EActorType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAT_Civilian => 0i32,
            Self::eAT_Guard => 1i32,
            Self::eAT_Hitman => 2i32,
            Self::eAT_Last => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorType {
     const TYPE_ID: &str = "EActorType";
}

impl StaticVariant for Vec<EActorType> {
     const TYPE_ID: &str = "TArray<EActorType>";
}

impl StaticVariant for Vec<Vec<EActorType>> {
     const TYPE_ID: &str = "TArray<TArray<EActorType>>";
}

impl Variant for EActorType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EActorVoiceVariation {
    eAVV_Undefined,
    eAVV_ABIATTI,
    eAVV_ATHENASAVALAS,
    eAVV_BDYGRD01,
    eAVV_BDYGRD02,
    eAVV_BDYGRD03,
    eAVV_BDYGRD04,
    eAVV_BDYGRD05,
    eAVV_BDYGRD06,
    eAVV_BDYGRD07,
    eAVV_BERG,
    eAVV_BULLDOG_MANSIONSTAFF_F05,
    eAVV_BULLDOG_MANSIONSTAFF_F08,
    eAVV_BULLDOG_MANSIONSTAFF_F09,
    eAVV_BULLDOG_MANSIONSTAFF_F10,
    eAVV_BULLDOG_MANSIONSTAFF_M06,
    eAVV_BULLDOG_MANSIONSTAFF_M07,
    eAVV_BULLDOG_MANSIONSTAFF_M08,
    eAVV_BULLDOG_MANSIONSTAFF_M09,
    eAVV_BULLDOG_MANSIONSTAFF_M11,
    eAVV_BUSEY,
    eAVV_CARLISLEALEXA,
    eAVV_CARLISLEEDWARD,
    eAVV_CARLISLEEMMA,
    eAVV_CARLISLEGREGORY,
    eAVV_CARLISLEPATRICK,
    eAVV_CARLISLEREBECCA,
    eAVV_CARUSO,
    eAVV_CASSIDY,
    eAVV_CHEF01,
    eAVV_CHEF02,
    eAVV_CHEF03,
    eAVV_CHEF04,
    eAVV_CHURCHSTAFF01,
    eAVV_CHURCHSTAFF02,
    eAVV_CHURCHSTAFF03,
    eAVV_CIVFEM01,
    eAVV_CIVFEM02,
    eAVV_CIVFEM03,
    eAVV_CIVFEM04,
    eAVV_CIVFEM05,
    eAVV_CIVFEM06,
    eAVV_CIVFEM07,
    eAVV_CIVFEM08,
    eAVV_CIVFEM09,
    eAVV_CIVFEM10,
    eAVV_CIVFEMCH01,
    eAVV_CIVFEMCH02,
    eAVV_CIVFEMES01,
    eAVV_CIVFEMES02,
    eAVV_CIVFEMES03,
    eAVV_CIVFEMHI01,
    eAVV_CIVFEMHI02,
    eAVV_CIVFEMHI03,
    eAVV_CIVMALE01,
    eAVV_CIVMALE02,
    eAVV_CIVMALE03,
    eAVV_CIVMALE04,
    eAVV_CIVMALE05,
    eAVV_CIVMALE06,
    eAVV_CIVMALE07,
    eAVV_CIVMALE08,
    eAVV_CIVMALE09,
    eAVV_CIVMALE10,
    eAVV_CIVMALE11,
    eAVV_CIVMALECH01,
    eAVV_CIVMALECH02,
    eAVV_CIVMALEES01,
    eAVV_CIVMALEES02,
    eAVV_CIVMALEES03,
    eAVV_CIVMALEHI01,
    eAVV_CIVMALEHI02,
    eAVV_CIVMALEHI03,
    eAVV_CLEANER01,
    eAVV_CLEANER02,
    eAVV_CLEANER03,
    eAVV_CLEANERFEM01,
    eAVV_CLEANERFEM02,
    eAVV_CLEANERFEM03,
    eAVV_CONSTANT,
    eAVV_CREW01,
    eAVV_CREW02,
    eAVV_CREW04,
    eAVV_CROSS,
    eAVV_DALIA,
    eAVV_DELGADO,
    eAVV_DESANTIS,
    eAVV_DINO_BOSCO,
    eAVV_DOCTOR01,
    eAVV_DOCTOR06,
    eAVV_DOCTORFEM03,
    eAVV_DOCTORFEM04,
    eAVV_ET_ADONIS,
    eAVV_ET_ARGUS,
    eAVV_ET_CARDINAL,
    eAVV_ET_CONNER,
    eAVV_ET_DYLAN,
    eAVV_ET_FABA,
    eAVV_ET_GARY_LUNN,
    eAVV_ET_HARVERFOEK,
    eAVV_ET_LARIN,
    eAVV_ET_MOXON,
    eAVV_ET_MR_GIGGLES,
    eAVV_ET_PHILLIPOS,
    eAVV_ET_SCOTT_SARNO,
    eAVV_ET_TORVIK,
    eAVV_ET_TROUTT,
    eAVV_ET_VITO_DURIC,
    eAVV_FILMCREW01,
    eAVV_FILMCREW02,
    eAVV_FILMCREW03,
    eAVV_FILMCREW04,
    eAVV_FILMCREWFEM01,
    eAVV_FILMCREWFEM02,
    eAVV_FILMCREWFEM03,
    eAVV_FILMCREWFEM04,
    eAVV_FILMCREWFEM05,
    eAVV_FOD_FEM,
    eAVV_FOD_MALE,
    eAVV_FOX_BARTENDER_F08,
    eAVV_FOX_BARTENDER_F10,
    eAVV_FOX_BARTENDER_M07,
    eAVV_FOX_BARTENDER_M08,
    eAVV_FOX_BARTENDER_M09,
    eAVV_FOX_BARTENDER_MCH01,
    eAVV_FOX_DJ_M07,
    eAVV_FOX_DJ_M11,
    eAVV_FOX_ICAAGENT_M01,
    eAVV_FOX_ICAAGENT_M02,
    eAVV_FOX_ICAAGENT_M04,
    eAVV_FOX_ICAAGENT_M05,
    eAVV_FOX_ICAAGENT_M06,
    eAVV_FOX_ICAAGENT_M07,
    eAVV_FOX_STAFF_F05,
    eAVV_FOX_STAFF_F06,
    eAVV_FOX_STAFF_FCH01,
    eAVV_FOX_STAFF_M07,
    eAVV_FOX_STAFF_M08,
    eAVV_FOX_STAFF_M09,
    eAVV_FOX_TECH_F05,
    eAVV_FOX_TECH_F06,
    eAVV_FOX_TECH_F08,
    eAVV_FOX_TECH_FCH01,
    eAVV_FOX_TECH_M06,
    eAVV_FOX_TECH_M07,
    eAVV_FOX_TECH_M08,
    eAVV_FOX_TECH_M11,
    eAVV_FOX_THUG_M04,
    eAVV_FOX_THUG_M05,
    eAVV_FOX_THUG_M06,
    eAVV_FOX_THUG_M07,
    eAVV_FRANCO,
    eAVV_GARDENER01,
    eAVV_GARDENER02,
    eAVV_GARDENER03,
    eAVV_GARDENERFEM01,
    eAVV_GARDENERFEM02,
    eAVV_GARDENERFEM03,
    eAVV_GECKO_ARTTECH_F05,
    eAVV_GECKO_ARTTECH_F06,
    eAVV_GECKO_ARTTECH_F08,
    eAVV_GECKO_ARTTECH_F10,
    eAVV_GECKO_ARTTECH_M05,
    eAVV_GECKO_ARTTECH_M06,
    eAVV_GECKO_ARTTECH_M08,
    eAVV_GECKO_ARTTECH_M09,
    eAVV_GECKO_ATTENDANT_M09,
    eAVV_GECKO_ATTENDANT_MHI03,
    eAVV_GECKO_MAINTENANCE_FCH01,
    eAVV_GECKO_MAINTENANCE_M05,
    eAVV_GECKO_WAITER_F05,
    eAVV_GECKO_WAITER_F06,
    eAVV_GECKO_WAITER_F09,
    eAVV_GECKO_WAITER_F10,
    eAVV_GECKO_WAITER_FHI02,
    eAVV_GECKO_WAITER_M07,
    eAVV_GECKO_WAITER_M08,
    eAVV_GECKO_WAITER_M09,
    eAVV_GECKO_WAITER_M11,
    eAVV_GECKO_WAITER_MHI03,
    eAVV_GRAVES,
    eAVV_GUARDIA02,
    eAVV_GUARDIA03,
    eAVV_HOUSSTFF01,
    eAVV_HOUSSTFF02,
    eAVV_HOUSSTFF03,
    eAVV_HOUSSTFF06,
    eAVV_HOUSSTFFEM01,
    eAVV_HOUSSTFFEM02,
    eAVV_HOUSSTFFEM03,
    eAVV_HUSH,
    eAVV_ICAAGENT_M05,
    eAVV_INGRAM,
    eAVV_INTERN,
    eAVV_JANUS,
    eAVV_JOB_ACTORFEMHI02,
    eAVV_JOB_ACTORHI01,
    eAVV_JOB_ARCHTCTF05,
    eAVV_JOB_ARCHTCTF07,
    eAVV_JOB_ARCHTCTF08,
    eAVV_JOB_ARCHTCTF09,
    eAVV_JOB_ARCHTCTM06,
    eAVV_JOB_ARCHTCTM07,
    eAVV_JOB_ARCHTCTM08,
    eAVV_JOB_ARCHTCTM09,
    eAVV_JOB_ARCHTCTM10,
    eAVV_JOB_ARKELITE04,
    eAVV_JOB_ARKELITE05,
    eAVV_JOB_ARKELITE06,
    eAVV_JOB_ARKELITE07,
    eAVV_JOB_ARKIANF05,
    eAVV_JOB_ARKIANF06,
    eAVV_JOB_ARKIANF07,
    eAVV_JOB_ARKIANF08,
    eAVV_JOB_ARKIANF09,
    eAVV_JOB_ARKIANM06,
    eAVV_JOB_ARKIANM07,
    eAVV_JOB_ARKIANM08,
    eAVV_JOB_ARKIANM09,
    eAVV_JOB_ARKIANM10,
    eAVV_JOB_ARKPTRNF05,
    eAVV_JOB_ARKPTRNF06,
    eAVV_JOB_ARKPTRNF07,
    eAVV_JOB_ARKPTRNF08,
    eAVV_JOB_ARKPTRNF09,
    eAVV_JOB_ARKPTRNM06,
    eAVV_JOB_ARKPTRNM07,
    eAVV_JOB_ARKPTRNM08,
    eAVV_JOB_ARKPTRNM09,
    eAVV_JOB_ARKPTRNM10,
    eAVV_JOB_ARKSTAFFF05,
    eAVV_JOB_ARKSTAFFF06,
    eAVV_JOB_ARKSTAFFM06,
    eAVV_JOB_ARKSTAFFM07,
    eAVV_JOB_ARKSTAFFM08,
    eAVV_JOB_BANKERF05,
    eAVV_JOB_BANKERF06,
    eAVV_JOB_BANKERF08,
    eAVV_JOB_BANKERM06,
    eAVV_JOB_BANKERM07,
    eAVV_JOB_BANKERM08,
    eAVV_JOB_BANKERM09,
    eAVV_JOB_BANKGRD05,
    eAVV_JOB_BANKGRD06,
    eAVV_JOB_BANKGRD07,
    eAVV_JOB_BANKGRDCHF,
    eAVV_JOB_BANKIT07,
    eAVV_JOB_BANKMTNC08,
    eAVV_JOB_BBQGRD04,
    eAVV_JOB_BBQGRD05,
    eAVV_JOB_BBQGRD06,
    eAVV_JOB_BBQGRD07,
    eAVV_JOB_BOLLYCREWHI01,
    eAVV_JOB_BOLLYCREWHI02,
    eAVV_JOB_BOLLYCREWHI03,
    eAVV_JOB_CASSIDYGRD04,
    eAVV_JOB_CASSIDYGRD05,
    eAVV_JOB_CASSIDYGRD06,
    eAVV_JOB_CASSIDYGRD07,
    eAVV_JOB_CASTLESTFEM05,
    eAVV_JOB_CASTLESTFEM07,
    eAVV_JOB_CASTLESTFF07,
    eAVV_JOB_CASTLESTFF10,
    eAVV_JOB_CAVEGDES01,
    eAVV_JOB_CAVEGDES02,
    eAVV_JOB_CAVEWKR07,
    eAVV_JOB_CAVEWKR08,
    eAVV_JOB_CAVEWKRES01,
    eAVV_JOB_CAVEWKRES02,
    eAVV_JOB_CAVEWKRES03,
    eAVV_JOB_CHEFES01,
    eAVV_JOB_CHEFES02,
    eAVV_JOB_CHEFES03,
    eAVV_JOB_CHEFF07,
    eAVV_JOB_CHEFM06,
    eAVV_JOB_CHEFM07,
    eAVV_JOB_CHEFM09,
    eAVV_JOB_CIVGRD04,
    eAVV_JOB_CIVGRD05,
    eAVV_JOB_CIVGRD06,
    eAVV_JOB_CIVGRD07,
    eAVV_JOB_CLOTHSALHI01,
    eAVV_JOB_CLOTHSALHI02,
    eAVV_JOB_CNSTR08,
    eAVV_JOB_CNSTR09,
    eAVV_JOB_CNSTRES01,
    eAVV_JOB_CNSTRGRD04,
    eAVV_JOB_CNSTRGRD05,
    eAVV_JOB_CNSTRGRD06,
    eAVV_JOB_CNSTRGRD07,
    eAVV_JOB_COCAGRD06,
    eAVV_JOB_COCAGRDES02,
    eAVV_JOB_COP04,
    eAVV_JOB_COP05,
    eAVV_JOB_COP06,
    eAVV_JOB_COP07,
    eAVV_JOB_COUNSLRF08,
    eAVV_JOB_COUNSLRF09,
    eAVV_JOB_COUNSLRM07,
    eAVV_JOB_COUNSLRM09,
    eAVV_JOB_CUSTDNF05,
    eAVV_JOB_CUSTDNF06,
    eAVV_JOB_CUSTDNF07,
    eAVV_JOB_CUSTDNF08,
    eAVV_JOB_CUSTDNF09,
    eAVV_JOB_CUSTDNM06,
    eAVV_JOB_CUSTDNM07,
    eAVV_JOB_CUSTDNM08,
    eAVV_JOB_CUSTDNM09,
    eAVV_JOB_CUSTDNM10,
    eAVV_JOB_DRUGLABWKRES02,
    eAVV_JOB_DRUGLABWKRES03,
    eAVV_JOB_FARMF05,
    eAVV_JOB_FARMFES01,
    eAVV_JOB_FARMFES02,
    eAVV_JOB_FARMM06,
    eAVV_JOB_FARMM08,
    eAVV_JOB_FARMMES01,
    eAVV_JOB_FARMMES02,
    eAVV_JOB_FARMMES03,
    eAVV_JOB_GARBAGE08,
    eAVV_JOB_GARBAGE09,
    eAVV_JOB_GARBAGEES01,
    eAVV_JOB_GARBAGRD04,
    eAVV_JOB_GARBAGRD05,
    eAVV_JOB_GARBAGRD06,
    eAVV_JOB_GARBAGRD07,
    eAVV_JOB_GRDNR08,
    eAVV_JOB_GRDNR09,
    eAVV_JOB_GRDNRES01,
    eAVV_JOB_GRDNRGRD04,
    eAVV_JOB_GRDNRGRD05,
    eAVV_JOB_GRDNRGRD06,
    eAVV_JOB_GRDNRGRD07,
    eAVV_JOB_GUARD04,
    eAVV_JOB_GUARD05,
    eAVV_JOB_GUARD06,
    eAVV_JOB_GUARD07,
    eAVV_JOB_HSSTFFES02,
    eAVV_JOB_HSSTFFES03,
    eAVV_JOB_HSSTFMES02,
    eAVV_JOB_HSSTFMES03,
    eAVV_JOB_JANUSGRD04,
    eAVV_JOB_JANUSGRD05,
    eAVV_JOB_JANUSGRD06,
    eAVV_JOB_JANUSGRD07,
    eAVV_JOB_LNDRYGRDHI01,
    eAVV_JOB_LNDRYGRDHI02,
    eAVV_JOB_LNDRYGRDHI03,
    eAVV_JOB_LNDRYWKRHI01,
    eAVV_JOB_LNDRYWKRHI02,
    eAVV_JOB_LNDRYWKRHI03,
    eAVV_JOB_MANSIONGD05,
    eAVV_JOB_MANSIONGD06,
    eAVV_JOB_MANSIONGD07,
    eAVV_JOB_MANSIONGDES02,
    eAVV_JOB_MEDICFEM06,
    eAVV_JOB_MTLWKRHI01,
    eAVV_JOB_MTLWKRHI02,
    eAVV_JOB_MTLWKRHI03,
    eAVV_JOB_MUMBSECHI02,
    eAVV_JOB_MUMBSECHI03,
    eAVV_JOB_MUMBSRVHI01,
    eAVV_JOB_MUMBSRVHI02,
    eAVV_JOB_MUMBSRVHI03,
    eAVV_JOB_MUSICIANF05,
    eAVV_JOB_MUSICIANM06,
    eAVV_JOB_MUSICIANM07,
    eAVV_JOB_MUSICIANM08,
    eAVV_JOB_MUSICIANM09,
    eAVV_JOB_MUSICIANM10,
    eAVV_JOB_NITIATEF05,
    eAVV_JOB_NITIATEM06,
    eAVV_JOB_NITIATEM07,
    eAVV_JOB_QUEENGRDHI01,
    eAVV_JOB_QUEENGRDHI02,
    eAVV_JOB_QUEENGRDHI03,
    eAVV_JOB_QUEENSTGHI03,
    eAVV_JOB_QUEENTGHI02,
    eAVV_JOB_RAIDER04,
    eAVV_JOB_RAIDER05,
    eAVV_JOB_RAIDER06,
    eAVV_JOB_RAIDER07,
    eAVV_JOB_RANGANGRD05,
    eAVV_JOB_RANGANGRD06,
    eAVV_JOB_RANGANSECHI01,
    eAVV_JOB_RANGANSECHI02,
    eAVV_JOB_RANGANSECHI03,
    eAVV_JOB_SERVANT08,
    eAVV_JOB_SERVANT09,
    eAVV_JOB_SERVANTES02,
    eAVV_JOB_SERVANTFEM07,
    eAVV_JOB_SITEWKR06,
    eAVV_JOB_SITEWKR07,
    eAVV_JOB_SITEWKR08,
    eAVV_JOB_SITEWKR09,
    eAVV_JOB_SITEWKRES01,
    eAVV_JOB_SITEWKRES02,
    eAVV_JOB_SITEWKRES03,
    eAVV_JOB_STINGLIFEGRDM06,
    eAVV_JOB_STINGSEC05,
    eAVV_JOB_STINGSEC06,
    eAVV_JOB_STINGSMASSF09,
    eAVV_JOB_STINGSTAFFF08,
    eAVV_JOB_STINGSTAFFM06,
    eAVV_JOB_STINGSTAFFM08,
    eAVV_JOB_STINGTECHF08,
    eAVV_JOB_STINGTECHM07,
    eAVV_JOB_STINGTECHM09,
    eAVV_JOB_STINGTRAINERF06,
    eAVV_JOB_STINGVILLAGRD05,
    eAVV_JOB_STINGVILLAGRD06,
    eAVV_JOB_STINGWTRF05,
    eAVV_JOB_STINGWTRM07,
    eAVV_JOB_STINGWTRM08,
    eAVV_JOB_SUBWKR06,
    eAVV_JOB_SUBWKR07,
    eAVV_JOB_TEASERVHI02,
    eAVV_JOB_THUGHI01,
    eAVV_JOB_THUGHI02,
    eAVV_JOB_THUGHI03,
    eAVV_JOB_TRAINSERVHI01,
    eAVV_JOB_VILLAGEGDES01,
    eAVV_JOB_VILLAGEGDES03,
    eAVV_KNOX_R,
    eAVV_KNOX_S,
    eAVV_KONG,
    eAVV_LJUDMILAVETROVA,
    eAVV_LLAMA_WAITER_F05,
    eAVV_LLAMA_WAITER_F06,
    eAVV_LLAMA_WAITER_F10,
    eAVV_LLAMA_WAITER_M06,
    eAVV_LLAMA_WAITER_M07,
    eAVV_LLAMA_WAITER_M11,
    eAVV_LLAMA_WORKER_FES01,
    eAVV_LLAMA_WORKER_FES02,
    eAVV_LLAMA_WORKER_FES03,
    eAVV_LLAMA_WORKER_MES01,
    eAVV_LLAMA_WORKER_MES02,
    eAVV_LLAMA_WORKER_MES03,
    eAVV_MAELSTROM,
    eAVV_MAMBACREW01,
    eAVV_MAMBACREW02,
    eAVV_MAMBACREW03,
    eAVV_MAMBACREW04,
    eAVV_MARTINEZ,
    eAVV_MECH01,
    eAVV_MECH02,
    eAVV_MECH03,
    eAVV_MENDOLA,
    eAVV_MODEL01,
    eAVV_MODEL02,
    eAVV_MODEL03,
    eAVV_MODELFEM01,
    eAVV_MODELFEM02,
    eAVV_MODELFEM03,
    eAVV_MORGAN,
    eAVV_NORFOLK,
    eAVV_NOVIKOV,
    eAVV_ORSON,
    eAVV_PARVATI,
    eAVV_RAT_DUMPLINGCOOK_F05,
    eAVV_RAT_DUMPLINGCOOK_F06,
    eAVV_RAT_DUMPLINGCOOK_FCH02,
    eAVV_RAT_DUMPLINGCOOK_M06,
    eAVV_RAT_DUMPLINGCOOK_M07,
    eAVV_RAT_DUMPLINGCOOK_M08,
    eAVV_RAT_DUMPLINGCOOK_M09,
    eAVV_RAT_DUMPLINGCOOK_MCH01,
    eAVV_RAT_DUMPLINGCOOK_MCH02,
    eAVV_RAT_FACILITYSTAFF_F06,
    eAVV_RAT_FACILITYSTAFF_F09,
    eAVV_RAT_FACILITYSTAFF_FCH01,
    eAVV_RAT_FACILITYSTAFF_FCH02,
    eAVV_RAT_FACILITYSTAFF_M06,
    eAVV_RAT_FACILITYSTAFF_M07,
    eAVV_RAT_FACILITYSTAFF_M08,
    eAVV_RAT_FACILITYSTAFF_M09,
    eAVV_RAT_FACILITYSTAFF_M11,
    eAVV_PRIEST01,
    eAVV_RANGAN,
    eAVV_REYNARD,
    eAVV_RITTER,
    eAVV_ROBERT_KNOX,
    eAVV_ROSE,
    eAVV_ROYCE,
    eAVV_SANTA,
    eAVV_SCIENTIST01,
    eAVV_SCIENTIST02,
    eAVV_SCIENTIST03,
    eAVV_SCIENTIST04,
    eAVV_SCIENTISTFEM01,
    eAVV_SCIENTISTFEM02,
    eAVV_SCIENTISTFEM03,
    eAVV_SCIENTISTFEM04,
    eAVV_SHAH,
    eAVV_SHEEPGRD04,
    eAVV_SHEEPGRD05,
    eAVV_SHEEPGRD06,
    eAVV_SHEEPGRD07,
    eAVV_SIERRA_KNOX,
    eAVV_SOFTGRD01,
    eAVV_SOFTGRD02,
    eAVV_SOFTGRD03,
    eAVV_SOLDIER01,
    eAVV_SOLDIER02,
    eAVV_SOLDIER03,
    eAVV_SOLDIERBOSS01,
    eAVV_SOLDIERBOSS02,
    eAVV_SOLDIERBOSS03,
    eAVV_SPECOPS01,
    eAVV_SPECOPS02,
    eAVV_SPECOPS03,
    eAVV_STAFFEM03,
    eAVV_STAFFEM04,
    eAVV_STAFFEM05,
    eAVV_STAFFMALE01,
    eAVV_STAFFMALE02,
    eAVV_STAFFMALE03,
    eAVV_STAFFMALE04,
    eAVV_STAFFMALE05,
    eAVV_STAFFMALE06,
    eAVV_STEVENBRADLEY,
    eAVV_STRANDBERG,
    eAVV_STUYVESANT,
    eAVV_STYLIST01,
    eAVV_STYLIST02,
    eAVV_STYLIST03,
    eAVV_STYLIST04,
    eAVV_STYLISTFEM01,
    eAVV_STYLISTFEM02,
    eAVV_STYLISTFEM03,
    eAVV_STYLISTFEM04,
    eAVV_THUGES01,
    eAVV_THUGES02,
    eAVV_THUGES03,
    eAVV_THUGHI01,
    eAVV_THUGHI02,
    eAVV_THUGHI03,
    eAVV_TYSONWILLIAMS,
    eAVV_VIDAL,
    eAVV_WAITER01,
    eAVV_WAITER02,
    eAVV_WAITER03,
    eAVV_WAITER04,
    eAVV_WAITERFEM01,
    eAVV_WAITERFEM02,
    eAVV_WAITERFEM03,
    eAVV_WAITERFEM04,
    eAVV_WASHINGTON,
    eAVV_WS_BOULTON,
    eAVV_WS_NEWMAN,
    eAVV_WS_WATSON,
    eAVV_YACHTCREW01,
    eAVV_YACHTCREW02,
    eAVV_YACHTCREW03,
    eAVV_YACHTCREW04,
    eAVV_YAMASAKI,
    eAVV_YATES,
    eAVV_ZAYDAN,
    eAVV_DUGONG_COOKJOB_FHI02,
    eAVV_DUGONG_COOKJOB_FHI03,
    eAVV_DUGONG_COOKJOB_MCH02,
    eAVV_DUGONG_COOKJOB_MHI02,
    eAVV_DUGONG_COOKJOB_MHI03,
    eAVV_DUGONG_ENGINEER_MCH02,
    eAVV_DUGONG_ENGINEER_MHI02,
    eAVV_DUGONG_ENGINEER_MHI03,
    eAVV_DUGONG_FARAH_FI03,
    eAVV_DUGONG_METALWKR_MHI02,
    eAVV_DUGONG_METALWKR_MHI03,
    eAVV_DUGONG_MILITIA_M05,
    eAVV_DUGONG_MILITIA_M06,
    eAVV_DUGONG_MILITIA_M07,
    eAVV_DUGONG_MILITIA_SP01,
    eAVV_DUGONG_PIRATE_MHI02,
    eAVV_DUGONG_PIRATE_MHI03,
    eAVV_CREST,
    eAVV_AKKA,
    eAVV_ET_DROP,
    eAVV_ET_PEN,
    eAVV_ET_LAMBC,
    eAVV_ET_LAMBIC,
    eAVV_ET_LAMBIC_CLONE,
    eAVV_ET_LAMPICCLONE,
    eAVV_ET_FRENTINI,
}

impl Aligned for EActorVoiceVariation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EActorVoiceVariation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAVV_Undefined => 0i32,
            Self::eAVV_ABIATTI => 1i32,
            Self::eAVV_ATHENASAVALAS => 2i32,
            Self::eAVV_BDYGRD01 => 3i32,
            Self::eAVV_BDYGRD02 => 4i32,
            Self::eAVV_BDYGRD03 => 5i32,
            Self::eAVV_BDYGRD04 => 6i32,
            Self::eAVV_BDYGRD05 => 7i32,
            Self::eAVV_BDYGRD06 => 8i32,
            Self::eAVV_BDYGRD07 => 9i32,
            Self::eAVV_BERG => 10i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_F05 => 11i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_F08 => 12i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_F09 => 13i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_F10 => 14i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_M06 => 15i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_M07 => 16i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_M08 => 17i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_M09 => 18i32,
            Self::eAVV_BULLDOG_MANSIONSTAFF_M11 => 19i32,
            Self::eAVV_BUSEY => 20i32,
            Self::eAVV_CARLISLEALEXA => 21i32,
            Self::eAVV_CARLISLEEDWARD => 22i32,
            Self::eAVV_CARLISLEEMMA => 23i32,
            Self::eAVV_CARLISLEGREGORY => 24i32,
            Self::eAVV_CARLISLEPATRICK => 25i32,
            Self::eAVV_CARLISLEREBECCA => 26i32,
            Self::eAVV_CARUSO => 27i32,
            Self::eAVV_CASSIDY => 28i32,
            Self::eAVV_CHEF01 => 29i32,
            Self::eAVV_CHEF02 => 30i32,
            Self::eAVV_CHEF03 => 31i32,
            Self::eAVV_CHEF04 => 32i32,
            Self::eAVV_CHURCHSTAFF01 => 33i32,
            Self::eAVV_CHURCHSTAFF02 => 34i32,
            Self::eAVV_CHURCHSTAFF03 => 35i32,
            Self::eAVV_CIVFEM01 => 36i32,
            Self::eAVV_CIVFEM02 => 37i32,
            Self::eAVV_CIVFEM03 => 38i32,
            Self::eAVV_CIVFEM04 => 39i32,
            Self::eAVV_CIVFEM05 => 40i32,
            Self::eAVV_CIVFEM06 => 41i32,
            Self::eAVV_CIVFEM07 => 42i32,
            Self::eAVV_CIVFEM08 => 43i32,
            Self::eAVV_CIVFEM09 => 44i32,
            Self::eAVV_CIVFEM10 => 45i32,
            Self::eAVV_CIVFEMCH01 => 46i32,
            Self::eAVV_CIVFEMCH02 => 47i32,
            Self::eAVV_CIVFEMES01 => 48i32,
            Self::eAVV_CIVFEMES02 => 49i32,
            Self::eAVV_CIVFEMES03 => 50i32,
            Self::eAVV_CIVFEMHI01 => 51i32,
            Self::eAVV_CIVFEMHI02 => 52i32,
            Self::eAVV_CIVFEMHI03 => 53i32,
            Self::eAVV_CIVMALE01 => 54i32,
            Self::eAVV_CIVMALE02 => 55i32,
            Self::eAVV_CIVMALE03 => 56i32,
            Self::eAVV_CIVMALE04 => 57i32,
            Self::eAVV_CIVMALE05 => 58i32,
            Self::eAVV_CIVMALE06 => 59i32,
            Self::eAVV_CIVMALE07 => 60i32,
            Self::eAVV_CIVMALE08 => 61i32,
            Self::eAVV_CIVMALE09 => 62i32,
            Self::eAVV_CIVMALE10 => 63i32,
            Self::eAVV_CIVMALE11 => 64i32,
            Self::eAVV_CIVMALECH01 => 65i32,
            Self::eAVV_CIVMALECH02 => 66i32,
            Self::eAVV_CIVMALEES01 => 67i32,
            Self::eAVV_CIVMALEES02 => 68i32,
            Self::eAVV_CIVMALEES03 => 69i32,
            Self::eAVV_CIVMALEHI01 => 70i32,
            Self::eAVV_CIVMALEHI02 => 71i32,
            Self::eAVV_CIVMALEHI03 => 72i32,
            Self::eAVV_CLEANER01 => 73i32,
            Self::eAVV_CLEANER02 => 74i32,
            Self::eAVV_CLEANER03 => 75i32,
            Self::eAVV_CLEANERFEM01 => 76i32,
            Self::eAVV_CLEANERFEM02 => 77i32,
            Self::eAVV_CLEANERFEM03 => 78i32,
            Self::eAVV_CONSTANT => 79i32,
            Self::eAVV_CREW01 => 80i32,
            Self::eAVV_CREW02 => 81i32,
            Self::eAVV_CREW04 => 82i32,
            Self::eAVV_CROSS => 83i32,
            Self::eAVV_DALIA => 84i32,
            Self::eAVV_DELGADO => 85i32,
            Self::eAVV_DESANTIS => 86i32,
            Self::eAVV_DINO_BOSCO => 87i32,
            Self::eAVV_DOCTOR01 => 88i32,
            Self::eAVV_DOCTOR06 => 89i32,
            Self::eAVV_DOCTORFEM03 => 90i32,
            Self::eAVV_DOCTORFEM04 => 91i32,
            Self::eAVV_ET_ADONIS => 92i32,
            Self::eAVV_ET_ARGUS => 93i32,
            Self::eAVV_ET_CARDINAL => 94i32,
            Self::eAVV_ET_CONNER => 95i32,
            Self::eAVV_ET_DYLAN => 96i32,
            Self::eAVV_ET_FABA => 97i32,
            Self::eAVV_ET_GARY_LUNN => 98i32,
            Self::eAVV_ET_HARVERFOEK => 99i32,
            Self::eAVV_ET_LARIN => 100i32,
            Self::eAVV_ET_MOXON => 101i32,
            Self::eAVV_ET_MR_GIGGLES => 102i32,
            Self::eAVV_ET_PHILLIPOS => 103i32,
            Self::eAVV_ET_SCOTT_SARNO => 104i32,
            Self::eAVV_ET_TORVIK => 105i32,
            Self::eAVV_ET_TROUTT => 106i32,
            Self::eAVV_ET_VITO_DURIC => 107i32,
            Self::eAVV_FILMCREW01 => 108i32,
            Self::eAVV_FILMCREW02 => 109i32,
            Self::eAVV_FILMCREW03 => 110i32,
            Self::eAVV_FILMCREW04 => 111i32,
            Self::eAVV_FILMCREWFEM01 => 112i32,
            Self::eAVV_FILMCREWFEM02 => 113i32,
            Self::eAVV_FILMCREWFEM03 => 114i32,
            Self::eAVV_FILMCREWFEM04 => 115i32,
            Self::eAVV_FILMCREWFEM05 => 116i32,
            Self::eAVV_FOD_FEM => 117i32,
            Self::eAVV_FOD_MALE => 118i32,
            Self::eAVV_FOX_BARTENDER_F08 => 119i32,
            Self::eAVV_FOX_BARTENDER_F10 => 120i32,
            Self::eAVV_FOX_BARTENDER_M07 => 121i32,
            Self::eAVV_FOX_BARTENDER_M08 => 122i32,
            Self::eAVV_FOX_BARTENDER_M09 => 123i32,
            Self::eAVV_FOX_BARTENDER_MCH01 => 124i32,
            Self::eAVV_FOX_DJ_M07 => 125i32,
            Self::eAVV_FOX_DJ_M11 => 126i32,
            Self::eAVV_FOX_ICAAGENT_M01 => 127i32,
            Self::eAVV_FOX_ICAAGENT_M02 => 128i32,
            Self::eAVV_FOX_ICAAGENT_M04 => 129i32,
            Self::eAVV_FOX_ICAAGENT_M05 => 130i32,
            Self::eAVV_FOX_ICAAGENT_M06 => 131i32,
            Self::eAVV_FOX_ICAAGENT_M07 => 132i32,
            Self::eAVV_FOX_STAFF_F05 => 133i32,
            Self::eAVV_FOX_STAFF_F06 => 134i32,
            Self::eAVV_FOX_STAFF_FCH01 => 135i32,
            Self::eAVV_FOX_STAFF_M07 => 136i32,
            Self::eAVV_FOX_STAFF_M08 => 137i32,
            Self::eAVV_FOX_STAFF_M09 => 138i32,
            Self::eAVV_FOX_TECH_F05 => 139i32,
            Self::eAVV_FOX_TECH_F06 => 140i32,
            Self::eAVV_FOX_TECH_F08 => 141i32,
            Self::eAVV_FOX_TECH_FCH01 => 142i32,
            Self::eAVV_FOX_TECH_M06 => 143i32,
            Self::eAVV_FOX_TECH_M07 => 144i32,
            Self::eAVV_FOX_TECH_M08 => 145i32,
            Self::eAVV_FOX_TECH_M11 => 146i32,
            Self::eAVV_FOX_THUG_M04 => 147i32,
            Self::eAVV_FOX_THUG_M05 => 148i32,
            Self::eAVV_FOX_THUG_M06 => 149i32,
            Self::eAVV_FOX_THUG_M07 => 150i32,
            Self::eAVV_FRANCO => 151i32,
            Self::eAVV_GARDENER01 => 152i32,
            Self::eAVV_GARDENER02 => 153i32,
            Self::eAVV_GARDENER03 => 154i32,
            Self::eAVV_GARDENERFEM01 => 155i32,
            Self::eAVV_GARDENERFEM02 => 156i32,
            Self::eAVV_GARDENERFEM03 => 157i32,
            Self::eAVV_GECKO_ARTTECH_F05 => 158i32,
            Self::eAVV_GECKO_ARTTECH_F06 => 159i32,
            Self::eAVV_GECKO_ARTTECH_F08 => 160i32,
            Self::eAVV_GECKO_ARTTECH_F10 => 161i32,
            Self::eAVV_GECKO_ARTTECH_M05 => 162i32,
            Self::eAVV_GECKO_ARTTECH_M06 => 163i32,
            Self::eAVV_GECKO_ARTTECH_M08 => 164i32,
            Self::eAVV_GECKO_ARTTECH_M09 => 165i32,
            Self::eAVV_GECKO_ATTENDANT_M09 => 166i32,
            Self::eAVV_GECKO_ATTENDANT_MHI03 => 167i32,
            Self::eAVV_GECKO_MAINTENANCE_FCH01 => 168i32,
            Self::eAVV_GECKO_MAINTENANCE_M05 => 169i32,
            Self::eAVV_GECKO_WAITER_F05 => 170i32,
            Self::eAVV_GECKO_WAITER_F06 => 171i32,
            Self::eAVV_GECKO_WAITER_F09 => 172i32,
            Self::eAVV_GECKO_WAITER_F10 => 173i32,
            Self::eAVV_GECKO_WAITER_FHI02 => 174i32,
            Self::eAVV_GECKO_WAITER_M07 => 175i32,
            Self::eAVV_GECKO_WAITER_M08 => 176i32,
            Self::eAVV_GECKO_WAITER_M09 => 177i32,
            Self::eAVV_GECKO_WAITER_M11 => 178i32,
            Self::eAVV_GECKO_WAITER_MHI03 => 179i32,
            Self::eAVV_GRAVES => 180i32,
            Self::eAVV_GUARDIA02 => 181i32,
            Self::eAVV_GUARDIA03 => 182i32,
            Self::eAVV_HOUSSTFF01 => 183i32,
            Self::eAVV_HOUSSTFF02 => 184i32,
            Self::eAVV_HOUSSTFF03 => 185i32,
            Self::eAVV_HOUSSTFF06 => 186i32,
            Self::eAVV_HOUSSTFFEM01 => 187i32,
            Self::eAVV_HOUSSTFFEM02 => 188i32,
            Self::eAVV_HOUSSTFFEM03 => 189i32,
            Self::eAVV_HUSH => 190i32,
            Self::eAVV_ICAAGENT_M05 => 191i32,
            Self::eAVV_INGRAM => 192i32,
            Self::eAVV_INTERN => 193i32,
            Self::eAVV_JANUS => 194i32,
            Self::eAVV_JOB_ACTORFEMHI02 => 195i32,
            Self::eAVV_JOB_ACTORHI01 => 196i32,
            Self::eAVV_JOB_ARCHTCTF05 => 197i32,
            Self::eAVV_JOB_ARCHTCTF07 => 198i32,
            Self::eAVV_JOB_ARCHTCTF08 => 199i32,
            Self::eAVV_JOB_ARCHTCTF09 => 200i32,
            Self::eAVV_JOB_ARCHTCTM06 => 201i32,
            Self::eAVV_JOB_ARCHTCTM07 => 202i32,
            Self::eAVV_JOB_ARCHTCTM08 => 203i32,
            Self::eAVV_JOB_ARCHTCTM09 => 204i32,
            Self::eAVV_JOB_ARCHTCTM10 => 205i32,
            Self::eAVV_JOB_ARKELITE04 => 206i32,
            Self::eAVV_JOB_ARKELITE05 => 207i32,
            Self::eAVV_JOB_ARKELITE06 => 208i32,
            Self::eAVV_JOB_ARKELITE07 => 209i32,
            Self::eAVV_JOB_ARKIANF05 => 210i32,
            Self::eAVV_JOB_ARKIANF06 => 211i32,
            Self::eAVV_JOB_ARKIANF07 => 212i32,
            Self::eAVV_JOB_ARKIANF08 => 213i32,
            Self::eAVV_JOB_ARKIANF09 => 214i32,
            Self::eAVV_JOB_ARKIANM06 => 215i32,
            Self::eAVV_JOB_ARKIANM07 => 216i32,
            Self::eAVV_JOB_ARKIANM08 => 217i32,
            Self::eAVV_JOB_ARKIANM09 => 218i32,
            Self::eAVV_JOB_ARKIANM10 => 219i32,
            Self::eAVV_JOB_ARKPTRNF05 => 220i32,
            Self::eAVV_JOB_ARKPTRNF06 => 221i32,
            Self::eAVV_JOB_ARKPTRNF07 => 222i32,
            Self::eAVV_JOB_ARKPTRNF08 => 223i32,
            Self::eAVV_JOB_ARKPTRNF09 => 224i32,
            Self::eAVV_JOB_ARKPTRNM06 => 225i32,
            Self::eAVV_JOB_ARKPTRNM07 => 226i32,
            Self::eAVV_JOB_ARKPTRNM08 => 227i32,
            Self::eAVV_JOB_ARKPTRNM09 => 228i32,
            Self::eAVV_JOB_ARKPTRNM10 => 229i32,
            Self::eAVV_JOB_ARKSTAFFF05 => 230i32,
            Self::eAVV_JOB_ARKSTAFFF06 => 231i32,
            Self::eAVV_JOB_ARKSTAFFM06 => 232i32,
            Self::eAVV_JOB_ARKSTAFFM07 => 233i32,
            Self::eAVV_JOB_ARKSTAFFM08 => 234i32,
            Self::eAVV_JOB_BANKERF05 => 235i32,
            Self::eAVV_JOB_BANKERF06 => 236i32,
            Self::eAVV_JOB_BANKERF08 => 237i32,
            Self::eAVV_JOB_BANKERM06 => 238i32,
            Self::eAVV_JOB_BANKERM07 => 239i32,
            Self::eAVV_JOB_BANKERM08 => 240i32,
            Self::eAVV_JOB_BANKERM09 => 241i32,
            Self::eAVV_JOB_BANKGRD05 => 242i32,
            Self::eAVV_JOB_BANKGRD06 => 243i32,
            Self::eAVV_JOB_BANKGRD07 => 244i32,
            Self::eAVV_JOB_BANKGRDCHF => 245i32,
            Self::eAVV_JOB_BANKIT07 => 246i32,
            Self::eAVV_JOB_BANKMTNC08 => 247i32,
            Self::eAVV_JOB_BBQGRD04 => 248i32,
            Self::eAVV_JOB_BBQGRD05 => 249i32,
            Self::eAVV_JOB_BBQGRD06 => 250i32,
            Self::eAVV_JOB_BBQGRD07 => 251i32,
            Self::eAVV_JOB_BOLLYCREWHI01 => 252i32,
            Self::eAVV_JOB_BOLLYCREWHI02 => 253i32,
            Self::eAVV_JOB_BOLLYCREWHI03 => 254i32,
            Self::eAVV_JOB_CASSIDYGRD04 => 255i32,
            Self::eAVV_JOB_CASSIDYGRD05 => 256i32,
            Self::eAVV_JOB_CASSIDYGRD06 => 257i32,
            Self::eAVV_JOB_CASSIDYGRD07 => 258i32,
            Self::eAVV_JOB_CASTLESTFEM05 => 259i32,
            Self::eAVV_JOB_CASTLESTFEM07 => 260i32,
            Self::eAVV_JOB_CASTLESTFF07 => 261i32,
            Self::eAVV_JOB_CASTLESTFF10 => 262i32,
            Self::eAVV_JOB_CAVEGDES01 => 263i32,
            Self::eAVV_JOB_CAVEGDES02 => 264i32,
            Self::eAVV_JOB_CAVEWKR07 => 265i32,
            Self::eAVV_JOB_CAVEWKR08 => 266i32,
            Self::eAVV_JOB_CAVEWKRES01 => 267i32,
            Self::eAVV_JOB_CAVEWKRES02 => 268i32,
            Self::eAVV_JOB_CAVEWKRES03 => 269i32,
            Self::eAVV_JOB_CHEFES01 => 270i32,
            Self::eAVV_JOB_CHEFES02 => 271i32,
            Self::eAVV_JOB_CHEFES03 => 272i32,
            Self::eAVV_JOB_CHEFF07 => 273i32,
            Self::eAVV_JOB_CHEFM06 => 274i32,
            Self::eAVV_JOB_CHEFM07 => 275i32,
            Self::eAVV_JOB_CHEFM09 => 276i32,
            Self::eAVV_JOB_CIVGRD04 => 277i32,
            Self::eAVV_JOB_CIVGRD05 => 278i32,
            Self::eAVV_JOB_CIVGRD06 => 279i32,
            Self::eAVV_JOB_CIVGRD07 => 280i32,
            Self::eAVV_JOB_CLOTHSALHI01 => 281i32,
            Self::eAVV_JOB_CLOTHSALHI02 => 282i32,
            Self::eAVV_JOB_CNSTR08 => 283i32,
            Self::eAVV_JOB_CNSTR09 => 284i32,
            Self::eAVV_JOB_CNSTRES01 => 285i32,
            Self::eAVV_JOB_CNSTRGRD04 => 286i32,
            Self::eAVV_JOB_CNSTRGRD05 => 287i32,
            Self::eAVV_JOB_CNSTRGRD06 => 288i32,
            Self::eAVV_JOB_CNSTRGRD07 => 289i32,
            Self::eAVV_JOB_COCAGRD06 => 290i32,
            Self::eAVV_JOB_COCAGRDES02 => 291i32,
            Self::eAVV_JOB_COP04 => 292i32,
            Self::eAVV_JOB_COP05 => 293i32,
            Self::eAVV_JOB_COP06 => 294i32,
            Self::eAVV_JOB_COP07 => 295i32,
            Self::eAVV_JOB_COUNSLRF08 => 296i32,
            Self::eAVV_JOB_COUNSLRF09 => 297i32,
            Self::eAVV_JOB_COUNSLRM07 => 298i32,
            Self::eAVV_JOB_COUNSLRM09 => 299i32,
            Self::eAVV_JOB_CUSTDNF05 => 300i32,
            Self::eAVV_JOB_CUSTDNF06 => 301i32,
            Self::eAVV_JOB_CUSTDNF07 => 302i32,
            Self::eAVV_JOB_CUSTDNF08 => 303i32,
            Self::eAVV_JOB_CUSTDNF09 => 304i32,
            Self::eAVV_JOB_CUSTDNM06 => 305i32,
            Self::eAVV_JOB_CUSTDNM07 => 306i32,
            Self::eAVV_JOB_CUSTDNM08 => 307i32,
            Self::eAVV_JOB_CUSTDNM09 => 308i32,
            Self::eAVV_JOB_CUSTDNM10 => 309i32,
            Self::eAVV_JOB_DRUGLABWKRES02 => 310i32,
            Self::eAVV_JOB_DRUGLABWKRES03 => 311i32,
            Self::eAVV_JOB_FARMF05 => 312i32,
            Self::eAVV_JOB_FARMFES01 => 313i32,
            Self::eAVV_JOB_FARMFES02 => 314i32,
            Self::eAVV_JOB_FARMM06 => 315i32,
            Self::eAVV_JOB_FARMM08 => 316i32,
            Self::eAVV_JOB_FARMMES01 => 317i32,
            Self::eAVV_JOB_FARMMES02 => 318i32,
            Self::eAVV_JOB_FARMMES03 => 319i32,
            Self::eAVV_JOB_GARBAGE08 => 320i32,
            Self::eAVV_JOB_GARBAGE09 => 321i32,
            Self::eAVV_JOB_GARBAGEES01 => 322i32,
            Self::eAVV_JOB_GARBAGRD04 => 323i32,
            Self::eAVV_JOB_GARBAGRD05 => 324i32,
            Self::eAVV_JOB_GARBAGRD06 => 325i32,
            Self::eAVV_JOB_GARBAGRD07 => 326i32,
            Self::eAVV_JOB_GRDNR08 => 327i32,
            Self::eAVV_JOB_GRDNR09 => 328i32,
            Self::eAVV_JOB_GRDNRES01 => 329i32,
            Self::eAVV_JOB_GRDNRGRD04 => 330i32,
            Self::eAVV_JOB_GRDNRGRD05 => 331i32,
            Self::eAVV_JOB_GRDNRGRD06 => 332i32,
            Self::eAVV_JOB_GRDNRGRD07 => 333i32,
            Self::eAVV_JOB_GUARD04 => 334i32,
            Self::eAVV_JOB_GUARD05 => 335i32,
            Self::eAVV_JOB_GUARD06 => 336i32,
            Self::eAVV_JOB_GUARD07 => 337i32,
            Self::eAVV_JOB_HSSTFFES02 => 338i32,
            Self::eAVV_JOB_HSSTFFES03 => 339i32,
            Self::eAVV_JOB_HSSTFMES02 => 340i32,
            Self::eAVV_JOB_HSSTFMES03 => 341i32,
            Self::eAVV_JOB_JANUSGRD04 => 342i32,
            Self::eAVV_JOB_JANUSGRD05 => 343i32,
            Self::eAVV_JOB_JANUSGRD06 => 344i32,
            Self::eAVV_JOB_JANUSGRD07 => 345i32,
            Self::eAVV_JOB_LNDRYGRDHI01 => 346i32,
            Self::eAVV_JOB_LNDRYGRDHI02 => 347i32,
            Self::eAVV_JOB_LNDRYGRDHI03 => 348i32,
            Self::eAVV_JOB_LNDRYWKRHI01 => 349i32,
            Self::eAVV_JOB_LNDRYWKRHI02 => 350i32,
            Self::eAVV_JOB_LNDRYWKRHI03 => 351i32,
            Self::eAVV_JOB_MANSIONGD05 => 352i32,
            Self::eAVV_JOB_MANSIONGD06 => 353i32,
            Self::eAVV_JOB_MANSIONGD07 => 354i32,
            Self::eAVV_JOB_MANSIONGDES02 => 355i32,
            Self::eAVV_JOB_MEDICFEM06 => 356i32,
            Self::eAVV_JOB_MTLWKRHI01 => 357i32,
            Self::eAVV_JOB_MTLWKRHI02 => 358i32,
            Self::eAVV_JOB_MTLWKRHI03 => 359i32,
            Self::eAVV_JOB_MUMBSECHI02 => 360i32,
            Self::eAVV_JOB_MUMBSECHI03 => 361i32,
            Self::eAVV_JOB_MUMBSRVHI01 => 362i32,
            Self::eAVV_JOB_MUMBSRVHI02 => 363i32,
            Self::eAVV_JOB_MUMBSRVHI03 => 364i32,
            Self::eAVV_JOB_MUSICIANF05 => 365i32,
            Self::eAVV_JOB_MUSICIANM06 => 366i32,
            Self::eAVV_JOB_MUSICIANM07 => 367i32,
            Self::eAVV_JOB_MUSICIANM08 => 368i32,
            Self::eAVV_JOB_MUSICIANM09 => 369i32,
            Self::eAVV_JOB_MUSICIANM10 => 370i32,
            Self::eAVV_JOB_NITIATEF05 => 371i32,
            Self::eAVV_JOB_NITIATEM06 => 372i32,
            Self::eAVV_JOB_NITIATEM07 => 373i32,
            Self::eAVV_JOB_QUEENGRDHI01 => 374i32,
            Self::eAVV_JOB_QUEENGRDHI02 => 375i32,
            Self::eAVV_JOB_QUEENGRDHI03 => 376i32,
            Self::eAVV_JOB_QUEENSTGHI03 => 377i32,
            Self::eAVV_JOB_QUEENTGHI02 => 378i32,
            Self::eAVV_JOB_RAIDER04 => 379i32,
            Self::eAVV_JOB_RAIDER05 => 380i32,
            Self::eAVV_JOB_RAIDER06 => 381i32,
            Self::eAVV_JOB_RAIDER07 => 382i32,
            Self::eAVV_JOB_RANGANGRD05 => 383i32,
            Self::eAVV_JOB_RANGANGRD06 => 384i32,
            Self::eAVV_JOB_RANGANSECHI01 => 385i32,
            Self::eAVV_JOB_RANGANSECHI02 => 386i32,
            Self::eAVV_JOB_RANGANSECHI03 => 387i32,
            Self::eAVV_JOB_SERVANT08 => 388i32,
            Self::eAVV_JOB_SERVANT09 => 389i32,
            Self::eAVV_JOB_SERVANTES02 => 390i32,
            Self::eAVV_JOB_SERVANTFEM07 => 391i32,
            Self::eAVV_JOB_SITEWKR06 => 392i32,
            Self::eAVV_JOB_SITEWKR07 => 393i32,
            Self::eAVV_JOB_SITEWKR08 => 394i32,
            Self::eAVV_JOB_SITEWKR09 => 395i32,
            Self::eAVV_JOB_SITEWKRES01 => 396i32,
            Self::eAVV_JOB_SITEWKRES02 => 397i32,
            Self::eAVV_JOB_SITEWKRES03 => 398i32,
            Self::eAVV_JOB_STINGLIFEGRDM06 => 399i32,
            Self::eAVV_JOB_STINGSEC05 => 400i32,
            Self::eAVV_JOB_STINGSEC06 => 401i32,
            Self::eAVV_JOB_STINGSMASSF09 => 402i32,
            Self::eAVV_JOB_STINGSTAFFF08 => 403i32,
            Self::eAVV_JOB_STINGSTAFFM06 => 404i32,
            Self::eAVV_JOB_STINGSTAFFM08 => 405i32,
            Self::eAVV_JOB_STINGTECHF08 => 406i32,
            Self::eAVV_JOB_STINGTECHM07 => 407i32,
            Self::eAVV_JOB_STINGTECHM09 => 408i32,
            Self::eAVV_JOB_STINGTRAINERF06 => 409i32,
            Self::eAVV_JOB_STINGVILLAGRD05 => 410i32,
            Self::eAVV_JOB_STINGVILLAGRD06 => 411i32,
            Self::eAVV_JOB_STINGWTRF05 => 412i32,
            Self::eAVV_JOB_STINGWTRM07 => 413i32,
            Self::eAVV_JOB_STINGWTRM08 => 414i32,
            Self::eAVV_JOB_SUBWKR06 => 415i32,
            Self::eAVV_JOB_SUBWKR07 => 416i32,
            Self::eAVV_JOB_TEASERVHI02 => 417i32,
            Self::eAVV_JOB_THUGHI01 => 418i32,
            Self::eAVV_JOB_THUGHI02 => 419i32,
            Self::eAVV_JOB_THUGHI03 => 420i32,
            Self::eAVV_JOB_TRAINSERVHI01 => 421i32,
            Self::eAVV_JOB_VILLAGEGDES01 => 422i32,
            Self::eAVV_JOB_VILLAGEGDES03 => 423i32,
            Self::eAVV_KNOX_R => 424i32,
            Self::eAVV_KNOX_S => 425i32,
            Self::eAVV_KONG => 426i32,
            Self::eAVV_LJUDMILAVETROVA => 427i32,
            Self::eAVV_LLAMA_WAITER_F05 => 428i32,
            Self::eAVV_LLAMA_WAITER_F06 => 429i32,
            Self::eAVV_LLAMA_WAITER_F10 => 430i32,
            Self::eAVV_LLAMA_WAITER_M06 => 431i32,
            Self::eAVV_LLAMA_WAITER_M07 => 432i32,
            Self::eAVV_LLAMA_WAITER_M11 => 433i32,
            Self::eAVV_LLAMA_WORKER_FES01 => 434i32,
            Self::eAVV_LLAMA_WORKER_FES02 => 435i32,
            Self::eAVV_LLAMA_WORKER_FES03 => 436i32,
            Self::eAVV_LLAMA_WORKER_MES01 => 437i32,
            Self::eAVV_LLAMA_WORKER_MES02 => 438i32,
            Self::eAVV_LLAMA_WORKER_MES03 => 439i32,
            Self::eAVV_MAELSTROM => 440i32,
            Self::eAVV_MAMBACREW01 => 441i32,
            Self::eAVV_MAMBACREW02 => 442i32,
            Self::eAVV_MAMBACREW03 => 443i32,
            Self::eAVV_MAMBACREW04 => 444i32,
            Self::eAVV_MARTINEZ => 445i32,
            Self::eAVV_MECH01 => 446i32,
            Self::eAVV_MECH02 => 447i32,
            Self::eAVV_MECH03 => 448i32,
            Self::eAVV_MENDOLA => 449i32,
            Self::eAVV_MODEL01 => 450i32,
            Self::eAVV_MODEL02 => 451i32,
            Self::eAVV_MODEL03 => 452i32,
            Self::eAVV_MODELFEM01 => 453i32,
            Self::eAVV_MODELFEM02 => 454i32,
            Self::eAVV_MODELFEM03 => 455i32,
            Self::eAVV_MORGAN => 456i32,
            Self::eAVV_NORFOLK => 457i32,
            Self::eAVV_NOVIKOV => 458i32,
            Self::eAVV_ORSON => 459i32,
            Self::eAVV_PARVATI => 460i32,
            Self::eAVV_RAT_DUMPLINGCOOK_F05 => 461i32,
            Self::eAVV_RAT_DUMPLINGCOOK_F06 => 462i32,
            Self::eAVV_RAT_DUMPLINGCOOK_FCH02 => 463i32,
            Self::eAVV_RAT_DUMPLINGCOOK_M06 => 464i32,
            Self::eAVV_RAT_DUMPLINGCOOK_M07 => 465i32,
            Self::eAVV_RAT_DUMPLINGCOOK_M08 => 466i32,
            Self::eAVV_RAT_DUMPLINGCOOK_M09 => 467i32,
            Self::eAVV_RAT_DUMPLINGCOOK_MCH01 => 468i32,
            Self::eAVV_RAT_DUMPLINGCOOK_MCH02 => 469i32,
            Self::eAVV_RAT_FACILITYSTAFF_F06 => 470i32,
            Self::eAVV_RAT_FACILITYSTAFF_F09 => 471i32,
            Self::eAVV_RAT_FACILITYSTAFF_FCH01 => 472i32,
            Self::eAVV_RAT_FACILITYSTAFF_FCH02 => 473i32,
            Self::eAVV_RAT_FACILITYSTAFF_M06 => 474i32,
            Self::eAVV_RAT_FACILITYSTAFF_M07 => 475i32,
            Self::eAVV_RAT_FACILITYSTAFF_M08 => 476i32,
            Self::eAVV_RAT_FACILITYSTAFF_M09 => 477i32,
            Self::eAVV_RAT_FACILITYSTAFF_M11 => 478i32,
            Self::eAVV_PRIEST01 => 479i32,
            Self::eAVV_RANGAN => 480i32,
            Self::eAVV_REYNARD => 481i32,
            Self::eAVV_RITTER => 482i32,
            Self::eAVV_ROBERT_KNOX => 483i32,
            Self::eAVV_ROSE => 484i32,
            Self::eAVV_ROYCE => 485i32,
            Self::eAVV_SANTA => 486i32,
            Self::eAVV_SCIENTIST01 => 487i32,
            Self::eAVV_SCIENTIST02 => 488i32,
            Self::eAVV_SCIENTIST03 => 489i32,
            Self::eAVV_SCIENTIST04 => 490i32,
            Self::eAVV_SCIENTISTFEM01 => 491i32,
            Self::eAVV_SCIENTISTFEM02 => 492i32,
            Self::eAVV_SCIENTISTFEM03 => 493i32,
            Self::eAVV_SCIENTISTFEM04 => 494i32,
            Self::eAVV_SHAH => 495i32,
            Self::eAVV_SHEEPGRD04 => 496i32,
            Self::eAVV_SHEEPGRD05 => 497i32,
            Self::eAVV_SHEEPGRD06 => 498i32,
            Self::eAVV_SHEEPGRD07 => 499i32,
            Self::eAVV_SIERRA_KNOX => 500i32,
            Self::eAVV_SOFTGRD01 => 501i32,
            Self::eAVV_SOFTGRD02 => 502i32,
            Self::eAVV_SOFTGRD03 => 503i32,
            Self::eAVV_SOLDIER01 => 504i32,
            Self::eAVV_SOLDIER02 => 505i32,
            Self::eAVV_SOLDIER03 => 506i32,
            Self::eAVV_SOLDIERBOSS01 => 507i32,
            Self::eAVV_SOLDIERBOSS02 => 508i32,
            Self::eAVV_SOLDIERBOSS03 => 509i32,
            Self::eAVV_SPECOPS01 => 510i32,
            Self::eAVV_SPECOPS02 => 511i32,
            Self::eAVV_SPECOPS03 => 512i32,
            Self::eAVV_STAFFEM03 => 513i32,
            Self::eAVV_STAFFEM04 => 514i32,
            Self::eAVV_STAFFEM05 => 515i32,
            Self::eAVV_STAFFMALE01 => 516i32,
            Self::eAVV_STAFFMALE02 => 517i32,
            Self::eAVV_STAFFMALE03 => 518i32,
            Self::eAVV_STAFFMALE04 => 519i32,
            Self::eAVV_STAFFMALE05 => 520i32,
            Self::eAVV_STAFFMALE06 => 521i32,
            Self::eAVV_STEVENBRADLEY => 522i32,
            Self::eAVV_STRANDBERG => 523i32,
            Self::eAVV_STUYVESANT => 524i32,
            Self::eAVV_STYLIST01 => 525i32,
            Self::eAVV_STYLIST02 => 526i32,
            Self::eAVV_STYLIST03 => 527i32,
            Self::eAVV_STYLIST04 => 528i32,
            Self::eAVV_STYLISTFEM01 => 529i32,
            Self::eAVV_STYLISTFEM02 => 530i32,
            Self::eAVV_STYLISTFEM03 => 531i32,
            Self::eAVV_STYLISTFEM04 => 532i32,
            Self::eAVV_THUGES01 => 533i32,
            Self::eAVV_THUGES02 => 534i32,
            Self::eAVV_THUGES03 => 535i32,
            Self::eAVV_THUGHI01 => 536i32,
            Self::eAVV_THUGHI02 => 537i32,
            Self::eAVV_THUGHI03 => 538i32,
            Self::eAVV_TYSONWILLIAMS => 539i32,
            Self::eAVV_VIDAL => 540i32,
            Self::eAVV_WAITER01 => 541i32,
            Self::eAVV_WAITER02 => 542i32,
            Self::eAVV_WAITER03 => 543i32,
            Self::eAVV_WAITER04 => 544i32,
            Self::eAVV_WAITERFEM01 => 545i32,
            Self::eAVV_WAITERFEM02 => 546i32,
            Self::eAVV_WAITERFEM03 => 547i32,
            Self::eAVV_WAITERFEM04 => 548i32,
            Self::eAVV_WASHINGTON => 549i32,
            Self::eAVV_WS_BOULTON => 550i32,
            Self::eAVV_WS_NEWMAN => 551i32,
            Self::eAVV_WS_WATSON => 552i32,
            Self::eAVV_YACHTCREW01 => 553i32,
            Self::eAVV_YACHTCREW02 => 554i32,
            Self::eAVV_YACHTCREW03 => 555i32,
            Self::eAVV_YACHTCREW04 => 556i32,
            Self::eAVV_YAMASAKI => 557i32,
            Self::eAVV_YATES => 558i32,
            Self::eAVV_ZAYDAN => 559i32,
            Self::eAVV_DUGONG_COOKJOB_FHI02 => 560i32,
            Self::eAVV_DUGONG_COOKJOB_FHI03 => 561i32,
            Self::eAVV_DUGONG_COOKJOB_MCH02 => 562i32,
            Self::eAVV_DUGONG_COOKJOB_MHI02 => 563i32,
            Self::eAVV_DUGONG_COOKJOB_MHI03 => 564i32,
            Self::eAVV_DUGONG_ENGINEER_MCH02 => 565i32,
            Self::eAVV_DUGONG_ENGINEER_MHI02 => 566i32,
            Self::eAVV_DUGONG_ENGINEER_MHI03 => 567i32,
            Self::eAVV_DUGONG_FARAH_FI03 => 568i32,
            Self::eAVV_DUGONG_METALWKR_MHI02 => 569i32,
            Self::eAVV_DUGONG_METALWKR_MHI03 => 570i32,
            Self::eAVV_DUGONG_MILITIA_M05 => 571i32,
            Self::eAVV_DUGONG_MILITIA_M06 => 572i32,
            Self::eAVV_DUGONG_MILITIA_M07 => 573i32,
            Self::eAVV_DUGONG_MILITIA_SP01 => 574i32,
            Self::eAVV_DUGONG_PIRATE_MHI02 => 575i32,
            Self::eAVV_DUGONG_PIRATE_MHI03 => 576i32,
            Self::eAVV_CREST => 577i32,
            Self::eAVV_AKKA => 578i32,
            Self::eAVV_ET_DROP => 579i32,
            Self::eAVV_ET_PEN => 580i32,
            Self::eAVV_ET_LAMBC => 581i32,
            Self::eAVV_ET_LAMBIC => 582i32,
            Self::eAVV_ET_LAMBIC_CLONE => 583i32,
            Self::eAVV_ET_LAMPICCLONE => 584i32,
            Self::eAVV_ET_FRENTINI => 585i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EActorVoiceVariation {
     const TYPE_ID: &str = "EActorVoiceVariation";
}

impl StaticVariant for Vec<EActorVoiceVariation> {
     const TYPE_ID: &str = "TArray<EActorVoiceVariation>";
}

impl StaticVariant for Vec<Vec<EActorVoiceVariation>> {
     const TYPE_ID: &str = "TArray<TArray<EActorVoiceVariation>>";
}

impl Variant for EActorVoiceVariation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EActorVoiceVariation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EActorVoiceVariation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EActorVoiceVariation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EActorVoiceVariation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EActorVoiceVariation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAgilityState {
    eAgState_JumpToHangFromLocomotion,
    eAgState_ClimbOnToLedgeFromLocomotion,
    eAgState_ClimbToHangFromLocomotion,
    eAgState_WalkOnFromLocomotion,
    eAgState_WalkOffToLocomoton,
    eAgState_PullUpToLedgeWalk,
    eAgState_PullUpToLocomotion,
    eAgState_LedgeJumpOffToLocomotion,
    eAgState_VaultOverLedgeFromCover,
    eAgState_ClimbOnToLedgeFromCover,
    eAgState_LedgeHangDefault,
    eAgState_LedgeWalkDefault,
    eAgState_TransLedgeHangDownToWalk,
    eAgState_TransLedgeHangUpToWalk,
    eAgState_TransLedgeWalkDownToHang,
    eAgState_TransLedgeWalkUpToHang,
    eAgState_TransLedgeHangUpToRail,
    eAgState_TransLedgeHangToLocomotion,
    eAgState_TransLedgeWalkToLocomotion,
    eAgState_LedgeHangJumpLeft,
    eAgState_LedgeHangJumpRight,
    eAgState_LedgeWalkJumpLeft,
    eAgState_LedgeWalkJumpRight,
    eAgState_SneakPastWindowLeftToRight,
    eAgState_SneakPastWindowRightToLeft,
    eAgState_ClimbWindowFromLedgeToLocomotion,
    eAgState_ClimbWindowFromLocomotionToLedge,
    eAgState_ClimbWindowFromLocomotionToLocomotion,
    eAgState_ClimbWindowFromCoverToLocomotion,
    eAgState_ClimbWindowFromCoverToLedge,
    eAgState_ClimbOnToLedgeFromDrainPipe,
    eAgState_ClimbToHangFromDrainPipe,
    eAgState_ClimbToWalkFromDrainPipeLeft,
    eAgState_ClimbToWalkFromDrainPipeRight,
    eAgState_Deactivate,
    eAgState_Unknown,
}

impl Aligned for EAgilityState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAgilityState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAgState_JumpToHangFromLocomotion => 0i32,
            Self::eAgState_ClimbOnToLedgeFromLocomotion => 1i32,
            Self::eAgState_ClimbToHangFromLocomotion => 2i32,
            Self::eAgState_WalkOnFromLocomotion => 3i32,
            Self::eAgState_WalkOffToLocomoton => 4i32,
            Self::eAgState_PullUpToLedgeWalk => 5i32,
            Self::eAgState_PullUpToLocomotion => 6i32,
            Self::eAgState_LedgeJumpOffToLocomotion => 7i32,
            Self::eAgState_VaultOverLedgeFromCover => 8i32,
            Self::eAgState_ClimbOnToLedgeFromCover => 9i32,
            Self::eAgState_LedgeHangDefault => 10i32,
            Self::eAgState_LedgeWalkDefault => 11i32,
            Self::eAgState_TransLedgeHangDownToWalk => 12i32,
            Self::eAgState_TransLedgeHangUpToWalk => 13i32,
            Self::eAgState_TransLedgeWalkDownToHang => 14i32,
            Self::eAgState_TransLedgeWalkUpToHang => 15i32,
            Self::eAgState_TransLedgeHangUpToRail => 16i32,
            Self::eAgState_TransLedgeHangToLocomotion => 17i32,
            Self::eAgState_TransLedgeWalkToLocomotion => 18i32,
            Self::eAgState_LedgeHangJumpLeft => 19i32,
            Self::eAgState_LedgeHangJumpRight => 20i32,
            Self::eAgState_LedgeWalkJumpLeft => 21i32,
            Self::eAgState_LedgeWalkJumpRight => 22i32,
            Self::eAgState_SneakPastWindowLeftToRight => 23i32,
            Self::eAgState_SneakPastWindowRightToLeft => 24i32,
            Self::eAgState_ClimbWindowFromLedgeToLocomotion => 25i32,
            Self::eAgState_ClimbWindowFromLocomotionToLedge => 26i32,
            Self::eAgState_ClimbWindowFromLocomotionToLocomotion => 27i32,
            Self::eAgState_ClimbWindowFromCoverToLocomotion => 28i32,
            Self::eAgState_ClimbWindowFromCoverToLedge => 29i32,
            Self::eAgState_ClimbOnToLedgeFromDrainPipe => 30i32,
            Self::eAgState_ClimbToHangFromDrainPipe => 31i32,
            Self::eAgState_ClimbToWalkFromDrainPipeLeft => 32i32,
            Self::eAgState_ClimbToWalkFromDrainPipeRight => 33i32,
            Self::eAgState_Deactivate => 34i32,
            Self::eAgState_Unknown => 35i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAgilityState {
     const TYPE_ID: &str = "EAgilityState";
}

impl StaticVariant for Vec<EAgilityState> {
     const TYPE_ID: &str = "TArray<EAgilityState>";
}

impl StaticVariant for Vec<Vec<EAgilityState>> {
     const TYPE_ID: &str = "TArray<TArray<EAgilityState>>";
}

impl Variant for EAgilityState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAgilityState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAgilityState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAgilityState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAgilityState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAgilityState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAimAssistActivationState {
    eAAAS_Activated,
    eAAAS_Activating,
    eAAAS_Deactivated,
    eAAAS_Deactivating,
}

impl Aligned for EAimAssistActivationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAimAssistActivationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAAAS_Activated => 0i32,
            Self::eAAAS_Activating => 1i32,
            Self::eAAAS_Deactivated => 2i32,
            Self::eAAAS_Deactivating => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAimAssistActivationState {
     const TYPE_ID: &str = "EAimAssistActivationState";
}

impl StaticVariant for Vec<EAimAssistActivationState> {
     const TYPE_ID: &str = "TArray<EAimAssistActivationState>";
}

impl StaticVariant for Vec<Vec<EAimAssistActivationState>> {
     const TYPE_ID: &str = "TArray<TArray<EAimAssistActivationState>>";
}

impl Variant for EAimAssistActivationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAimAssistActivationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAimAssistActivationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAimAssistActivationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAimAssistActivationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAimAssistActivationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAmmoBehaviourConfigType {
    eAB_None,
    eAB_Explosive,
    eAB_Penetration,
}

impl Aligned for EAmmoBehaviourConfigType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAmmoBehaviourConfigType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAB_None => 0i32,
            Self::eAB_Explosive => 1i32,
            Self::eAB_Penetration => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAmmoBehaviourConfigType {
     const TYPE_ID: &str = "EAmmoBehaviourConfigType";
}

impl StaticVariant for Vec<EAmmoBehaviourConfigType> {
     const TYPE_ID: &str = "TArray<EAmmoBehaviourConfigType>";
}

impl StaticVariant for Vec<Vec<EAmmoBehaviourConfigType>> {
     const TYPE_ID: &str = "TArray<TArray<EAmmoBehaviourConfigType>>";
}

impl Variant for EAmmoBehaviourConfigType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAmmoBehaviourConfigType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAmmoBehaviourConfigType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAmmoBehaviourConfigType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAmmoBehaviourConfigType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAmmoBehaviourConfigType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAnimBlendMode {
    EAnimBlendMode_InterpAttInterpPos,
    EAnimBlendMode_InterpAttAddPos,
    EAnimBlendMode_AddAttLeavePos,
    EAnimBlendMode_AddAttAddPos,
}

impl Aligned for EAnimBlendMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAnimBlendMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EAnimBlendMode_InterpAttInterpPos => 0i32,
            Self::EAnimBlendMode_InterpAttAddPos => 1i32,
            Self::EAnimBlendMode_AddAttLeavePos => 2i32,
            Self::EAnimBlendMode_AddAttAddPos => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAnimBlendMode {
     const TYPE_ID: &str = "EAnimBlendMode";
}

impl StaticVariant for Vec<EAnimBlendMode> {
     const TYPE_ID: &str = "TArray<EAnimBlendMode>";
}

impl StaticVariant for Vec<Vec<EAnimBlendMode>> {
     const TYPE_ID: &str = "TArray<TArray<EAnimBlendMode>>";
}

impl Variant for EAnimBlendMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAnimBlendMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAnimBlendMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAnimBlendMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAnimBlendMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAnimBlendMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAnimSetState {
    EASES_DEFAULT,
    EASES_AMBIENT_ARMED,
    EASES_AMBIENT_VIP_ESCORT,
    EASES_AMBIENT_HERO_ESCORT,
    EASES_COMBAT_EVACUATE,
    EASES_COMBAT_EVACUATE_VIP_SOLO,
    EASES_SICK,
    EASES_INFECTED,
}

impl Aligned for EAnimSetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAnimSetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EASES_DEFAULT => 0i32,
            Self::EASES_AMBIENT_ARMED => 1i32,
            Self::EASES_AMBIENT_VIP_ESCORT => 2i32,
            Self::EASES_AMBIENT_HERO_ESCORT => 3i32,
            Self::EASES_COMBAT_EVACUATE => 4i32,
            Self::EASES_COMBAT_EVACUATE_VIP_SOLO => 5i32,
            Self::EASES_SICK => 6i32,
            Self::EASES_INFECTED => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAnimSetState {
     const TYPE_ID: &str = "EAnimSetState";
}

impl StaticVariant for Vec<EAnimSetState> {
     const TYPE_ID: &str = "TArray<EAnimSetState>";
}

impl StaticVariant for Vec<Vec<EAnimSetState>> {
     const TYPE_ID: &str = "TArray<TArray<EAnimSetState>>";
}

impl Variant for EAnimSetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAnimSetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAnimSetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAnimSetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAnimSetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAnimSetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAnimSetType {
    EAST_UNDEFINED,
    EAST_DEFAULT,
    EAST_PISTOL,
    EAST_REVOLVER,
    EAST_SMG,
    EAST_SNIPER,
    EAST_ASSULT,
    EAST_SHOTGUN,
    EAST_BODYBAG,
    EAST_GLASS,
    EAST_WHISKYGLASS,
    EAST_WINEGLASS,
    EAST_CHAMPAGNEGLASS,
    EAST_PHONE,
    EAST_BOX,
    EAST_PLATE,
    EAST_SMALLOBJ,
    EAST_SUITCASE,
    EAST_TRAY,
    EAST_TROLLY,
    EAST_FLASHLIGHT,
    EAST_CARRY_1HANDEDWEAPON,
    EAST_CARRY_2HANDEDWEAPON,
    EAST_CARRY_RAKE,
    EAST_CARRY_WEAPON_ITEM,
    EAST_CARRY_BRICK_MINE,
    EAST_CARRY_PROXY_MINE,
    EAST_CARRY_LEAD_PIPES,
    EAST_CARRY_TUBE,
    EAST_CARRY_UMBRELLA,
}

impl Aligned for EAnimSetType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAnimSetType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EAST_UNDEFINED => 0i32,
            Self::EAST_DEFAULT => 1i32,
            Self::EAST_PISTOL => 2i32,
            Self::EAST_REVOLVER => 3i32,
            Self::EAST_SMG => 4i32,
            Self::EAST_SNIPER => 5i32,
            Self::EAST_ASSULT => 6i32,
            Self::EAST_SHOTGUN => 7i32,
            Self::EAST_BODYBAG => 8i32,
            Self::EAST_GLASS => 9i32,
            Self::EAST_WHISKYGLASS => 10i32,
            Self::EAST_WINEGLASS => 11i32,
            Self::EAST_CHAMPAGNEGLASS => 12i32,
            Self::EAST_PHONE => 13i32,
            Self::EAST_BOX => 14i32,
            Self::EAST_PLATE => 15i32,
            Self::EAST_SMALLOBJ => 16i32,
            Self::EAST_SUITCASE => 17i32,
            Self::EAST_TRAY => 18i32,
            Self::EAST_TROLLY => 19i32,
            Self::EAST_FLASHLIGHT => 20i32,
            Self::EAST_CARRY_1HANDEDWEAPON => 21i32,
            Self::EAST_CARRY_2HANDEDWEAPON => 22i32,
            Self::EAST_CARRY_RAKE => 23i32,
            Self::EAST_CARRY_WEAPON_ITEM => 24i32,
            Self::EAST_CARRY_BRICK_MINE => 25i32,
            Self::EAST_CARRY_PROXY_MINE => 26i32,
            Self::EAST_CARRY_LEAD_PIPES => 27i32,
            Self::EAST_CARRY_TUBE => 28i32,
            Self::EAST_CARRY_UMBRELLA => 29i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAnimSetType {
     const TYPE_ID: &str = "EAnimSetType";
}

impl StaticVariant for Vec<EAnimSetType> {
     const TYPE_ID: &str = "TArray<EAnimSetType>";
}

impl StaticVariant for Vec<Vec<EAnimSetType>> {
     const TYPE_ID: &str = "TArray<TArray<EAnimSetType>>";
}

impl Variant for EAnimSetType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAnimSetType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAnimSetType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAnimSetType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAnimSetType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAnimSetType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAnimationPose {
    AP_Undefined,
    AP_Standing,
    AP_SittingChair,
    AP_SittingGround,
    AP_LyingGround,
    AP_Crouching,
    AP_SittingBench,
    AP_SittingChairTable,
}

impl Aligned for EAnimationPose {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAnimationPose {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AP_Undefined => 0i32,
            Self::AP_Standing => 1i32,
            Self::AP_SittingChair => 2i32,
            Self::AP_SittingGround => 3i32,
            Self::AP_LyingGround => 4i32,
            Self::AP_Crouching => 5i32,
            Self::AP_SittingBench => 6i32,
            Self::AP_SittingChairTable => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAnimationPose {
     const TYPE_ID: &str = "EAnimationPose";
}

impl StaticVariant for Vec<EAnimationPose> {
     const TYPE_ID: &str = "TArray<EAnimationPose>";
}

impl StaticVariant for Vec<Vec<EAnimationPose>> {
     const TYPE_ID: &str = "TArray<TArray<EAnimationPose>>";
}

impl Variant for EAnimationPose {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAnimationPose")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAnimationPose".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAnimationPose>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAnimationPose>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAnimationPose>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EAsyncRaycastsGroup {
    eAsyncRaycasts_Gameplay,
    eAsyncRaycasts_ParticlesSoundCloth,
    eAsyncRaycasts_UNUSED_LAST,
}

impl Aligned for EAsyncRaycastsGroup {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EAsyncRaycastsGroup {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAsyncRaycasts_Gameplay => 0i8,
            Self::eAsyncRaycasts_ParticlesSoundCloth => 1i8,
            Self::eAsyncRaycasts_UNUSED_LAST => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAsyncRaycastsGroup {
     const TYPE_ID: &str = "EAsyncRaycastsGroup";
}

impl StaticVariant for Vec<EAsyncRaycastsGroup> {
     const TYPE_ID: &str = "TArray<EAsyncRaycastsGroup>";
}

impl StaticVariant for Vec<Vec<EAsyncRaycastsGroup>> {
     const TYPE_ID: &str = "TArray<TArray<EAsyncRaycastsGroup>>";
}

impl Variant for EAsyncRaycastsGroup {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAsyncRaycastsGroup")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAsyncRaycastsGroup".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAsyncRaycastsGroup>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAsyncRaycastsGroup>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAsyncRaycastsGroup>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAttachLocation {
    eALRightHand,
    eALLeftHand,
    eALFreeBone,
    eALBack,
    eALRifle,
    eALAttachCount,
    eALUndefined,
}

impl Aligned for EAttachLocation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAttachLocation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eALRightHand => 0i32,
            Self::eALLeftHand => 1i32,
            Self::eALFreeBone => 2i32,
            Self::eALBack => 3i32,
            Self::eALRifle => 4i32,
            Self::eALAttachCount => 5i32,
            Self::eALUndefined => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAttachLocation {
     const TYPE_ID: &str = "EAttachLocation";
}

impl StaticVariant for Vec<EAttachLocation> {
     const TYPE_ID: &str = "TArray<EAttachLocation>";
}

impl StaticVariant for Vec<Vec<EAttachLocation>> {
     const TYPE_ID: &str = "TArray<TArray<EAttachLocation>>";
}

impl Variant for EAttachLocation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAttachLocation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAttachLocation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAttachLocation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAttachLocation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAttachLocation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAudioVolumetricMixingMode {
    AUDIO_VOLUMETRIC_MIXING_MAX_ALL,
    AUDIO_VOLUMETRIC_MIXING_MAX_3D,
    AUDIO_VOLUMETRIC_MIXING_ADD,
}

impl Aligned for EAudioVolumetricMixingMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAudioVolumetricMixingMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AUDIO_VOLUMETRIC_MIXING_MAX_ALL => 0i32,
            Self::AUDIO_VOLUMETRIC_MIXING_MAX_3D => 1i32,
            Self::AUDIO_VOLUMETRIC_MIXING_ADD => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAudioVolumetricMixingMode {
     const TYPE_ID: &str = "EAudioVolumetricMixingMode";
}

impl StaticVariant for Vec<EAudioVolumetricMixingMode> {
     const TYPE_ID: &str = "TArray<EAudioVolumetricMixingMode>";
}

impl StaticVariant for Vec<Vec<EAudioVolumetricMixingMode>> {
     const TYPE_ID: &str = "TArray<TArray<EAudioVolumetricMixingMode>>";
}

impl Variant for EAudioVolumetricMixingMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAudioVolumetricMixingMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAudioVolumetricMixingMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAudioVolumetricMixingMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAudioVolumetricMixingMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAudioVolumetricMixingMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EAutoScanMode {
    ASM_GEOMETRY,
    ASM_VOLUMEBOX,
}

impl Aligned for EAutoScanMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EAutoScanMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ASM_GEOMETRY => 0i32,
            Self::ASM_VOLUMEBOX => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EAutoScanMode {
     const TYPE_ID: &str = "EAutoScanMode";
}

impl StaticVariant for Vec<EAutoScanMode> {
     const TYPE_ID: &str = "TArray<EAutoScanMode>";
}

impl StaticVariant for Vec<Vec<EAutoScanMode>> {
     const TYPE_ID: &str = "TArray<TArray<EAutoScanMode>>";
}

impl Variant for EAutoScanMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EAutoScanMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EAutoScanMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EAutoScanMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EAutoScanMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EAutoScanMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBIEventTypes {
    eBIL_HM_HitNPC,
    eBIL_HM_HitNPCKilled,
    eBIL_HM_HitNPCHeadShot,
    eBIL_HM_HitNPCCloseCombatShot,
    eBIL_NPC_HitHM,
    eBIL_Geometry,
}

impl Aligned for EBIEventTypes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBIEventTypes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBIL_HM_HitNPC => 0i32,
            Self::eBIL_HM_HitNPCKilled => 1i32,
            Self::eBIL_HM_HitNPCHeadShot => 2i32,
            Self::eBIL_HM_HitNPCCloseCombatShot => 3i32,
            Self::eBIL_NPC_HitHM => 4i32,
            Self::eBIL_Geometry => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBIEventTypes {
     const TYPE_ID: &str = "EBIEventTypes";
}

impl StaticVariant for Vec<EBIEventTypes> {
     const TYPE_ID: &str = "TArray<EBIEventTypes>";
}

impl StaticVariant for Vec<Vec<EBIEventTypes>> {
     const TYPE_ID: &str = "TArray<TArray<EBIEventTypes>>";
}

impl Variant for EBIEventTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBIEventTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBIEventTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBIEventTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBIEventTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBIEventTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBaseMovementType {
    eMovementNone,
    eMovementDead,
    eMovementNewFullBody,
    eMovementAgility,
    eMovementAlign,
    eMovementCover,
    eMovementDrainPipe,
    eMovementLadder,
    eMovementPullVictimFromWindow,
    eMovementFiberWireKill,
    eMovementDumpBody,
    eMovementThrowBodyOverRail,
    eMovementDumpBodyOverLedge,
    eMovementOperateCPDoor,
    eMovementDisguiseSafeZone,
    eMovementHideInCloset,
    eMovementTakeDown,
    eMovementCloseCombat,
    eMovementRecoveryFinisher,
    eMovementContextAction,
    eMovementSubaction,
    eMovementGrabVictim,
    eMovementPushVictimThroughWindowAndRail,
    eMovementContextKill,
    eMovementKickVictimOverLedge,
    eMovementDragBody,
    eMovementTakeClothes,
    eMovementCoupDeGrace,
    eMovementThrow,
    eMovementPlace,
    eMovementSurrender,
    eMovementFrisk,
    eMovementShowItem,
    eMovementPeek,
    eMovementFocusedInteraction,
    eMovementSilentTakedown,
    eMovementSnapNeck,
    eMovementLocomotion,
    eMovementLast,
    eMovementPickupItem,
}

impl Aligned for EBaseMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBaseMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eMovementNone => -1i32,
            Self::eMovementDead => 0i32,
            Self::eMovementNewFullBody => 1i32,
            Self::eMovementAgility => 2i32,
            Self::eMovementAlign => 3i32,
            Self::eMovementCover => 4i32,
            Self::eMovementDrainPipe => 5i32,
            Self::eMovementLadder => 6i32,
            Self::eMovementPullVictimFromWindow => 7i32,
            Self::eMovementFiberWireKill => 8i32,
            Self::eMovementDumpBody => 9i32,
            Self::eMovementThrowBodyOverRail => 10i32,
            Self::eMovementDumpBodyOverLedge => 11i32,
            Self::eMovementOperateCPDoor => 12i32,
            Self::eMovementDisguiseSafeZone => 13i32,
            Self::eMovementHideInCloset => 14i32,
            Self::eMovementTakeDown => 15i32,
            Self::eMovementCloseCombat => 16i32,
            Self::eMovementRecoveryFinisher => 17i32,
            Self::eMovementContextAction => 18i32,
            Self::eMovementSubaction => 19i32,
            Self::eMovementGrabVictim => 20i32,
            Self::eMovementPushVictimThroughWindowAndRail => 21i32,
            Self::eMovementContextKill => 22i32,
            Self::eMovementKickVictimOverLedge => 23i32,
            Self::eMovementDragBody => 24i32,
            Self::eMovementTakeClothes => 25i32,
            Self::eMovementCoupDeGrace => 26i32,
            Self::eMovementThrow => 27i32,
            Self::eMovementPlace => 28i32,
            Self::eMovementSurrender => 29i32,
            Self::eMovementFrisk => 30i32,
            Self::eMovementShowItem => 31i32,
            Self::eMovementPeek => 32i32,
            Self::eMovementFocusedInteraction => 33i32,
            Self::eMovementSilentTakedown => 34i32,
            Self::eMovementSnapNeck => 35i32,
            Self::eMovementLocomotion => 36i32,
            Self::eMovementLast => 37i32,
            Self::eMovementPickupItem => 38i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBaseMovementType {
     const TYPE_ID: &str = "EBaseMovementType";
}

impl StaticVariant for Vec<EBaseMovementType> {
     const TYPE_ID: &str = "TArray<EBaseMovementType>";
}

impl StaticVariant for Vec<Vec<EBaseMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<EBaseMovementType>>";
}

impl Variant for EBaseMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBaseMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBaseMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBaseMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBaseMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBaseMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBehaviorTreeVariableType {
    BTVT_Invalid,
    BTVT_SceneReference,
    BTVT_Contextual,
    BTVT_Dynamic,
    BTVT_NumTypes,
}

impl Aligned for EBehaviorTreeVariableType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBehaviorTreeVariableType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BTVT_Invalid => -1i32,
            Self::BTVT_SceneReference => 0i32,
            Self::BTVT_Contextual => 1i32,
            Self::BTVT_Dynamic => 2i32,
            Self::BTVT_NumTypes => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBehaviorTreeVariableType {
     const TYPE_ID: &str = "EBehaviorTreeVariableType";
}

impl StaticVariant for Vec<EBehaviorTreeVariableType> {
     const TYPE_ID: &str = "TArray<EBehaviorTreeVariableType>";
}

impl StaticVariant for Vec<Vec<EBehaviorTreeVariableType>> {
     const TYPE_ID: &str = "TArray<TArray<EBehaviorTreeVariableType>>";
}

impl Variant for EBehaviorTreeVariableType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBehaviorTreeVariableType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBehaviorTreeVariableType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBehaviorTreeVariableType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBehaviorTreeVariableType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBehaviorTreeVariableType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBoolCheckType {
    eBCT_IGNORE,
    eBCT_TRUE,
    eBCT_FALSE,
}

impl Aligned for EBoolCheckType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBoolCheckType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBCT_IGNORE => 0i32,
            Self::eBCT_TRUE => 1i32,
            Self::eBCT_FALSE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBoolCheckType {
     const TYPE_ID: &str = "EBoolCheckType";
}

impl StaticVariant for Vec<EBoolCheckType> {
     const TYPE_ID: &str = "TArray<EBoolCheckType>";
}

impl StaticVariant for Vec<Vec<EBoolCheckType>> {
     const TYPE_ID: &str = "TArray<TArray<EBoolCheckType>>";
}

impl Variant for EBoolCheckType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBoolCheckType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBoolCheckType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBoolCheckType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBoolCheckType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBoolCheckType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBoolStateRequirement {
    eBSR_Any,
    eBSR_RequireTrue,
    eBSR_RequireFalse,
}

impl Aligned for EBoolStateRequirement {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBoolStateRequirement {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBSR_Any => 0i32,
            Self::eBSR_RequireTrue => 1i32,
            Self::eBSR_RequireFalse => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBoolStateRequirement {
     const TYPE_ID: &str = "EBoolStateRequirement";
}

impl StaticVariant for Vec<EBoolStateRequirement> {
     const TYPE_ID: &str = "TArray<EBoolStateRequirement>";
}

impl StaticVariant for Vec<Vec<EBoolStateRequirement>> {
     const TYPE_ID: &str = "TArray<TArray<EBoolStateRequirement>>";
}

impl Variant for EBoolStateRequirement {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBoolStateRequirement")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBoolStateRequirement".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBoolStateRequirement>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBoolStateRequirement>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBoolStateRequirement>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBooleanOption {
    BO_Off,
    BO_On,
    BO_Default,
}

impl Aligned for EBooleanOption {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBooleanOption {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BO_Off => 0i32,
            Self::BO_On => 1i32,
            Self::BO_Default => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBooleanOption {
     const TYPE_ID: &str = "EBooleanOption";
}

impl StaticVariant for Vec<EBooleanOption> {
     const TYPE_ID: &str = "TArray<EBooleanOption>";
}

impl StaticVariant for Vec<Vec<EBooleanOption>> {
     const TYPE_ID: &str = "TArray<TArray<EBooleanOption>>";
}

impl Variant for EBooleanOption {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBooleanOption")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBooleanOption".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBooleanOption>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBooleanOption>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBooleanOption>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBulletType {
    BULLET_TYPE_NONE,
    BULLET_TYPE_GUN,
    BULLET_TYPE_REVOLVER,
    BULLET_TYPE_SMG,
    BULLET_TYPE_MG,
    BULLET_TYPE_RIFLE,
    BULLET_TYPE_SHOTGUN,
    BULLET_TYPE_SNIPER,
    BULLET_TYPE_RPG,
}

impl Aligned for EBulletType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBulletType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BULLET_TYPE_NONE => 0i32,
            Self::BULLET_TYPE_GUN => 1i32,
            Self::BULLET_TYPE_REVOLVER => 2i32,
            Self::BULLET_TYPE_SMG => 3i32,
            Self::BULLET_TYPE_MG => 4i32,
            Self::BULLET_TYPE_RIFLE => 5i32,
            Self::BULLET_TYPE_SHOTGUN => 6i32,
            Self::BULLET_TYPE_SNIPER => 7i32,
            Self::BULLET_TYPE_RPG => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBulletType {
     const TYPE_ID: &str = "EBulletType";
}

impl StaticVariant for Vec<EBulletType> {
     const TYPE_ID: &str = "TArray<EBulletType>";
}

impl StaticVariant for Vec<Vec<EBulletType>> {
     const TYPE_ID: &str = "TArray<TArray<EBulletType>>";
}

impl Variant for EBulletType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBulletType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBulletType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBulletType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBulletType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBulletType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EButtonDisplay {
    BUTTON_DISPLAY_AT_OPENDOOR,
    BUTTON_DISPLAY_AT_PICKUP,
    BUTTON_DISPLAY_AT_STARTDIALOG,
    BUTTON_DISPLAY_AT_RESET,
    BUTTON_DISPLAY_AT_OUTFIT,
    BUTTON_DISPLAY_AT_CLOTHBUNDLE,
    BUTTON_DISPLAY_AT_DRAGBODY,
    BUTTON_DISPLAY_AT_SWITCHBOX,
    BUTTON_DISPLAY_AT_SWAPITEM,
    BUTTON_DISPLAY_AT_DUMPBODY,
    BUTTON_DISPLAY_AT_OPENLID,
    BUTTON_DISPLAY_AT_CHECKPOINTDOOR,
    BUTTON_DISPLAY_AT_SIMPLE,
    BUTTON_DISPLAY_AT_ENTERCLOSET,
    BUTTON_DISPLAY_AT_EXITCLOSET,
    BUTTON_DISPLAY_AT_ENTERSAFEZONE,
    BUTTON_DISPLAY_AT_EXITSAFEZONE,
    BUTTON_DISPLAY_AT_DISABLEFUSEBOX,
    BUTTON_DISPLAY_AT_CONTAINERFLUSHBODY,
    BUTTON_DISPLAY_AT_CONTEXTACTION,
    BUTTON_DISPLAY_AT_HEALTHSTATION,
    BUTTON_DISPLAY_AT_KEYCARDREADER,
    BUTTON_DISPLAY_AT_ITEMCONTAINER,
    BUTTON_DISPLAY_AT_USE_QUICK,
    BUTTON_DISPLAY_AT_USE,
    BUTTON_DISPLAY_RELOAD,
    BUTTON_DISPLAY_HOLSTER,
    BUTTON_DISPLAY_CHANGE_WEAPON_MODE,
    BUTTON_DISPLAY_REMOTE_DETONATE,
    BUTTON_DISPLAY_INVENTORY_ACCEPT,
    BUTTON_DISPLAY_INVENTORY_CANCEL,
    BUTTON_DISPLAY_HINTMESSAGE_CONTINUE,
    BUTTON_DISPLAY_CLOSECOMBAT_TAKEDOWN,
    BUTTON_DISPLAY_CLOSECOMBAT_COUNTERATTACK,
    BUTTON_DISPLAY_CLOSECOMBAT_SILENT,
    BUTTON_DISPLAY_CLOSECOMBAT_SNAPNECK,
    BUTTON_DISPLAY_CLOSECOMBAT_CHOKE,
    BUTTON_DISPLAY_CLOSECOMBAT_CHOKE_TARGET,
    BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_HIT,
    BUTTON_DISPLAY_PISTOL_FINISHER,
    BUTTON_DISPLAY_PEEK_VENT,
    BUTTON_DISPLAY_PEEK_CLOSET,
    BUTTON_DISPLAY_CLIMB_LADDER,
    BUTTON_DISPLAY_SLIDE_LADDER,
    BUTTON_DISPLAY_LEDGE,
    BUTTON_DISPLAY_LEDGE_STEPON,
    BUTTON_DISPLAY_LEDGEJUMP,
    BUTTON_DISPLAY_LEDGE_PULL_UP,
    BUTTON_DISPLAY_LEDGE_CLIMB_DOWN,
    BUTTON_DISPLAY_LEDGE_DROP_DOWN,
    BUTTON_DISPLAY_WINDOW,
    BUTTON_DISPLAY_WINDOWSNEAK,
    BUTTON_DISPLAY_PULLVICTIM,
    BUTTON_DISPLAY_PUSHVICTIM,
    BUTTON_DISPLAY_SURRENDER,
    BUTTON_DISPLAY_COVERTOCOVER,
    BUTTON_DISPLAY_COVERCORNER,
    BUTTON_DISPLAY_COVEREXITFORWARD,
    BUTTON_DISPLAY_COVERSCALEEXIT,
    BUTTON_DISPLAY_TAKEDISGUISE,
    BUTTON_DISPLAY_DROPBODY,
    BUTTON_DISPLAY_ABORT_CHECKPOINTDOOR,
    BUTTON_DISPLAY_QUICKSWAP,
    BUTTON_DISPLAY_OPERATE_LEVER,
    BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_HIGH,
    BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_LOW,
    BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_COUNTER,
    BUTTON_DISPLAY_FIBERWIRE_KILL,
    BUTTON_DISPLAY_DROP_ITEM,
    BUTTON_DISPLAY_ABORT_MINIGAME,
    BUTTON_DISPLAY_CONTRACT_MARK,
    BUTTON_DISPLAY_CONTRACT_UNMARK,
    BUTTON_DISPLAY_COMPLY,
    BUTTON_DISPLAY_MAX,
}

impl Aligned for EButtonDisplay {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EButtonDisplay {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BUTTON_DISPLAY_AT_OPENDOOR => 0i32,
            Self::BUTTON_DISPLAY_AT_PICKUP => 1i32,
            Self::BUTTON_DISPLAY_AT_STARTDIALOG => 2i32,
            Self::BUTTON_DISPLAY_AT_RESET => 3i32,
            Self::BUTTON_DISPLAY_AT_OUTFIT => 4i32,
            Self::BUTTON_DISPLAY_AT_CLOTHBUNDLE => 5i32,
            Self::BUTTON_DISPLAY_AT_DRAGBODY => 6i32,
            Self::BUTTON_DISPLAY_AT_SWITCHBOX => 7i32,
            Self::BUTTON_DISPLAY_AT_SWAPITEM => 8i32,
            Self::BUTTON_DISPLAY_AT_DUMPBODY => 9i32,
            Self::BUTTON_DISPLAY_AT_OPENLID => 10i32,
            Self::BUTTON_DISPLAY_AT_CHECKPOINTDOOR => 11i32,
            Self::BUTTON_DISPLAY_AT_SIMPLE => 12i32,
            Self::BUTTON_DISPLAY_AT_ENTERCLOSET => 13i32,
            Self::BUTTON_DISPLAY_AT_EXITCLOSET => 14i32,
            Self::BUTTON_DISPLAY_AT_ENTERSAFEZONE => 15i32,
            Self::BUTTON_DISPLAY_AT_EXITSAFEZONE => 16i32,
            Self::BUTTON_DISPLAY_AT_DISABLEFUSEBOX => 17i32,
            Self::BUTTON_DISPLAY_AT_CONTAINERFLUSHBODY => 18i32,
            Self::BUTTON_DISPLAY_AT_CONTEXTACTION => 19i32,
            Self::BUTTON_DISPLAY_AT_HEALTHSTATION => 20i32,
            Self::BUTTON_DISPLAY_AT_KEYCARDREADER => 21i32,
            Self::BUTTON_DISPLAY_AT_ITEMCONTAINER => 22i32,
            Self::BUTTON_DISPLAY_AT_USE_QUICK => 23i32,
            Self::BUTTON_DISPLAY_AT_USE => 24i32,
            Self::BUTTON_DISPLAY_RELOAD => 25i32,
            Self::BUTTON_DISPLAY_HOLSTER => 26i32,
            Self::BUTTON_DISPLAY_CHANGE_WEAPON_MODE => 27i32,
            Self::BUTTON_DISPLAY_REMOTE_DETONATE => 28i32,
            Self::BUTTON_DISPLAY_INVENTORY_ACCEPT => 29i32,
            Self::BUTTON_DISPLAY_INVENTORY_CANCEL => 30i32,
            Self::BUTTON_DISPLAY_HINTMESSAGE_CONTINUE => 31i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_TAKEDOWN => 32i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_COUNTERATTACK => 33i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_SILENT => 34i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_SNAPNECK => 35i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHOKE => 36i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHOKE_TARGET => 37i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_HIT => 38i32,
            Self::BUTTON_DISPLAY_PISTOL_FINISHER => 39i32,
            Self::BUTTON_DISPLAY_PEEK_VENT => 40i32,
            Self::BUTTON_DISPLAY_PEEK_CLOSET => 41i32,
            Self::BUTTON_DISPLAY_CLIMB_LADDER => 42i32,
            Self::BUTTON_DISPLAY_SLIDE_LADDER => 43i32,
            Self::BUTTON_DISPLAY_LEDGE => 44i32,
            Self::BUTTON_DISPLAY_LEDGE_STEPON => 45i32,
            Self::BUTTON_DISPLAY_LEDGEJUMP => 46i32,
            Self::BUTTON_DISPLAY_LEDGE_PULL_UP => 47i32,
            Self::BUTTON_DISPLAY_LEDGE_CLIMB_DOWN => 48i32,
            Self::BUTTON_DISPLAY_LEDGE_DROP_DOWN => 49i32,
            Self::BUTTON_DISPLAY_WINDOW => 50i32,
            Self::BUTTON_DISPLAY_WINDOWSNEAK => 51i32,
            Self::BUTTON_DISPLAY_PULLVICTIM => 52i32,
            Self::BUTTON_DISPLAY_PUSHVICTIM => 53i32,
            Self::BUTTON_DISPLAY_SURRENDER => 54i32,
            Self::BUTTON_DISPLAY_COVERTOCOVER => 55i32,
            Self::BUTTON_DISPLAY_COVERCORNER => 56i32,
            Self::BUTTON_DISPLAY_COVEREXITFORWARD => 57i32,
            Self::BUTTON_DISPLAY_COVERSCALEEXIT => 58i32,
            Self::BUTTON_DISPLAY_TAKEDISGUISE => 59i32,
            Self::BUTTON_DISPLAY_DROPBODY => 60i32,
            Self::BUTTON_DISPLAY_ABORT_CHECKPOINTDOOR => 61i32,
            Self::BUTTON_DISPLAY_QUICKSWAP => 62i32,
            Self::BUTTON_DISPLAY_OPERATE_LEVER => 63i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_HIGH => 64i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_LOW => 65i32,
            Self::BUTTON_DISPLAY_CLOSECOMBAT_CHAIN_COUNTER => 66i32,
            Self::BUTTON_DISPLAY_FIBERWIRE_KILL => 67i32,
            Self::BUTTON_DISPLAY_DROP_ITEM => 68i32,
            Self::BUTTON_DISPLAY_ABORT_MINIGAME => 69i32,
            Self::BUTTON_DISPLAY_CONTRACT_MARK => 70i32,
            Self::BUTTON_DISPLAY_CONTRACT_UNMARK => 71i32,
            Self::BUTTON_DISPLAY_COMPLY => 72i32,
            Self::BUTTON_DISPLAY_MAX => 73i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EButtonDisplay {
     const TYPE_ID: &str = "EButtonDisplay";
}

impl StaticVariant for Vec<EButtonDisplay> {
     const TYPE_ID: &str = "TArray<EButtonDisplay>";
}

impl StaticVariant for Vec<Vec<EButtonDisplay>> {
     const TYPE_ID: &str = "TArray<TArray<EButtonDisplay>>";
}

impl Variant for EButtonDisplay {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EButtonDisplay")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EButtonDisplay".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EButtonDisplay>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EButtonDisplay>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EButtonDisplay>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EButtonPressType {
    BUTTON_PRESS,
    BUTTON_HOLD,
    BUTTON_REPEAT,
    BUTTON_TAP,
    BUTTON_ROTATE_CCW,
    BUTTON_PRESS_TYPE_MAX,
}

impl Aligned for EButtonPressType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EButtonPressType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BUTTON_PRESS => 0i32,
            Self::BUTTON_HOLD => 1i32,
            Self::BUTTON_REPEAT => 2i32,
            Self::BUTTON_TAP => 3i32,
            Self::BUTTON_ROTATE_CCW => 4i32,
            Self::BUTTON_PRESS_TYPE_MAX => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EButtonPressType {
     const TYPE_ID: &str = "EButtonPressType";
}

impl StaticVariant for Vec<EButtonPressType> {
     const TYPE_ID: &str = "TArray<EButtonPressType>";
}

impl StaticVariant for Vec<Vec<EButtonPressType>> {
     const TYPE_ID: &str = "TArray<TArray<EButtonPressType>>";
}

impl Variant for EButtonPressType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EButtonPressType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EButtonPressType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EButtonPressType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EButtonPressType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EButtonPressType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EButtonState {
    BUTTON_STATE_DISABLED,
    BUTTON_STATE_NONE,
    BUTTON_STATE_ENABLED,
    BUTTON_STATE_PRESSED,
    BUTTON_STATE_BLINKING,
}

impl Aligned for EButtonState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EButtonState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BUTTON_STATE_DISABLED => -1i32,
            Self::BUTTON_STATE_NONE => 0i32,
            Self::BUTTON_STATE_ENABLED => 1i32,
            Self::BUTTON_STATE_PRESSED => 2i32,
            Self::BUTTON_STATE_BLINKING => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EButtonState {
     const TYPE_ID: &str = "EButtonState";
}

impl StaticVariant for Vec<EButtonState> {
     const TYPE_ID: &str = "TArray<EButtonState>";
}

impl StaticVariant for Vec<Vec<EButtonState>> {
     const TYPE_ID: &str = "TArray<TArray<EButtonState>>";
}

impl Variant for EButtonState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EButtonState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EButtonState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EButtonState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EButtonState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EButtonState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EBystanderPointType {
    BPT_Scared,
    BPT_Alerted,
}

impl Aligned for EBystanderPointType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EBystanderPointType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BPT_Scared => 0i32,
            Self::BPT_Alerted => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EBystanderPointType {
     const TYPE_ID: &str = "EBystanderPointType";
}

impl StaticVariant for Vec<EBystanderPointType> {
     const TYPE_ID: &str = "TArray<EBystanderPointType>";
}

impl StaticVariant for Vec<Vec<EBystanderPointType>> {
     const TYPE_ID: &str = "TArray<TArray<EBystanderPointType>>";
}

impl Variant for EBystanderPointType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EBystanderPointType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EBystanderPointType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EBystanderPointType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EBystanderPointType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EBystanderPointType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECCDUsage {
    ECCDUSAGE_DISABLED,
    ECCDUSAGE_AGAINST_STATIC,
    ECCDUSAGE_AGAINST_STATIC_DYNAMIC,
}

impl Aligned for ECCDUsage {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECCDUsage {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECCDUSAGE_DISABLED => 0i8,
            Self::ECCDUSAGE_AGAINST_STATIC => 1i8,
            Self::ECCDUSAGE_AGAINST_STATIC_DYNAMIC => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCDUsage {
     const TYPE_ID: &str = "ECCDUsage";
}

impl StaticVariant for Vec<ECCDUsage> {
     const TYPE_ID: &str = "TArray<ECCDUsage>";
}

impl StaticVariant for Vec<Vec<ECCDUsage>> {
     const TYPE_ID: &str = "TArray<TArray<ECCDUsage>>";
}

impl Variant for ECCDUsage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCDUsage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCDUsage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCDUsage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCDUsage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCDUsage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECCDecalEffect {
    eCCDecalEffect_None,
    eCCDecalEffect_Stab,
    eCCDecalEffect_Blunt1H,
    eCCDecalEffect_Blunt2H,
    eCCDecalEffect_Slash1H,
    eCCDecalEffect_Shatter,
    eCCDecalEffect_AxeCleave,
    eCCDecalEffect_AxePull,
    eCCDecalEffect_AxeSlitThroat,
    eCCDecalEffect_SlitThroat,
    eCCDecalEffect_FacePunch,
    eCCDecalEffect_Bruise,
}

impl Aligned for ECCDecalEffect {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECCDecalEffect {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCCDecalEffect_None => 0i32,
            Self::eCCDecalEffect_Stab => 1i32,
            Self::eCCDecalEffect_Blunt1H => 2i32,
            Self::eCCDecalEffect_Blunt2H => 3i32,
            Self::eCCDecalEffect_Slash1H => 4i32,
            Self::eCCDecalEffect_Shatter => 5i32,
            Self::eCCDecalEffect_AxeCleave => 6i32,
            Self::eCCDecalEffect_AxePull => 7i32,
            Self::eCCDecalEffect_AxeSlitThroat => 8i32,
            Self::eCCDecalEffect_SlitThroat => 9i32,
            Self::eCCDecalEffect_FacePunch => 10i32,
            Self::eCCDecalEffect_Bruise => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCDecalEffect {
     const TYPE_ID: &str = "ECCDecalEffect";
}

impl StaticVariant for Vec<ECCDecalEffect> {
     const TYPE_ID: &str = "TArray<ECCDecalEffect>";
}

impl StaticVariant for Vec<Vec<ECCDecalEffect>> {
     const TYPE_ID: &str = "TArray<TArray<ECCDecalEffect>>";
}

impl Variant for ECCDecalEffect {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCDecalEffect")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCDecalEffect".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCDecalEffect>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCDecalEffect>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCDecalEffect>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECCEmitterEffect {
    eCCEmitterEffect_None,
    eCCEmitterEffect_Stab,
    eCCEmitterEffect_Blunt1H,
    eCCEmitterEffect_Blunt2H,
    eCCEmitterEffect_Slash1H,
    eCCEmitterEffect_Shatter,
    eCCEmitterEffect_AxeCleave,
    eCCEmitterEffect_AxePull,
    eCCEmitterEffect_AxeSlitThroat,
    eCCEmitterEffect_SlitThroat,
    eCCEmitterEffect_FacePunch,
    eCCEmitterEffect_Blood,
}

impl Aligned for ECCEmitterEffect {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECCEmitterEffect {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCCEmitterEffect_None => 0i32,
            Self::eCCEmitterEffect_Stab => 1i32,
            Self::eCCEmitterEffect_Blunt1H => 2i32,
            Self::eCCEmitterEffect_Blunt2H => 3i32,
            Self::eCCEmitterEffect_Slash1H => 4i32,
            Self::eCCEmitterEffect_Shatter => 5i32,
            Self::eCCEmitterEffect_AxeCleave => 6i32,
            Self::eCCEmitterEffect_AxePull => 7i32,
            Self::eCCEmitterEffect_AxeSlitThroat => 8i32,
            Self::eCCEmitterEffect_SlitThroat => 9i32,
            Self::eCCEmitterEffect_FacePunch => 10i32,
            Self::eCCEmitterEffect_Blood => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCEmitterEffect {
     const TYPE_ID: &str = "ECCEmitterEffect";
}

impl StaticVariant for Vec<ECCEmitterEffect> {
     const TYPE_ID: &str = "TArray<ECCEmitterEffect>";
}

impl StaticVariant for Vec<Vec<ECCEmitterEffect>> {
     const TYPE_ID: &str = "TArray<TArray<ECCEmitterEffect>>";
}

impl Variant for ECCEmitterEffect {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCEmitterEffect")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCEmitterEffect".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCEmitterEffect>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCEmitterEffect>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCEmitterEffect>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECCNodeSubtype {
    eCCNodeSubtype_Left,
    eCCNodeSubtype_Right,
    eCCNodeSubtype_Front,
    eCCNodeSubtype_Back,
    eCCNodeSubtype_StairsAbove,
    eCCNodeSubtype_StairsBelow,
    eCCNodeSubtype_StairsAbove_Back,
    eCCNodeSubtype_StairsBelow_Back,
    eCCNodeSubtype_Front_Back,
    eCCNodeSubtype_Count,
}

impl Aligned for ECCNodeSubtype {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECCNodeSubtype {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCCNodeSubtype_Left => 0i32,
            Self::eCCNodeSubtype_Right => 1i32,
            Self::eCCNodeSubtype_Front => 2i32,
            Self::eCCNodeSubtype_Back => 3i32,
            Self::eCCNodeSubtype_StairsAbove => 4i32,
            Self::eCCNodeSubtype_StairsBelow => 5i32,
            Self::eCCNodeSubtype_StairsAbove_Back => 6i32,
            Self::eCCNodeSubtype_StairsBelow_Back => 7i32,
            Self::eCCNodeSubtype_Front_Back => 8i32,
            Self::eCCNodeSubtype_Count => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCNodeSubtype {
     const TYPE_ID: &str = "ECCNodeSubtype";
}

impl StaticVariant for Vec<ECCNodeSubtype> {
     const TYPE_ID: &str = "TArray<ECCNodeSubtype>";
}

impl StaticVariant for Vec<Vec<ECCNodeSubtype>> {
     const TYPE_ID: &str = "TArray<TArray<ECCNodeSubtype>>";
}

impl Variant for ECCNodeSubtype {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCNodeSubtype")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCNodeSubtype".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCNodeSubtype>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCNodeSubtype>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCNodeSubtype>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECCNodeType {
    eCCNodeType_Counter,
    eCCNodeType_ExecutePistol,
    eCCNodeType_React,
    eCCNodeType_SilentTakeDownEnd,
    eCCNodeType_SilentKill,
    eCCNodeType_SlitThroat1H,
    eCCNodeType_Swing1H,
    eCCNodeType_Bash1H,
    eCCNodeType_Stab1H,
    eCCNodeType_Syringe1H,
    eCCNodeType_Strangle1H,
    eCCNodeType_Smash1H,
    eCCNodeType_Swing2H,
    eCCNodeType_Stab2H,
    eCCNodeType_Bash2H,
    eCCNodeType_Strangle2H,
    eCCNodeType_Axe,
    eCCNodeType_Sword1H,
    eCCNodeType_AttackChain,
    eCCNodeType_AttackChainCivilian,
    eCCNodeType_AttackChainHeavy,
    eCCNodeType_FailChain,
    eCCNodeType_FinishChainHigh,
    eCCNodeType_FinishChainLow,
    eCCNodeType_FinishChainKill,
    eCCNodeType_StairsChain,
    eCCNodeType_CounterChain,
    eCCNodeType_AttackIdle,
    eCCNodeType_AttackPassify,
    eCCNodeType_FailChainPush,
    eCCNodeType_Count,
}

impl Aligned for ECCNodeType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECCNodeType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCCNodeType_Counter => 0i32,
            Self::eCCNodeType_ExecutePistol => 1i32,
            Self::eCCNodeType_React => 2i32,
            Self::eCCNodeType_SilentTakeDownEnd => 3i32,
            Self::eCCNodeType_SilentKill => 4i32,
            Self::eCCNodeType_SlitThroat1H => 5i32,
            Self::eCCNodeType_Swing1H => 6i32,
            Self::eCCNodeType_Bash1H => 7i32,
            Self::eCCNodeType_Stab1H => 8i32,
            Self::eCCNodeType_Syringe1H => 9i32,
            Self::eCCNodeType_Strangle1H => 10i32,
            Self::eCCNodeType_Smash1H => 11i32,
            Self::eCCNodeType_Swing2H => 12i32,
            Self::eCCNodeType_Stab2H => 13i32,
            Self::eCCNodeType_Bash2H => 14i32,
            Self::eCCNodeType_Strangle2H => 15i32,
            Self::eCCNodeType_Axe => 16i32,
            Self::eCCNodeType_Sword1H => 17i32,
            Self::eCCNodeType_AttackChain => 18i32,
            Self::eCCNodeType_AttackChainCivilian => 19i32,
            Self::eCCNodeType_AttackChainHeavy => 20i32,
            Self::eCCNodeType_FailChain => 21i32,
            Self::eCCNodeType_FinishChainHigh => 22i32,
            Self::eCCNodeType_FinishChainLow => 23i32,
            Self::eCCNodeType_FinishChainKill => 24i32,
            Self::eCCNodeType_StairsChain => 25i32,
            Self::eCCNodeType_CounterChain => 26i32,
            Self::eCCNodeType_AttackIdle => 27i32,
            Self::eCCNodeType_AttackPassify => 28i32,
            Self::eCCNodeType_FailChainPush => 29i32,
            Self::eCCNodeType_Count => 30i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCNodeType {
     const TYPE_ID: &str = "ECCNodeType";
}

impl StaticVariant for Vec<ECCNodeType> {
     const TYPE_ID: &str = "TArray<ECCNodeType>";
}

impl StaticVariant for Vec<Vec<ECCNodeType>> {
     const TYPE_ID: &str = "TArray<TArray<ECCNodeType>>";
}

impl Variant for ECCNodeType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCNodeType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCNodeType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCNodeType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCNodeType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCNodeType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECCWeaponAnimSet {
    AS_SLIT_THROAT_1H,
    AS_SWING_1H,
    AS_BASH_1H,
    AS_STAB_1H,
    AS_SYRINGE_1H,
    AS_SMASH_1H,
    AS_STRANGLE,
    AS_SWING_2H,
    AS_BASH_2H,
    AS_STAB_2H,
    AS_STRANGLE_2H,
    AS_SWORD_1H,
    AS_AXE,
}

impl Aligned for ECCWeaponAnimSet {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECCWeaponAnimSet {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_SLIT_THROAT_1H => 0i32,
            Self::AS_SWING_1H => 1i32,
            Self::AS_BASH_1H => 2i32,
            Self::AS_STAB_1H => 3i32,
            Self::AS_SYRINGE_1H => 4i32,
            Self::AS_SMASH_1H => 5i32,
            Self::AS_STRANGLE => 6i32,
            Self::AS_SWING_2H => 7i32,
            Self::AS_BASH_2H => 8i32,
            Self::AS_STAB_2H => 9i32,
            Self::AS_STRANGLE_2H => 10i32,
            Self::AS_SWORD_1H => 11i32,
            Self::AS_AXE => 12i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECCWeaponAnimSet {
     const TYPE_ID: &str = "ECCWeaponAnimSet";
}

impl StaticVariant for Vec<ECCWeaponAnimSet> {
     const TYPE_ID: &str = "TArray<ECCWeaponAnimSet>";
}

impl StaticVariant for Vec<Vec<ECCWeaponAnimSet>> {
     const TYPE_ID: &str = "TArray<TArray<ECCWeaponAnimSet>>";
}

impl Variant for ECCWeaponAnimSet {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECCWeaponAnimSet")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECCWeaponAnimSet".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECCWeaponAnimSet>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECCWeaponAnimSet>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECCWeaponAnimSet>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECOMUsage {
    ECOMUSAGE_AUTOCOMPUTE,
    ECOMUSAGE_PIVOT,
}

impl Aligned for ECOMUsage {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECOMUsage {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECOMUSAGE_AUTOCOMPUTE => 0i8,
            Self::ECOMUSAGE_PIVOT => 1i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECOMUsage {
     const TYPE_ID: &str = "ECOMUsage";
}

impl StaticVariant for Vec<ECOMUsage> {
     const TYPE_ID: &str = "TArray<ECOMUsage>";
}

impl StaticVariant for Vec<Vec<ECOMUsage>> {
     const TYPE_ID: &str = "TArray<TArray<ECOMUsage>>";
}

impl Variant for ECOMUsage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECOMUsage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECOMUsage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECOMUsage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECOMUsage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECOMUsage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECameraAssistanceMode {
    eCAM_None,
    eCAM_TrackAssist,
    eCAM_AutoTrackTarget,
}

impl Aligned for ECameraAssistanceMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECameraAssistanceMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCAM_None => 0i32,
            Self::eCAM_TrackAssist => 1i32,
            Self::eCAM_AutoTrackTarget => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraAssistanceMode {
     const TYPE_ID: &str = "ECameraAssistanceMode";
}

impl StaticVariant for Vec<ECameraAssistanceMode> {
     const TYPE_ID: &str = "TArray<ECameraAssistanceMode>";
}

impl StaticVariant for Vec<Vec<ECameraAssistanceMode>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraAssistanceMode>>";
}

impl Variant for ECameraAssistanceMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraAssistanceMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraAssistanceMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraAssistanceMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraAssistanceMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraAssistanceMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECameraCollisionMode {
    ECAMERACOLLISIONMODE_COLLIDE_ALWAYS,
    ECAMERACOLLISIONMODE_CAMERA_OBSTACLE,
    ECAMERACOLLISIONMODE_COLLIDE_NEVER,
    ECAMERACOLLISIONMODE_COLLIDE_DEFAULT,
}

impl Aligned for ECameraCollisionMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECameraCollisionMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECAMERACOLLISIONMODE_COLLIDE_ALWAYS => 0i8,
            Self::ECAMERACOLLISIONMODE_CAMERA_OBSTACLE => 1i8,
            Self::ECAMERACOLLISIONMODE_COLLIDE_NEVER => 2i8,
            Self::ECAMERACOLLISIONMODE_COLLIDE_DEFAULT => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraCollisionMode {
     const TYPE_ID: &str = "ECameraCollisionMode";
}

impl StaticVariant for Vec<ECameraCollisionMode> {
     const TYPE_ID: &str = "TArray<ECameraCollisionMode>";
}

impl StaticVariant for Vec<Vec<ECameraCollisionMode>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraCollisionMode>>";
}

impl Variant for ECameraCollisionMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraCollisionMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraCollisionMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraCollisionMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraCollisionMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraCollisionMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECameraControls {
    eCameraControlsNormal,
    eCameraControlsOTS,
}

impl Aligned for ECameraControls {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECameraControls {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCameraControlsNormal => 0i32,
            Self::eCameraControlsOTS => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraControls {
     const TYPE_ID: &str = "ECameraControls";
}

impl StaticVariant for Vec<ECameraControls> {
     const TYPE_ID: &str = "TArray<ECameraControls>";
}

impl StaticVariant for Vec<Vec<ECameraControls>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraControls>>";
}

impl Variant for ECameraControls {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraControls")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraControls".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraControls>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraControls>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraControls>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECameraOffset_old {
    eCameraOffset_Center,
    eCameraOffset_Left,
    eCameraOffset_Right,
}

impl Aligned for ECameraOffset_old {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECameraOffset_old {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCameraOffset_Center => 0i32,
            Self::eCameraOffset_Left => 1i32,
            Self::eCameraOffset_Right => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraOffset_old {
     const TYPE_ID: &str = "ECameraOffset_old";
}

impl StaticVariant for Vec<ECameraOffset_old> {
     const TYPE_ID: &str = "TArray<ECameraOffset_old>";
}

impl StaticVariant for Vec<Vec<ECameraOffset_old>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraOffset_old>>";
}

impl Variant for ECameraOffset_old {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraOffset_old")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraOffset_old".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraOffset_old>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraOffset_old>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraOffset_old>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECameraShakerChannel {
    eCameraShakerChannel_Default,
    eCameraShakerChannle_Locomotion,
    eCameraShakerChannel_Ambient,
    eCameraShakerChannel_Weapon,
    eCameraShakerChannel_CloseCombat,
    eCameraShakerChannel_Num,
}

impl Aligned for ECameraShakerChannel {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECameraShakerChannel {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCameraShakerChannel_Default => 0i32,
            Self::eCameraShakerChannle_Locomotion => 1i32,
            Self::eCameraShakerChannel_Ambient => 2i32,
            Self::eCameraShakerChannel_Weapon => 3i32,
            Self::eCameraShakerChannel_CloseCombat => 4i32,
            Self::eCameraShakerChannel_Num => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraShakerChannel {
     const TYPE_ID: &str = "ECameraShakerChannel";
}

impl StaticVariant for Vec<ECameraShakerChannel> {
     const TYPE_ID: &str = "TArray<ECameraShakerChannel>";
}

impl StaticVariant for Vec<Vec<ECameraShakerChannel>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraShakerChannel>>";
}

impl Variant for ECameraShakerChannel {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraShakerChannel")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraShakerChannel".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraShakerChannel>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraShakerChannel>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraShakerChannel>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECameraState {
    eCamSneakStand,
    eCamSneakWalk,
    eCamSneakRoadyRun,
    eCamNormalStand,
    eCamNormalWalk,
    eCamNormalRun,
    eCamLocomotion,
    eCamCrowdStand,
    eCamCrowdWalk,
    eCamCrowdRun,
    eCamCrowdSneakStand,
    eCamCrowdSneakWalk,
    eCamCrowdSneakRoadyRun,
    eCamCrowdLocomotion,
    eCamDead,
    eCamLadder,
    eCamDrainPipe,
    eCamDrag,
    eCamSBTag,
    eCamSBTagOTS,
    eCamCloseCombat,
    eCamFiberWire,
    eCamWindowPull,
    eCamRailPush,
    eCamLedgeKick,
    eCamLedgePull,
    eCamLedgeHang,
    eCamLedgeWalk,
    eCamLedgeWalkOTS,
    eCamCoverLow,
    eCamCoverMedium,
    eCamCoverHigh,
    eCamCoverLowOTS,
    eCamCoverHighOTS,
    eCamCoverLowScope,
    eCamCoverHighScope,
    eCamCoverLowTakedownOver,
    eCamCoverLowTakedownCorner,
    eCamCoverHighTakedownCorner,
    eCamTakeDisguise,
    eCamOTS,
    eCamOTSHigh,
    eCamOTSLow,
    eCamUnAimedShooting,
    eCamUnAimedShootingHigh,
    eCamUnAimedShootingLow,
    eCamScope,
    eCamScopeHigh,
    eCamScopeLow,
    eCamVaultLow,
    eCamVaultHigh,
    eCamTakedown,
    eCamTakedownChair,
    eCamLockedSniping,
    eCamLockedSnipingScope,
    eCamLockedSnipingScopeHigh,
    eCamLockedSnipingScopeLow,
    eCamContainerAssemble,
    eCamNumProfiles,
    eCamAll,
}

impl Aligned for ECameraState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECameraState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCamSneakStand => 0i32,
            Self::eCamSneakWalk => 1i32,
            Self::eCamSneakRoadyRun => 2i32,
            Self::eCamNormalStand => 3i32,
            Self::eCamNormalWalk => 4i32,
            Self::eCamNormalRun => 5i32,
            Self::eCamLocomotion => 6i32,
            Self::eCamCrowdStand => 7i32,
            Self::eCamCrowdWalk => 8i32,
            Self::eCamCrowdRun => 9i32,
            Self::eCamCrowdSneakStand => 10i32,
            Self::eCamCrowdSneakWalk => 11i32,
            Self::eCamCrowdSneakRoadyRun => 12i32,
            Self::eCamCrowdLocomotion => 13i32,
            Self::eCamDead => 14i32,
            Self::eCamLadder => 15i32,
            Self::eCamDrainPipe => 16i32,
            Self::eCamDrag => 17i32,
            Self::eCamSBTag => 18i32,
            Self::eCamSBTagOTS => 19i32,
            Self::eCamCloseCombat => 20i32,
            Self::eCamFiberWire => 21i32,
            Self::eCamWindowPull => 22i32,
            Self::eCamRailPush => 23i32,
            Self::eCamLedgeKick => 24i32,
            Self::eCamLedgePull => 25i32,
            Self::eCamLedgeHang => 26i32,
            Self::eCamLedgeWalk => 27i32,
            Self::eCamLedgeWalkOTS => 28i32,
            Self::eCamCoverLow => 29i32,
            Self::eCamCoverMedium => 30i32,
            Self::eCamCoverHigh => 31i32,
            Self::eCamCoverLowOTS => 32i32,
            Self::eCamCoverHighOTS => 33i32,
            Self::eCamCoverLowScope => 34i32,
            Self::eCamCoverHighScope => 35i32,
            Self::eCamCoverLowTakedownOver => 36i32,
            Self::eCamCoverLowTakedownCorner => 37i32,
            Self::eCamCoverHighTakedownCorner => 38i32,
            Self::eCamTakeDisguise => 39i32,
            Self::eCamOTS => 40i32,
            Self::eCamOTSHigh => 41i32,
            Self::eCamOTSLow => 42i32,
            Self::eCamUnAimedShooting => 43i32,
            Self::eCamUnAimedShootingHigh => 44i32,
            Self::eCamUnAimedShootingLow => 45i32,
            Self::eCamScope => 46i32,
            Self::eCamScopeHigh => 47i32,
            Self::eCamScopeLow => 48i32,
            Self::eCamVaultLow => 49i32,
            Self::eCamVaultHigh => 50i32,
            Self::eCamTakedown => 51i32,
            Self::eCamTakedownChair => 52i32,
            Self::eCamLockedSniping => 53i32,
            Self::eCamLockedSnipingScope => 54i32,
            Self::eCamLockedSnipingScopeHigh => 55i32,
            Self::eCamLockedSnipingScopeLow => 56i32,
            Self::eCamContainerAssemble => 57i32,
            Self::eCamNumProfiles => 58i32,
            Self::eCamAll => 59i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECameraState {
     const TYPE_ID: &str = "ECameraState";
}

impl StaticVariant for Vec<ECameraState> {
     const TYPE_ID: &str = "TArray<ECameraState>";
}

impl StaticVariant for Vec<Vec<ECameraState>> {
     const TYPE_ID: &str = "TArray<TArray<ECameraState>>";
}

impl Variant for ECameraState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECameraState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECameraState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECameraState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECameraState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECameraState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECausalGraphTraversal {
    eCGT_NONE,
    eCGT_INPUT,
    eCGT_OUTPUT,
    eCGT_BOTH,
}

impl Aligned for ECausalGraphTraversal {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECausalGraphTraversal {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCGT_NONE => 0i32,
            Self::eCGT_INPUT => 1i32,
            Self::eCGT_OUTPUT => 2i32,
            Self::eCGT_BOTH => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECausalGraphTraversal {
     const TYPE_ID: &str = "ECausalGraphTraversal";
}

impl StaticVariant for Vec<ECausalGraphTraversal> {
     const TYPE_ID: &str = "TArray<ECausalGraphTraversal>";
}

impl StaticVariant for Vec<Vec<ECausalGraphTraversal>> {
     const TYPE_ID: &str = "TArray<TArray<ECausalGraphTraversal>>";
}

impl Variant for ECausalGraphTraversal {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECausalGraphTraversal")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECausalGraphTraversal".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECausalGraphTraversal>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECausalGraphTraversal>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECausalGraphTraversal>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECautiousDisturbanceState {
    eCDS_Pending,
    eCDS_Expired,
    eCDS_Handled,
    eCDS_GetHelpGroup,
    eCDS_InvestigationGroup,
    eCDS_InvestigateAfterExplosion,
    eCDS_Ignored,
    eCDS_NoInvestigator,
    eCDS_Similar,
    eCDS_ManHunt,
    eCDS_CombatSuppressGunshots,
}

impl Aligned for ECautiousDisturbanceState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECautiousDisturbanceState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCDS_Pending => 0i32,
            Self::eCDS_Expired => 1i32,
            Self::eCDS_Handled => 2i32,
            Self::eCDS_GetHelpGroup => 3i32,
            Self::eCDS_InvestigationGroup => 4i32,
            Self::eCDS_InvestigateAfterExplosion => 5i32,
            Self::eCDS_Ignored => 6i32,
            Self::eCDS_NoInvestigator => 7i32,
            Self::eCDS_Similar => 8i32,
            Self::eCDS_ManHunt => 9i32,
            Self::eCDS_CombatSuppressGunshots => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECautiousDisturbanceState {
     const TYPE_ID: &str = "ECautiousDisturbanceState";
}

impl StaticVariant for Vec<ECautiousDisturbanceState> {
     const TYPE_ID: &str = "TArray<ECautiousDisturbanceState>";
}

impl StaticVariant for Vec<Vec<ECautiousDisturbanceState>> {
     const TYPE_ID: &str = "TArray<TArray<ECautiousDisturbanceState>>";
}

impl Variant for ECautiousDisturbanceState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECautiousDisturbanceState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECautiousDisturbanceState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECautiousDisturbanceState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECautiousDisturbanceState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECautiousDisturbanceState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharSetCharacterType {
    ECSCT_Actor,
    ECSCT_Nude,
    ECSCT_HeroA,
}

impl Aligned for ECharSetCharacterType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharSetCharacterType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECSCT_Actor => 0i32,
            Self::ECSCT_Nude => 1i32,
            Self::ECSCT_HeroA => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharSetCharacterType {
     const TYPE_ID: &str = "ECharSetCharacterType";
}

impl StaticVariant for Vec<ECharSetCharacterType> {
     const TYPE_ID: &str = "TArray<ECharSetCharacterType>";
}

impl StaticVariant for Vec<Vec<ECharSetCharacterType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharSetCharacterType>>";
}

impl Variant for ECharSetCharacterType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharSetCharacterType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharSetCharacterType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharSetCharacterType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharSetCharacterType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharSetCharacterType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterActionRequests {
    eSM_AR_None,
    eSM_AR_ReloadR,
    eSM_AR_ReloadL,
    eSM_AR_ShootR,
    eSM_AR_ShootL,
    eSM_AR_SwapHands,
    eSM_AR_HolsterR,
    eSM_AR_HolsterL,
    eSM_AR_UnholsterR,
    eSM_AR_UnholsterL,
    eSM_AR_PickupItemR,
    eSM_AR_PickupItemL,
    eSM_AR_InteractionR,
    eSM_AR_InteractionL,
    eSM_AR_InteractionSwipe,
    eSM_AR_InteractionSwipeR,
    eSM_AR_InteractionSwipeL,
    eSM_AR_OpenDoor,
    eSM_AR_OpenDoorR,
    eSM_AR_OpenDoorL,
    eSM_AR_CloseCombat,
    eSM_AR_Movement,
    eSM_AR_Pretend,
    eSM_AR_Sniping,
    eSM_AR_EndSniping,
    eSM_AR_RetrieveFromSuitcase,
    eSM_AR_Marking,
    eSM_AR_ChangeAmmo,
    eSM_AR_Assemble,
    eSM_AR_Assemble_UnequippedContainer,
    eSM_AR_Disassemble,
    eSM_AR_Disassemble_PickingUp,
    eSM_AR_AssembleUB,
    eSM_AR_DisassembleUB,
    eSM_AR_Cancel,
    eSM_AR_Sprint,
    eSM_AR_CloseHandR,
    eSM_AR_CloseHandL,
}

impl Aligned for ECharacterActionRequests {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterActionRequests {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_AR_None => 0i32,
            Self::eSM_AR_ReloadR => 1i32,
            Self::eSM_AR_ReloadL => 2i32,
            Self::eSM_AR_ShootR => 3i32,
            Self::eSM_AR_ShootL => 4i32,
            Self::eSM_AR_SwapHands => 5i32,
            Self::eSM_AR_HolsterR => 6i32,
            Self::eSM_AR_HolsterL => 7i32,
            Self::eSM_AR_UnholsterR => 8i32,
            Self::eSM_AR_UnholsterL => 9i32,
            Self::eSM_AR_PickupItemR => 10i32,
            Self::eSM_AR_PickupItemL => 11i32,
            Self::eSM_AR_InteractionR => 12i32,
            Self::eSM_AR_InteractionL => 13i32,
            Self::eSM_AR_InteractionSwipe => 14i32,
            Self::eSM_AR_InteractionSwipeR => 15i32,
            Self::eSM_AR_InteractionSwipeL => 16i32,
            Self::eSM_AR_OpenDoor => 17i32,
            Self::eSM_AR_OpenDoorR => 18i32,
            Self::eSM_AR_OpenDoorL => 19i32,
            Self::eSM_AR_CloseCombat => 20i32,
            Self::eSM_AR_Movement => 21i32,
            Self::eSM_AR_Pretend => 22i32,
            Self::eSM_AR_Sniping => 23i32,
            Self::eSM_AR_EndSniping => 24i32,
            Self::eSM_AR_RetrieveFromSuitcase => 25i32,
            Self::eSM_AR_Marking => 26i32,
            Self::eSM_AR_ChangeAmmo => 27i32,
            Self::eSM_AR_Assemble => 28i32,
            Self::eSM_AR_Assemble_UnequippedContainer => 29i32,
            Self::eSM_AR_Disassemble => 30i32,
            Self::eSM_AR_Disassemble_PickingUp => 31i32,
            Self::eSM_AR_AssembleUB => 32i32,
            Self::eSM_AR_DisassembleUB => 33i32,
            Self::eSM_AR_Cancel => 34i32,
            Self::eSM_AR_Sprint => 35i32,
            Self::eSM_AR_CloseHandR => 36i32,
            Self::eSM_AR_CloseHandL => 37i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterActionRequests {
     const TYPE_ID: &str = "ECharacterActionRequests";
}

impl StaticVariant for Vec<ECharacterActionRequests> {
     const TYPE_ID: &str = "TArray<ECharacterActionRequests>";
}

impl StaticVariant for Vec<Vec<ECharacterActionRequests>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterActionRequests>>";
}

impl Variant for ECharacterActionRequests {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterActionRequests")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterActionRequests".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterActionRequests>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterActionRequests>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterActionRequests>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterActionSyncRequests {
    eSM_ASR_Reload,
    eSM_ASR_SwapItemHandL,
    eSM_ASR_SwapItemHandR,
}

impl Aligned for ECharacterActionSyncRequests {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterActionSyncRequests {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_ASR_Reload => 1i32,
            Self::eSM_ASR_SwapItemHandL => 2i32,
            Self::eSM_ASR_SwapItemHandR => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterActionSyncRequests {
     const TYPE_ID: &str = "ECharacterActionSyncRequests";
}

impl StaticVariant for Vec<ECharacterActionSyncRequests> {
     const TYPE_ID: &str = "TArray<ECharacterActionSyncRequests>";
}

impl StaticVariant for Vec<Vec<ECharacterActionSyncRequests>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterActionSyncRequests>>";
}

impl Variant for ECharacterActionSyncRequests {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterActionSyncRequests")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterActionSyncRequests".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterActionSyncRequests>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterActionSyncRequests>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterActionSyncRequests>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterAnimChildNetworkSlot {
    eCACNS_None,
    eCACNS_FlavorIdle_FB,
    eCACNS_FlavorIdle_RH,
    eCACNS_FlavorIdle_LH,
    eCACNS_Interaction_RH,
    eCACNS_Interaction_LH,
}

impl Aligned for ECharacterAnimChildNetworkSlot {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterAnimChildNetworkSlot {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCACNS_None => 0i32,
            Self::eCACNS_FlavorIdle_FB => 1i32,
            Self::eCACNS_FlavorIdle_RH => 2i32,
            Self::eCACNS_FlavorIdle_LH => 3i32,
            Self::eCACNS_Interaction_RH => 4i32,
            Self::eCACNS_Interaction_LH => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterAnimChildNetworkSlot {
     const TYPE_ID: &str = "ECharacterAnimChildNetworkSlot";
}

impl StaticVariant for Vec<ECharacterAnimChildNetworkSlot> {
     const TYPE_ID: &str = "TArray<ECharacterAnimChildNetworkSlot>";
}

impl StaticVariant for Vec<Vec<ECharacterAnimChildNetworkSlot>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterAnimChildNetworkSlot>>";
}

impl Variant for ECharacterAnimChildNetworkSlot {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterAnimChildNetworkSlot")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterAnimChildNetworkSlot".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterAnimChildNetworkSlot>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterAnimChildNetworkSlot>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterAnimChildNetworkSlot>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterAnimEvent {
    eCAE_ReloadStarted,
    eCAE_ReloadedClip,
    eCAE_ReloadCompleted,
    eCAE_ReloadedOneBullet,
    eCAE_ReloadUpdate,
    eCAE_ReloadSwapRHandAttacher,
    eCAE_ReloadResetRHandSwap,
    eCAE_ChangeAmmoCompleted,
    eCAE_UnholsterAttachL,
    eCAE_UnholsterCompletedL,
    eCAE_UnholsterAttachR,
    eCAE_UnholsterCompletedR,
    eCAE_HolsterDetachL,
    eCAE_HolsterCompletedL,
    eCAE_HolsterDetachR,
    eCAE_HolsterCompletedR,
    eCAE_PickupActivate,
    eCAE_PickupCompleted,
    eCAE_SwipeActivate,
    eCAE_SwipeCompleted,
    eCAE_InteractionActivate,
    eCAE_InteractionCompleted,
    eCAE_SwapHandsRtoL,
    eCAE_SwapHandsRtoLCompleted,
    eCAE_SwapHandsLtoR,
    eCAE_SwapHandsLtoRCompleted,
    eCAE_OpenDoorActivate,
    eCAE_OpenDoorCompleted,
    eCAE_FlavorIdleCompleted,
    eCAE_AssembleContainerAttach,
    eCAE_AssemblePlaceAlignCompleted,
    eCAE_AssembleAttach,
    eCAE_AssembleEarlyOut,
    eCAE_AssembleToSneak,
    eCAE_AssembleCompleted,
    eCAE_HandIKEnableLeft,
    eCAE_HandIKDisableLeft,
    eCAE_HandIKEnableRight,
    eCAE_HandIKDisableRight,
    eCAE_EarlyExit,
}

impl Aligned for ECharacterAnimEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterAnimEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCAE_ReloadStarted => 699i32,
            Self::eCAE_ReloadedClip => 700i32,
            Self::eCAE_ReloadCompleted => 701i32,
            Self::eCAE_ReloadedOneBullet => 711i32,
            Self::eCAE_ReloadUpdate => 702i32,
            Self::eCAE_ReloadSwapRHandAttacher => 703i32,
            Self::eCAE_ReloadResetRHandSwap => 704i32,
            Self::eCAE_ChangeAmmoCompleted => 712i32,
            Self::eCAE_UnholsterAttachL => 9010i32,
            Self::eCAE_UnholsterCompletedL => 9011i32,
            Self::eCAE_UnholsterAttachR => 9012i32,
            Self::eCAE_UnholsterCompletedR => 9013i32,
            Self::eCAE_HolsterDetachL => 9020i32,
            Self::eCAE_HolsterCompletedL => 9021i32,
            Self::eCAE_HolsterDetachR => 9022i32,
            Self::eCAE_HolsterCompletedR => 9023i32,
            Self::eCAE_PickupActivate => 9030i32,
            Self::eCAE_PickupCompleted => 9031i32,
            Self::eCAE_SwipeActivate => 9030i32,
            Self::eCAE_SwipeCompleted => 9031i32,
            Self::eCAE_InteractionActivate => 5001i32,
            Self::eCAE_InteractionCompleted => 5000i32,
            Self::eCAE_SwapHandsRtoL => 9040i32,
            Self::eCAE_SwapHandsRtoLCompleted => 9041i32,
            Self::eCAE_SwapHandsLtoR => 9042i32,
            Self::eCAE_SwapHandsLtoRCompleted => 9043i32,
            Self::eCAE_OpenDoorActivate => 9051i32,
            Self::eCAE_OpenDoorCompleted => 9050i32,
            Self::eCAE_FlavorIdleCompleted => 9060i32,
            Self::eCAE_AssembleContainerAttach => 9074i32,
            Self::eCAE_AssemblePlaceAlignCompleted => 9070i32,
            Self::eCAE_AssembleAttach => 9071i32,
            Self::eCAE_AssembleEarlyOut => 9075i32,
            Self::eCAE_AssembleToSneak => 9073i32,
            Self::eCAE_AssembleCompleted => 9072i32,
            Self::eCAE_HandIKEnableLeft => 10000i32,
            Self::eCAE_HandIKDisableLeft => 10001i32,
            Self::eCAE_HandIKEnableRight => 10002i32,
            Self::eCAE_HandIKDisableRight => 10003i32,
            Self::eCAE_EarlyExit => 50i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterAnimEvent {
     const TYPE_ID: &str = "ECharacterAnimEvent";
}

impl StaticVariant for Vec<ECharacterAnimEvent> {
     const TYPE_ID: &str = "TArray<ECharacterAnimEvent>";
}

impl StaticVariant for Vec<Vec<ECharacterAnimEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterAnimEvent>>";
}

impl Variant for ECharacterAnimEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterAnimEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterAnimEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterAnimEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterAnimEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterAnimEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECharacterAnimEventState {
    eES_None,
    eES_Pending,
    eES_Completed,
    eES_TimedOut,
}

impl Aligned for ECharacterAnimEventState {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECharacterAnimEventState {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eES_None => 0i8,
            Self::eES_Pending => 1i8,
            Self::eES_Completed => 2i8,
            Self::eES_TimedOut => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterAnimEventState {
     const TYPE_ID: &str = "ECharacterAnimEventState";
}

impl StaticVariant for Vec<ECharacterAnimEventState> {
     const TYPE_ID: &str = "TArray<ECharacterAnimEventState>";
}

impl StaticVariant for Vec<Vec<ECharacterAnimEventState>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterAnimEventState>>";
}

impl Variant for ECharacterAnimEventState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterAnimEventState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterAnimEventState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterAnimEventState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterAnimEventState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterAnimEventState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterBodyType {
    eCT_MaleRegular,
    eCT_FemaleRegular,
    eCT_Male47,
    eCT_Undefined,
}

impl Aligned for ECharacterBodyType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterBodyType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCT_MaleRegular => 0i32,
            Self::eCT_FemaleRegular => 1i32,
            Self::eCT_Male47 => 2i32,
            Self::eCT_Undefined => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterBodyType {
     const TYPE_ID: &str = "ECharacterBodyType";
}

impl StaticVariant for Vec<ECharacterBodyType> {
     const TYPE_ID: &str = "TArray<ECharacterBodyType>";
}

impl StaticVariant for Vec<Vec<ECharacterBodyType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterBodyType>>";
}

impl Variant for ECharacterBodyType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterBodyType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterBodyType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterBodyType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterBodyType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterBodyType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECharacterCollidableLayer {
    CCL_DYNAMIC,
    CCL_DYNAMIC_TRANSPARENT,
    CCL_DYNAMIC_NO_COLLISION,
    CCL_DYNAMIC_NO_COLLISION_TRANSPARENT,
    CCL_UNUSED_LAST,
}

impl Aligned for ECharacterCollidableLayer {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECharacterCollidableLayer {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CCL_DYNAMIC => 0i8,
            Self::CCL_DYNAMIC_TRANSPARENT => 1i8,
            Self::CCL_DYNAMIC_NO_COLLISION => 2i8,
            Self::CCL_DYNAMIC_NO_COLLISION_TRANSPARENT => 3i8,
            Self::CCL_UNUSED_LAST => 4i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterCollidableLayer {
     const TYPE_ID: &str = "ECharacterCollidableLayer";
}

impl StaticVariant for Vec<ECharacterCollidableLayer> {
     const TYPE_ID: &str = "TArray<ECharacterCollidableLayer>";
}

impl StaticVariant for Vec<Vec<ECharacterCollidableLayer>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterCollidableLayer>>";
}

impl Variant for ECharacterCollidableLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterCollidableLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterCollidableLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterCollidableLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterCollidableLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterCollidableLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterEvent {
    eCIET_PickUp,
    eCIET_LadderEnded,
    eCIET_AgilityEnded,
    eCIET_CCEnded,
    eCIET_Disguised,
    eCIET_HideBody,
    eCIET_WalkingOnStairs,
    eCIET_Sniping_Congratulate,
    eCIET_Sniping_Acknowledge,
    eCIET_FlavorIdleEnded,
    eCIET_StartedMoving,
    eCIET_StoppedMoving,
    eCIET_DragBody,
    eCIET_Takedown,
    eCIET_Damaged,
    eCIET_None,
}

impl Aligned for ECharacterEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCIET_PickUp => 0i32,
            Self::eCIET_LadderEnded => 1i32,
            Self::eCIET_AgilityEnded => 2i32,
            Self::eCIET_CCEnded => 3i32,
            Self::eCIET_Disguised => 4i32,
            Self::eCIET_HideBody => 5i32,
            Self::eCIET_WalkingOnStairs => 6i32,
            Self::eCIET_Sniping_Congratulate => 7i32,
            Self::eCIET_Sniping_Acknowledge => 8i32,
            Self::eCIET_FlavorIdleEnded => 9i32,
            Self::eCIET_StartedMoving => 10i32,
            Self::eCIET_StoppedMoving => 11i32,
            Self::eCIET_DragBody => 12i32,
            Self::eCIET_Takedown => 13i32,
            Self::eCIET_Damaged => 14i32,
            Self::eCIET_None => 34i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterEvent {
     const TYPE_ID: &str = "ECharacterEvent";
}

impl StaticVariant for Vec<ECharacterEvent> {
     const TYPE_ID: &str = "TArray<ECharacterEvent>";
}

impl StaticVariant for Vec<Vec<ECharacterEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterEvent>>";
}

impl Variant for ECharacterEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterFullBodyStateType {
    eSM_FB_OldMovementPlaceholder,
    eSM_FB_Slave,
    eSM_FB_Locomotion,
    eSM_FB_CloseCombat,
    eSM_FB_FlavorIdle,
    eSM_FB_Sniping,
    eSM_FB_AssemblePutOnTheFloor,
    eSM_FB_AssembleAlignContainer,
    eSM_FB_AssembleRetrieve,
    eSM_FB_AssembleStore,
}

impl Aligned for ECharacterFullBodyStateType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterFullBodyStateType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_FB_OldMovementPlaceholder => 0i32,
            Self::eSM_FB_Slave => 1i32,
            Self::eSM_FB_Locomotion => 2i32,
            Self::eSM_FB_CloseCombat => 3i32,
            Self::eSM_FB_FlavorIdle => 4i32,
            Self::eSM_FB_Sniping => 5i32,
            Self::eSM_FB_AssemblePutOnTheFloor => 6i32,
            Self::eSM_FB_AssembleAlignContainer => 7i32,
            Self::eSM_FB_AssembleRetrieve => 8i32,
            Self::eSM_FB_AssembleStore => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterFullBodyStateType {
     const TYPE_ID: &str = "ECharacterFullBodyStateType";
}

impl StaticVariant for Vec<ECharacterFullBodyStateType> {
     const TYPE_ID: &str = "TArray<ECharacterFullBodyStateType>";
}

impl StaticVariant for Vec<Vec<ECharacterFullBodyStateType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterFullBodyStateType>>";
}

impl Variant for ECharacterFullBodyStateType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterFullBodyStateType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterFullBodyStateType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterFullBodyStateType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterFullBodyStateType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterFullBodyStateType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterIdleHandlerFullbodyType {
    ecIHFBT_DisguisedIdle,
    ecIHFBT_Event,
}

impl Aligned for ECharacterIdleHandlerFullbodyType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterIdleHandlerFullbodyType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ecIHFBT_DisguisedIdle => 0i32,
            Self::ecIHFBT_Event => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterIdleHandlerFullbodyType {
     const TYPE_ID: &str = "ECharacterIdleHandlerFullbodyType";
}

impl StaticVariant for Vec<ECharacterIdleHandlerFullbodyType> {
     const TYPE_ID: &str = "TArray<ECharacterIdleHandlerFullbodyType>";
}

impl StaticVariant for Vec<Vec<ECharacterIdleHandlerFullbodyType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterIdleHandlerFullbodyType>>";
}

impl Variant for ECharacterIdleHandlerFullbodyType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterIdleHandlerFullbodyType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterIdleHandlerFullbodyType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterIdleHandlerFullbodyType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterIdleHandlerFullbodyType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterIdleHandlerFullbodyType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterIdleHandlerUpperBodyType {
    eCIHUBT_NothingToDoEmptySingleHand,
    eCIHUBT_NothingToDoEmptyHands,
    eCIHUBT_Event,
    eCIHUBT_Custom,
}

impl Aligned for ECharacterIdleHandlerUpperBodyType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterIdleHandlerUpperBodyType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCIHUBT_NothingToDoEmptySingleHand => 0i32,
            Self::eCIHUBT_NothingToDoEmptyHands => 1i32,
            Self::eCIHUBT_Event => 2i32,
            Self::eCIHUBT_Custom => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterIdleHandlerUpperBodyType {
     const TYPE_ID: &str = "ECharacterIdleHandlerUpperBodyType";
}

impl StaticVariant for Vec<ECharacterIdleHandlerUpperBodyType> {
     const TYPE_ID: &str = "TArray<ECharacterIdleHandlerUpperBodyType>";
}

impl StaticVariant for Vec<Vec<ECharacterIdleHandlerUpperBodyType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterIdleHandlerUpperBodyType>>";
}

impl Variant for ECharacterIdleHandlerUpperBodyType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterIdleHandlerUpperBodyType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterIdleHandlerUpperBodyType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterIdleHandlerUpperBodyType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterIdleHandlerUpperBodyType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterIdleHandlerUpperBodyType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterIdlePriority {
    eCIP_Irrelevant,
    eCIP_VeryLow,
    eCIP_QuiteLow,
    eCIP_Low,
    eCIP_MediumLow,
    eCIP_Medium,
    eCIP_MediumHigh,
    eCIP_High,
    eCIP_QuiteHigh,
    eCIP_VeryHigh,
    eCIP_Urgent,
}

impl Aligned for ECharacterIdlePriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterIdlePriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCIP_Irrelevant => 0i32,
            Self::eCIP_VeryLow => 1i32,
            Self::eCIP_QuiteLow => 2i32,
            Self::eCIP_Low => 3i32,
            Self::eCIP_MediumLow => 4i32,
            Self::eCIP_Medium => 5i32,
            Self::eCIP_MediumHigh => 6i32,
            Self::eCIP_High => 7i32,
            Self::eCIP_QuiteHigh => 8i32,
            Self::eCIP_VeryHigh => 9i32,
            Self::eCIP_Urgent => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterIdlePriority {
     const TYPE_ID: &str = "ECharacterIdlePriority";
}

impl StaticVariant for Vec<ECharacterIdlePriority> {
     const TYPE_ID: &str = "TArray<ECharacterIdlePriority>";
}

impl StaticVariant for Vec<Vec<ECharacterIdlePriority>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterIdlePriority>>";
}

impl Variant for ECharacterIdlePriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterIdlePriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterIdlePriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterIdlePriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterIdlePriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterIdlePriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterResourceType {
    eSMT_Invalid,
    eSMT_FullBody,
    eSMT_RightHand,
    eSMT_LeftHand,
}

impl Aligned for ECharacterResourceType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterResourceType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSMT_Invalid => 0i32,
            Self::eSMT_FullBody => 1i32,
            Self::eSMT_RightHand => 2i32,
            Self::eSMT_LeftHand => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterResourceType {
     const TYPE_ID: &str = "ECharacterResourceType";
}

impl StaticVariant for Vec<ECharacterResourceType> {
     const TYPE_ID: &str = "TArray<ECharacterResourceType>";
}

impl StaticVariant for Vec<Vec<ECharacterResourceType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterResourceType>>";
}

impl Variant for ECharacterResourceType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterResourceType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterResourceType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterResourceType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterResourceType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterResourceType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterStateTags {
    eSM_ST_UsingFullBody,
    eSM_ST_UsingRightHand,
    eSM_ST_UsingLeftHand,
    eSM_ST_EnslavingRightHand,
    eSM_ST_EnslavingLeftHand,
    eSM_ST_EnslavingFullBody,
    eSM_ST_UpperBodyRequestedControlRightHand,
    eSM_ST_UpperBodyRequestedControlLeftHand,
    eSM_ST_CanGiveUpControlRightHand,
    eSM_ST_CanGiveUpControlLeftHand,
    eSM_ST_Pickup,
    eSM_ST_Sniping,
    eSM_ST_Reloading,
    eSM_ST_Assemble,
    eSM_ST_EmptyStateLeftHand,
    eSM_ST_EmptyStateRightHand,
    eSM_ST_EnableOldMovement,
    eSM_ST_UsingItemLeft,
    eSM_ST_UsingItemRight,
}

impl Aligned for ECharacterStateTags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterStateTags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_ST_UsingFullBody => 1i32,
            Self::eSM_ST_UsingRightHand => 2i32,
            Self::eSM_ST_UsingLeftHand => 4i32,
            Self::eSM_ST_EnslavingRightHand => 8i32,
            Self::eSM_ST_EnslavingLeftHand => 16i32,
            Self::eSM_ST_EnslavingFullBody => 32i32,
            Self::eSM_ST_UpperBodyRequestedControlRightHand => 64i32,
            Self::eSM_ST_UpperBodyRequestedControlLeftHand => 128i32,
            Self::eSM_ST_CanGiveUpControlRightHand => 256i32,
            Self::eSM_ST_CanGiveUpControlLeftHand => 512i32,
            Self::eSM_ST_Pickup => 1024i32,
            Self::eSM_ST_Sniping => 2048i32,
            Self::eSM_ST_Reloading => 4096i32,
            Self::eSM_ST_Assemble => 262144i32,
            Self::eSM_ST_EmptyStateLeftHand => 8396800i32,
            Self::eSM_ST_EmptyStateRightHand => 16384i32,
            Self::eSM_ST_EnableOldMovement => 32768i32,
            Self::eSM_ST_UsingItemLeft => 65536i32,
            Self::eSM_ST_UsingItemRight => 131072i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterStateTags {
     const TYPE_ID: &str = "ECharacterStateTags";
}

impl StaticVariant for Vec<ECharacterStateTags> {
     const TYPE_ID: &str = "TArray<ECharacterStateTags>";
}

impl StaticVariant for Vec<Vec<ECharacterStateTags>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterStateTags>>";
}

impl Variant for ECharacterStateTags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterStateTags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterStateTags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterStateTags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterStateTags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterStateTags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterStateTransitionAttempt {
    eSM_TA_IfDestinationCan,
    eSM_TA_IfDestinationCanAndWants,
    eSM_TA_IfDestinationCanAndOriginDoesNotWant,
    eSM_TA_IfDestinationCanAndWantsOriginDoesNotWant,
    eSM_TA_IfDestinationCanAndOriginCanNot,
}

impl Aligned for ECharacterStateTransitionAttempt {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterStateTransitionAttempt {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_TA_IfDestinationCan => 0i32,
            Self::eSM_TA_IfDestinationCanAndWants => 1i32,
            Self::eSM_TA_IfDestinationCanAndOriginDoesNotWant => 2i32,
            Self::eSM_TA_IfDestinationCanAndWantsOriginDoesNotWant => 3i32,
            Self::eSM_TA_IfDestinationCanAndOriginCanNot => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterStateTransitionAttempt {
     const TYPE_ID: &str = "ECharacterStateTransitionAttempt";
}

impl StaticVariant for Vec<ECharacterStateTransitionAttempt> {
     const TYPE_ID: &str = "TArray<ECharacterStateTransitionAttempt>";
}

impl StaticVariant for Vec<Vec<ECharacterStateTransitionAttempt>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterStateTransitionAttempt>>";
}

impl Variant for ECharacterStateTransitionAttempt {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterStateTransitionAttempt")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterStateTransitionAttempt".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterStateTransitionAttempt>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterStateTransitionAttempt>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterStateTransitionAttempt>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterSubcontrollerType {
    eSCT_IDGenerator,
    eSCT_Debugger,
    eSCT_Time,
    eSCT_Tags,
    eSCT_Descriptors,
    eSCT_ActionRequest,
    eSCT_Events,
    eSCT_Animator,
    eSCT_Motor,
    eSCT_Inventory,
    eSCT_FlavorIdle,
    eSCT_Lookat,
    eSCT_AimAssistant,
    eSCT_CharacterCollector,
    eSCT_SwipeMechanic,
    eSCT_OpenDoor,
    eSCT_Fullbody,
    eSCT_Aim,
    eSCT_PrecisionShot,
    eSCT_Marking,
    eSCT_Grip,
    eSCT_Suitcase,
    eSCT_VRConfig,
    eSCT_Hands,
    eSCT_StickingItems,
    eSCT_Fiberwire,
}

impl Aligned for ECharacterSubcontrollerType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterSubcontrollerType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSCT_IDGenerator => 0i32,
            Self::eSCT_Debugger => 1i32,
            Self::eSCT_Time => 2i32,
            Self::eSCT_Tags => 3i32,
            Self::eSCT_Descriptors => 4i32,
            Self::eSCT_ActionRequest => 5i32,
            Self::eSCT_Events => 6i32,
            Self::eSCT_Animator => 7i32,
            Self::eSCT_Motor => 8i32,
            Self::eSCT_Inventory => 9i32,
            Self::eSCT_FlavorIdle => 10i32,
            Self::eSCT_Lookat => 11i32,
            Self::eSCT_AimAssistant => 12i32,
            Self::eSCT_CharacterCollector => 13i32,
            Self::eSCT_SwipeMechanic => 14i32,
            Self::eSCT_OpenDoor => 15i32,
            Self::eSCT_Fullbody => 16i32,
            Self::eSCT_Aim => 17i32,
            Self::eSCT_PrecisionShot => 18i32,
            Self::eSCT_Marking => 19i32,
            Self::eSCT_Grip => 20i32,
            Self::eSCT_Suitcase => 21i32,
            Self::eSCT_VRConfig => 22i32,
            Self::eSCT_Hands => 23i32,
            Self::eSCT_StickingItems => 24i32,
            Self::eSCT_Fiberwire => 25i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterSubcontrollerType {
     const TYPE_ID: &str = "ECharacterSubcontrollerType";
}

impl StaticVariant for Vec<ECharacterSubcontrollerType> {
     const TYPE_ID: &str = "TArray<ECharacterSubcontrollerType>";
}

impl StaticVariant for Vec<Vec<ECharacterSubcontrollerType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterSubcontrollerType>>";
}

impl Variant for ECharacterSubcontrollerType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterSubcontrollerType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterSubcontrollerType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterSubcontrollerType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterSubcontrollerType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterSubcontrollerType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECharacterUpperBodyStateType {
    eSM_UB_EmptyHanded,
    eSM_UB_Unholster,
    eSM_UB_Hold,
    eSM_UB_Reload,
    eSM_UB_Holster,
    eSM_UB_Conceal,
    eSM_UB_SwapItemHand,
    eSM_UB_Aiming,
    eSM_UB_Pickup,
    eSM_UB_InteractionSwipe,
    eSM_UB_Interaction,
    eSM_UB_Slave,
    eSM_UB_OpenDoor,
    eSM_UB_FlavorIdle,
    eSM_UB_ChangeAmmo,
    eSM_UB_Assemble,
    eSM_UB_Fiberwire,
    eSM_UB_PrimeTwoHanded,
    eSM_UB_SnapNeck,
}

impl Aligned for ECharacterUpperBodyStateType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECharacterUpperBodyStateType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSM_UB_EmptyHanded => 0i32,
            Self::eSM_UB_Unholster => 1i32,
            Self::eSM_UB_Hold => 2i32,
            Self::eSM_UB_Reload => 3i32,
            Self::eSM_UB_Holster => 4i32,
            Self::eSM_UB_Conceal => 5i32,
            Self::eSM_UB_SwapItemHand => 6i32,
            Self::eSM_UB_Aiming => 7i32,
            Self::eSM_UB_Pickup => 8i32,
            Self::eSM_UB_InteractionSwipe => 9i32,
            Self::eSM_UB_Interaction => 10i32,
            Self::eSM_UB_Slave => 11i32,
            Self::eSM_UB_OpenDoor => 12i32,
            Self::eSM_UB_FlavorIdle => 13i32,
            Self::eSM_UB_ChangeAmmo => 14i32,
            Self::eSM_UB_Assemble => 15i32,
            Self::eSM_UB_Fiberwire => 16i32,
            Self::eSM_UB_PrimeTwoHanded => 17i32,
            Self::eSM_UB_SnapNeck => 18i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECharacterUpperBodyStateType {
     const TYPE_ID: &str = "ECharacterUpperBodyStateType";
}

impl StaticVariant for Vec<ECharacterUpperBodyStateType> {
     const TYPE_ID: &str = "TArray<ECharacterUpperBodyStateType>";
}

impl StaticVariant for Vec<Vec<ECharacterUpperBodyStateType>> {
     const TYPE_ID: &str = "TArray<TArray<ECharacterUpperBodyStateType>>";
}

impl Variant for ECharacterUpperBodyStateType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECharacterUpperBodyStateType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECharacterUpperBodyStateType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECharacterUpperBodyStateType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECharacterUpperBodyStateType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECharacterUpperBodyStateType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECheatGroup {
    eCGNone,
    eCGPistols,
    eCGSMGs,
    eCGAssaultRifles,
    eCGShotguns,
    eCGSniper,
    eCGExotics,
    eCGDevices,
}

impl Aligned for ECheatGroup {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECheatGroup {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCGNone => 0i32,
            Self::eCGPistols => 1i32,
            Self::eCGSMGs => 2i32,
            Self::eCGAssaultRifles => 3i32,
            Self::eCGShotguns => 4i32,
            Self::eCGSniper => 5i32,
            Self::eCGExotics => 6i32,
            Self::eCGDevices => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECheatGroup {
     const TYPE_ID: &str = "ECheatGroup";
}

impl StaticVariant for Vec<ECheatGroup> {
     const TYPE_ID: &str = "TArray<ECheatGroup>";
}

impl StaticVariant for Vec<Vec<ECheatGroup>> {
     const TYPE_ID: &str = "TArray<TArray<ECheatGroup>>";
}

impl Variant for ECheatGroup {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECheatGroup")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECheatGroup".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECheatGroup>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECheatGroup>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECheatGroup>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EClipSpawnAxis {
    eCSA_XPos,
    eCSA_XNeg,
    eCSA_YPos,
    eCSA_YNeg,
    eCSA_ZPos,
    eCSA_ZNeg,
}

impl Aligned for EClipSpawnAxis {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EClipSpawnAxis {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCSA_XPos => 0i32,
            Self::eCSA_XNeg => 1i32,
            Self::eCSA_YPos => 2i32,
            Self::eCSA_YNeg => 3i32,
            Self::eCSA_ZPos => 4i32,
            Self::eCSA_ZNeg => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EClipSpawnAxis {
     const TYPE_ID: &str = "EClipSpawnAxis";
}

impl StaticVariant for Vec<EClipSpawnAxis> {
     const TYPE_ID: &str = "TArray<EClipSpawnAxis>";
}

impl StaticVariant for Vec<Vec<EClipSpawnAxis>> {
     const TYPE_ID: &str = "TArray<TArray<EClipSpawnAxis>>";
}

impl Variant for EClipSpawnAxis {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EClipSpawnAxis")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EClipSpawnAxis".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EClipSpawnAxis>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EClipSpawnAxis>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EClipSpawnAxis>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EClothBendConstrainType {
    eClothBendConstrainType_Stick,
    eClothBendConstrainType_Triangle,
}

impl Aligned for EClothBendConstrainType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EClothBendConstrainType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eClothBendConstrainType_Stick => 0i32,
            Self::eClothBendConstrainType_Triangle => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EClothBendConstrainType {
     const TYPE_ID: &str = "EClothBendConstrainType";
}

impl StaticVariant for Vec<EClothBendConstrainType> {
     const TYPE_ID: &str = "TArray<EClothBendConstrainType>";
}

impl StaticVariant for Vec<Vec<EClothBendConstrainType>> {
     const TYPE_ID: &str = "TArray<TArray<EClothBendConstrainType>>";
}

impl Variant for EClothBendConstrainType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EClothBendConstrainType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EClothBendConstrainType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EClothBendConstrainType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EClothBendConstrainType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EClothBendConstrainType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EClothColliderFilter {
    EClothColliderFilter_Environment,
    EClothColliderFilter_Character,
    EClothColliderFilter_Character_Environment,
}

impl Aligned for EClothColliderFilter {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EClothColliderFilter {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EClothColliderFilter_Environment => 0i32,
            Self::EClothColliderFilter_Character => 1i32,
            Self::EClothColliderFilter_Character_Environment => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EClothColliderFilter {
     const TYPE_ID: &str = "EClothColliderFilter";
}

impl StaticVariant for Vec<EClothColliderFilter> {
     const TYPE_ID: &str = "TArray<EClothColliderFilter>";
}

impl StaticVariant for Vec<Vec<EClothColliderFilter>> {
     const TYPE_ID: &str = "TArray<TArray<EClothColliderFilter>>";
}

impl Variant for EClothColliderFilter {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EClothColliderFilter")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EClothColliderFilter".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EClothColliderFilter>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EClothColliderFilter>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EClothColliderFilter>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EClothStretchConstrainType {
    eClothBendConstrainType_Anchor,
    eClothBendConstrainType_LRA,
    eClothBendConstrainType_None,
}

impl Aligned for EClothStretchConstrainType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EClothStretchConstrainType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eClothBendConstrainType_Anchor => 0i32,
            Self::eClothBendConstrainType_LRA => 1i32,
            Self::eClothBendConstrainType_None => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EClothStretchConstrainType {
     const TYPE_ID: &str = "EClothStretchConstrainType";
}

impl StaticVariant for Vec<EClothStretchConstrainType> {
     const TYPE_ID: &str = "TArray<EClothStretchConstrainType>";
}

impl StaticVariant for Vec<Vec<EClothStretchConstrainType>> {
     const TYPE_ID: &str = "TArray<TArray<EClothStretchConstrainType>>";
}

impl Variant for EClothStretchConstrainType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EClothStretchConstrainType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EClothStretchConstrainType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EClothStretchConstrainType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EClothStretchConstrainType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EClothStretchConstrainType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECollidableLayer {
    eCollLayer_COLLIDE_WITH_ALL,
    eCollLayer_STATIC_COLLIDABLES_ONLY,
    eCollLayer_DYNAMIC_COLLIDABLES_ONLY,
    eCollLayer_STAIRS,
    eCollLayer_SHOT_ONLY_COLLISION,
    eCollLayer_DYNAMIC_TRASH_COLLIDABLES,
    eCollLayer_KINEMATIC_COLLIDABLES_ONLY,
    eCollLayer_STATIC_COLLIDABLES_ONLY_TRANSPARENT,
    eCollLayer_DYNAMIC_COLLIDABLES_ONLY_TRANSPARENT,
    eCollLayer_KINEMATIC_COLLIDABLES_ONLY_TRANSPARENT,
    eCollLayer_STAIRS_STEPS,
    eCollLayer_STAIRS_SLOPE,
    eCollLayer_HERO_PROXY,
    eCollLayer_ACTOR_PROXY,
    eCollLayer_HERO_VR,
    eCollLayer_CLIP,
    eCollLayer_ACTOR_RAGDOLL,
    eCollLayer_CROWD_RAGDOLL,
    eCollLayer_LEDGE_ANCHOR,
    eCollLayer_ACTOR_DYN_BODY,
    eCollLayer_HERO_DYN_BODY,
    eCollLayer_ITEMS,
    eCollLayer_WEAPONS,
    eCollLayer_COLLISION_VOLUME_HITMAN_ON,
    eCollLayer_COLLISION_VOLUME_HITMAN_OFF,
    eCollLayer_DYNAMIC_COLLIDABLES_ONLY_NO_CHARACTER,
    eCollLayer_DYNAMIC_COLLIDABLES_ONLY_NO_CHARACTER_TRANSPARENT,
    eCollLayer_COLLIDE_WITH_STATIC_ONLY,
    eCollLayer_AI_VISION_BLOCKER,
    eCollLayer_AI_VISION_BLOCKER_AMBIENT_ONLY,
    eCollayer_UNUSED_LAST,
}

impl Aligned for ECollidableLayer {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECollidableLayer {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCollLayer_COLLIDE_WITH_ALL => 0i32,
            Self::eCollLayer_STATIC_COLLIDABLES_ONLY => 1i32,
            Self::eCollLayer_DYNAMIC_COLLIDABLES_ONLY => 2i32,
            Self::eCollLayer_STAIRS => 3i32,
            Self::eCollLayer_SHOT_ONLY_COLLISION => 4i32,
            Self::eCollLayer_DYNAMIC_TRASH_COLLIDABLES => 5i32,
            Self::eCollLayer_KINEMATIC_COLLIDABLES_ONLY => 6i32,
            Self::eCollLayer_STATIC_COLLIDABLES_ONLY_TRANSPARENT => 7i32,
            Self::eCollLayer_DYNAMIC_COLLIDABLES_ONLY_TRANSPARENT => 8i32,
            Self::eCollLayer_KINEMATIC_COLLIDABLES_ONLY_TRANSPARENT => 9i32,
            Self::eCollLayer_STAIRS_STEPS => 10i32,
            Self::eCollLayer_STAIRS_SLOPE => 11i32,
            Self::eCollLayer_HERO_PROXY => 12i32,
            Self::eCollLayer_ACTOR_PROXY => 13i32,
            Self::eCollLayer_HERO_VR => 14i32,
            Self::eCollLayer_CLIP => 15i32,
            Self::eCollLayer_ACTOR_RAGDOLL => 16i32,
            Self::eCollLayer_CROWD_RAGDOLL => 17i32,
            Self::eCollLayer_LEDGE_ANCHOR => 18i32,
            Self::eCollLayer_ACTOR_DYN_BODY => 19i32,
            Self::eCollLayer_HERO_DYN_BODY => 20i32,
            Self::eCollLayer_ITEMS => 21i32,
            Self::eCollLayer_WEAPONS => 22i32,
            Self::eCollLayer_COLLISION_VOLUME_HITMAN_ON => 23i32,
            Self::eCollLayer_COLLISION_VOLUME_HITMAN_OFF => 24i32,
            Self::eCollLayer_DYNAMIC_COLLIDABLES_ONLY_NO_CHARACTER => 25i32,
            Self::eCollLayer_DYNAMIC_COLLIDABLES_ONLY_NO_CHARACTER_TRANSPARENT => 26i32,
            Self::eCollLayer_COLLIDE_WITH_STATIC_ONLY => 27i32,
            Self::eCollLayer_AI_VISION_BLOCKER => 28i32,
            Self::eCollLayer_AI_VISION_BLOCKER_AMBIENT_ONLY => 29i32,
            Self::eCollayer_UNUSED_LAST => 30i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollidableLayer {
     const TYPE_ID: &str = "ECollidableLayer";
}

impl StaticVariant for Vec<ECollidableLayer> {
     const TYPE_ID: &str = "TArray<ECollidableLayer>";
}

impl StaticVariant for Vec<Vec<ECollidableLayer>> {
     const TYPE_ID: &str = "TArray<TArray<ECollidableLayer>>";
}

impl Variant for ECollidableLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollidableLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollidableLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollidableLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollidableLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollidableLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECollidableShape {
    ECOLLIDABLESHAPE_SPHERE,
    ECOLLIDABLESHAPE_CAPSULE,
    ECOLLIDABLESHAPE_BOX,
}

impl Aligned for ECollidableShape {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECollidableShape {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECOLLIDABLESHAPE_SPHERE => 0i32,
            Self::ECOLLIDABLESHAPE_CAPSULE => 1i32,
            Self::ECOLLIDABLESHAPE_BOX => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollidableShape {
     const TYPE_ID: &str = "ECollidableShape";
}

impl StaticVariant for Vec<ECollidableShape> {
     const TYPE_ID: &str = "TArray<ECollidableShape>";
}

impl StaticVariant for Vec<Vec<ECollidableShape>> {
     const TYPE_ID: &str = "TArray<TArray<ECollidableShape>>";
}

impl Variant for ECollidableShape {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollidableShape")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollidableShape".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollidableShape>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollidableShape>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollidableShape>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECollidablesType {
    ECST_STATIC_AND_DYNAMIC,
    ECST_STATIC_ONLY,
    ECST_DYNAMIC_ONLY,
}

impl Aligned for ECollidablesType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECollidablesType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECST_STATIC_AND_DYNAMIC => 0i32,
            Self::ECST_STATIC_ONLY => 1i32,
            Self::ECST_DYNAMIC_ONLY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollidablesType {
     const TYPE_ID: &str = "ECollidablesType";
}

impl StaticVariant for Vec<ECollidablesType> {
     const TYPE_ID: &str = "TArray<ECollidablesType>";
}

impl StaticVariant for Vec<Vec<ECollidablesType>> {
     const TYPE_ID: &str = "TArray<TArray<ECollidablesType>>";
}

impl Variant for ECollidablesType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollidablesType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollidablesType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollidablesType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollidablesType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollidablesType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECollisionNotifyGroup {
    eCollisionNotifyGroup_Default,
    eCollisionNotifyGroup_CollisionListener,
    eCollisionNotifyGroup_PhysicsEntity,
    eCollisionNotifyGroup_DontNotify,
    eCollisionNotifyGroup_ForceNotify,
}

impl Aligned for ECollisionNotifyGroup {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECollisionNotifyGroup {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCollisionNotifyGroup_Default => 0i8,
            Self::eCollisionNotifyGroup_CollisionListener => 1i8,
            Self::eCollisionNotifyGroup_PhysicsEntity => 2i8,
            Self::eCollisionNotifyGroup_DontNotify => 3i8,
            Self::eCollisionNotifyGroup_ForceNotify => 4i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollisionNotifyGroup {
     const TYPE_ID: &str = "ECollisionNotifyGroup";
}

impl StaticVariant for Vec<ECollisionNotifyGroup> {
     const TYPE_ID: &str = "TArray<ECollisionNotifyGroup>";
}

impl StaticVariant for Vec<Vec<ECollisionNotifyGroup>> {
     const TYPE_ID: &str = "TArray<TArray<ECollisionNotifyGroup>>";
}

impl Variant for ECollisionNotifyGroup {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollisionNotifyGroup")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollisionNotifyGroup".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollisionNotifyGroup>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollisionNotifyGroup>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollisionNotifyGroup>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECollisionPriority {
    ECOLLISIONPRIORITY_LOW,
    ECOLLISIONPRIORITY_NORMAL,
    ECOLLISIONPRIORITY_HIGH,
    ECOLLISIONPRIORITY_CRITICAL,
}

impl Aligned for ECollisionPriority {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECollisionPriority {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECOLLISIONPRIORITY_LOW => 0i8,
            Self::ECOLLISIONPRIORITY_NORMAL => 1i8,
            Self::ECOLLISIONPRIORITY_HIGH => 2i8,
            Self::ECOLLISIONPRIORITY_CRITICAL => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollisionPriority {
     const TYPE_ID: &str = "ECollisionPriority";
}

impl StaticVariant for Vec<ECollisionPriority> {
     const TYPE_ID: &str = "TArray<ECollisionPriority>";
}

impl StaticVariant for Vec<Vec<ECollisionPriority>> {
     const TYPE_ID: &str = "TArray<TArray<ECollisionPriority>>";
}

impl Variant for ECollisionPriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollisionPriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollisionPriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollisionPriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollisionPriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollisionPriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ECollisionResponse {
    REFLECT_VELOCITY,
    SLIDE_ON,
    STAY_AT_COLLISION_POINT,
    CUSTOM,
}

impl Aligned for ECollisionResponse {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ECollisionResponse {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::REFLECT_VELOCITY => 0i8,
            Self::SLIDE_ON => 1i8,
            Self::STAY_AT_COLLISION_POINT => 2i8,
            Self::CUSTOM => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECollisionResponse {
     const TYPE_ID: &str = "ECollisionResponse";
}

impl StaticVariant for Vec<ECollisionResponse> {
     const TYPE_ID: &str = "TArray<ECollisionResponse>";
}

impl StaticVariant for Vec<Vec<ECollisionResponse>> {
     const TYPE_ID: &str = "TArray<TArray<ECollisionResponse>>";
}

impl Variant for ECollisionResponse {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECollisionResponse")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECollisionResponse".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECollisionResponse>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECollisionResponse>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECollisionResponse>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECombatZoneState {
    CZS_Inactive,
    CZS_Triggered,
    CZS_Engaged,
}

impl Aligned for ECombatZoneState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECombatZoneState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CZS_Inactive => 0i32,
            Self::CZS_Triggered => 1i32,
            Self::CZS_Engaged => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECombatZoneState {
     const TYPE_ID: &str = "ECombatZoneState";
}

impl StaticVariant for Vec<ECombatZoneState> {
     const TYPE_ID: &str = "TArray<ECombatZoneState>";
}

impl StaticVariant for Vec<Vec<ECombatZoneState>> {
     const TYPE_ID: &str = "TArray<TArray<ECombatZoneState>>";
}

impl Variant for ECombatZoneState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECombatZoneState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECombatZoneState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECombatZoneState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECombatZoneState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECombatZoneState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECommunicationBarMessage {
    ECBM_Unknown,
    ECBM_Spotted,
    ECBM_Frisking,
    ECBM_HostileArea,
    ECBM_InvestigatingArea,
    ECBM_Clear,
    ECBM_Suspicious,
    ECBM_Alerted,
    ECBM_Hunting,
    ECBM_Arresting,
    ECBM_Engaging,
    ECBM_Hostile,
    ECBM_IdentityKnown,
    ECBM_Agitated,
    ECBM_VipRunsToSafeArea,
    ECBM_VipEscaping,
    ECBM_BodyFound,
    ECBM_GunshotHeard,
    ECBM_CloseCombatHeard,
    ECBM_CrimeNoticed,
    ECBM_BulletImpactNoticed,
    ECBM_SpottedByCamera,
    ECBM_UnconsciousWitness,
}

impl Aligned for ECommunicationBarMessage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECommunicationBarMessage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECBM_Unknown => 0i32,
            Self::ECBM_Spotted => 1i32,
            Self::ECBM_Frisking => 2i32,
            Self::ECBM_HostileArea => 3i32,
            Self::ECBM_InvestigatingArea => 4i32,
            Self::ECBM_Clear => 5i32,
            Self::ECBM_Suspicious => 6i32,
            Self::ECBM_Alerted => 7i32,
            Self::ECBM_Hunting => 8i32,
            Self::ECBM_Arresting => 9i32,
            Self::ECBM_Engaging => 10i32,
            Self::ECBM_Hostile => 11i32,
            Self::ECBM_IdentityKnown => 12i32,
            Self::ECBM_Agitated => 13i32,
            Self::ECBM_VipRunsToSafeArea => 14i32,
            Self::ECBM_VipEscaping => 15i32,
            Self::ECBM_BodyFound => 16i32,
            Self::ECBM_GunshotHeard => 17i32,
            Self::ECBM_CloseCombatHeard => 18i32,
            Self::ECBM_CrimeNoticed => 19i32,
            Self::ECBM_BulletImpactNoticed => 20i32,
            Self::ECBM_SpottedByCamera => 21i32,
            Self::ECBM_UnconsciousWitness => 22i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECommunicationBarMessage {
     const TYPE_ID: &str = "ECommunicationBarMessage";
}

impl StaticVariant for Vec<ECommunicationBarMessage> {
     const TYPE_ID: &str = "TArray<ECommunicationBarMessage>";
}

impl StaticVariant for Vec<Vec<ECommunicationBarMessage>> {
     const TYPE_ID: &str = "TArray<TArray<ECommunicationBarMessage>>";
}

impl Variant for ECommunicationBarMessage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECommunicationBarMessage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECommunicationBarMessage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECommunicationBarMessage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECommunicationBarMessage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECommunicationBarMessage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECommunicationBarState {
    COMMUNICATION_BAR_NONE,
    COMMUNICATION_BAR_CLEAR,
    COMMUNICATION_BAR_SEARCHING,
    COMMUNICATION_BAR_SUSPICIOUS,
    COMMUNICATION_BAR_HUNTING,
    COMMUNICATION_BAR_HOSTILE,
    COMMUNICATION_BAR_BLOOD_FOUND,
    COMMUNICATION_BAR_BODY_FOUND,
    COMMUNICATION_BAR_GUARDS_ALERTED,
    COMMUNICATION_BAR_BACKUP_ARRIVED,
}

impl Aligned for ECommunicationBarState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECommunicationBarState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::COMMUNICATION_BAR_NONE => 0i32,
            Self::COMMUNICATION_BAR_CLEAR => 1i32,
            Self::COMMUNICATION_BAR_SEARCHING => 2i32,
            Self::COMMUNICATION_BAR_SUSPICIOUS => 3i32,
            Self::COMMUNICATION_BAR_HUNTING => 4i32,
            Self::COMMUNICATION_BAR_HOSTILE => 5i32,
            Self::COMMUNICATION_BAR_BLOOD_FOUND => 6i32,
            Self::COMMUNICATION_BAR_BODY_FOUND => 7i32,
            Self::COMMUNICATION_BAR_GUARDS_ALERTED => 8i32,
            Self::COMMUNICATION_BAR_BACKUP_ARRIVED => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECommunicationBarState {
     const TYPE_ID: &str = "ECommunicationBarState";
}

impl StaticVariant for Vec<ECommunicationBarState> {
     const TYPE_ID: &str = "TArray<ECommunicationBarState>";
}

impl StaticVariant for Vec<Vec<ECommunicationBarState>> {
     const TYPE_ID: &str = "TArray<TArray<ECommunicationBarState>>";
}

impl Variant for ECommunicationBarState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECommunicationBarState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECommunicationBarState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECommunicationBarState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECommunicationBarState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECommunicationBarState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECompiledBehaviorType {
    BT_ConditionScope,
    BT_Random,
    BT_Match,
    BT_Sequence,
    BT_BEHAVIORS_BEGIN,
    BT_Dummy,
    BT_Dummy2,
    BT_Error,
    BT_Wait,
    BT_WaitForStanding,
    BT_WaitBasedOnDistanceToTarget,
    BT_WaitForItemHandled,
    BT_AbandonOrder,
    BT_CompleteOrder,
    BT_PlayAct,
    BT_ConfiguredAct,
    BT_PlayReaction,
    BT_SimpleReaction,
    BT_SituationAct,
    BT_SituationApproach,
    BT_SituationGetHelp,
    BT_SituationFace,
    BT_SituationConversation,
    BT_Holster,
    BT_SpeakWait,
    BT_SpeakWaitWithFallbackIfAlone,
    BT_ConfiguredSpeak,
    BT_ConditionedConfiguredSpeak,
    BT_ConditionedConfiguredAct,
    BT_SpeakCustomOrDefaultDistractionAckSoundDef,
    BT_SpeakCustomOrDefaultDistractionInvestigationSoundDef,
    BT_SpeakCustomOrDefaultDistractionStndSoundDef,
    BT_Pickup,
    BT_Drop,
    BT_PlayConversation,
    BT_PlayAnimation,
    BT_MoveToLocation,
    BT_MoveToTargetKnownPosition,
    BT_MoveToTargetActualPosition,
    BT_MoveToInteraction,
    BT_MoveToNPC,
    BT_FollowTargetKnownPosition,
    BT_FollowTargetActualPosition,
    BT_PickUpItem,
    BT_GrabItem,
    BT_PutDownItem,
    BT_Search,
    BT_LimitedSearch,
    BT_MoveTo,
    BT_Reposition,
    BT_SituationMoveTo,
    BT_FormationMove,
    BT_SituationJumpTo,
    BT_AmbientWalk,
    BT_AmbientStand,
    BT_CrowdAmbientStand,
    BT_AmbientItemUse,
    BT_AmbientLook,
    BT_Act,
    BT_Patrol,
    BT_MoveToPosition,
    BT_AlertedStand,
    BT_AlertedDebug,
    BT_AttentionToPerson,
    BT_StunnedByFlashGrenade,
    BT_CuriousIdle,
    BT_InvestigateWeapon,
    BT_DeliverWeapon,
    BT_RecoverUnconscious,
    BT_GetOutfit,
    BT_RadioCall,
    BT_EscortOut,
    BT_StashItem,
    BT_CautiousSearchPosition,
    BT_LockdownWarning,
    BT_WakeUpUnconscious,
    BT_DeadBodyInvestigate,
    BT_GuardDeadBody,
    BT_DragDeadBody,
    BT_CuriousBystander,
    BT_DeadBodyBystander,
    BT_StandOffArrest,
    BT_StandOffReposition,
    BT_StandAndAim,
    BT_CloseCombat,
    BT_MoveToCloseCombat,
    BT_MoveAwayFromCloseCombat,
    BT_CoverFightSeasonTwo,
    BT_ShootFromPosition,
    BT_StandAndShoot,
    BT_CheckLastPosition,
    BT_ProtoSearchIdle,
    BT_ProtoApproachSearchArea,
    BT_ProtoSearchPosition,
    BT_ShootTarget,
    BT_TriggerAlarm,
    BT_MoveInCover,
    BT_MoveToCover,
    BT_HomeAttackOrigin,
    BT_Shoot,
    BT_Aim,
    BT_MoveToRandomNeighbourNode,
    BT_MoveToRandomNeighbourNodeAiming,
    BT_MoveToAndPlayCombatPositionAct,
    BT_MoveToAimingAndPlayCombatPositionAct,
    BT_PlayJumpyReaction,
    BT_JumpyInvestigation,
    BT_AgitatedPatrol,
    BT_AgitatedGuard,
    BT_HeroEscort,
    BT_Escort,
    BT_ControlledFormationMove,
    BT_EscortSearch,
    BT_LeadEscort,
    BT_LeadEscort2,
    BT_AimReaction,
    BT_FollowHitman,
    BT_RideTheLightning,
    BT_Scared,
    BT_Flee,
    BT_AgitatedBystander,
    BT_SentryFrisk,
    BT_SentryIdle,
    BT_SentryWarning,
    BT_SentryCheckItem,
    BT_VIPScared,
    BT_VIPSafeRoomTrespasser,
    BT_DefendVIP,
    BT_CautiousVIP,
    BT_CautiousGuardVIP,
    BT_InfectedConfused,
    BT_EnterInfected,
    BT_CureInfected,
    BT_SickActInfected,
    BT_Smart,
    BT_Controlled,
    BT_SpeakTest,
    BT_Conversation,
    BT_RunToHelp,
    BT_WaitForDialog,
    BT_WaitForConfiguredAct,
    BT_TestFlashbangGrenadeThrow,
    BT_BEHAVIORS_END,
    BT_COMMANDS_BEGIN,
    BT_RenewEvent,
    BT_ExpireEvent,
    BT_ExpireEvents,
    BT_SetEventHandled,
    BT_RenewSharedEvent,
    BT_ExpireSharedEvent,
    BT_ExpireAllEvents,
    BT_CreateOrJoinSituation,
    BT_JoinSituation,
    BT_ForceActorToJoinSituation,
    BT_JoinSituationWithActor,
    BT_LeaveSituation,
    BT_Escalate,
    BT_GotoPhase,
    BT_RenewGoal,
    BT_ExpireGoal,
    BT_RenewGoalOf,
    BT_ExpireGoalOf,
    BT_SetTension,
    BT_TriggerSpotted,
    BT_CopyKnownLocation,
    BT_UpdateKnownLocation,
    BT_TransferKnownObjectPositions,
    BT_WitnessAttack,
    BT_Speak,
    BT_StartDynamicEnforcer,
    BT_StopDynamicEnforcer,
    BT_StartRangeBasedDynamicEnforcer,
    BT_StopRangeBasedDynamicEnforcerForLocation,
    BT_StopRangeBasedDynamicEnforcer,
    BT_SetDistracted,
    BT_IgnoreAllDistractionsExceptTheNewest,
    BT_IgnoreDistractions,
    BT_PerceptibleEntityNotifyWillReact,
    BT_PerceptibleEntityNotifyReacted,
    BT_PerceptibleEntityNotifyInvestigating,
    BT_PerceptibleEntityNotifyInvestigated,
    BT_PerceptibleEntityNotifyTerminate,
    BT_LeaveDistractionAssistantRole,
    BT_LeaveDistractionAssitingGuardRole,
    BT_RequestSuitcaseAssistanceOverRadio,
    BT_RequestSuitcaseAssistanceFaceToFace,
    BT_ExpireArrestReasons,
    BT_SetDialogSwitch_NPCID,
    BT_InfectedAssignToFollowPlayer,
    BT_InfectedRemoveFromFollowPlayer,
    BT_Log,
    BT_COMMANDS_END,
    BT_Invalid,
}

impl Aligned for ECompiledBehaviorType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECompiledBehaviorType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BT_ConditionScope => 0i32,
            Self::BT_Random => 1i32,
            Self::BT_Match => 2i32,
            Self::BT_Sequence => 3i32,
            Self::BT_BEHAVIORS_BEGIN => 4i32,
            Self::BT_Dummy => 4i32,
            Self::BT_Dummy2 => 5i32,
            Self::BT_Error => 6i32,
            Self::BT_Wait => 7i32,
            Self::BT_WaitForStanding => 8i32,
            Self::BT_WaitBasedOnDistanceToTarget => 9i32,
            Self::BT_WaitForItemHandled => 10i32,
            Self::BT_AbandonOrder => 11i32,
            Self::BT_CompleteOrder => 12i32,
            Self::BT_PlayAct => 13i32,
            Self::BT_ConfiguredAct => 14i32,
            Self::BT_PlayReaction => 15i32,
            Self::BT_SimpleReaction => 16i32,
            Self::BT_SituationAct => 17i32,
            Self::BT_SituationApproach => 18i32,
            Self::BT_SituationGetHelp => 19i32,
            Self::BT_SituationFace => 20i32,
            Self::BT_SituationConversation => 21i32,
            Self::BT_Holster => 22i32,
            Self::BT_SpeakWait => 23i32,
            Self::BT_SpeakWaitWithFallbackIfAlone => 24i32,
            Self::BT_ConfiguredSpeak => 25i32,
            Self::BT_ConditionedConfiguredSpeak => 26i32,
            Self::BT_ConditionedConfiguredAct => 27i32,
            Self::BT_SpeakCustomOrDefaultDistractionAckSoundDef => 28i32,
            Self::BT_SpeakCustomOrDefaultDistractionInvestigationSoundDef => 29i32,
            Self::BT_SpeakCustomOrDefaultDistractionStndSoundDef => 30i32,
            Self::BT_Pickup => 31i32,
            Self::BT_Drop => 32i32,
            Self::BT_PlayConversation => 33i32,
            Self::BT_PlayAnimation => 34i32,
            Self::BT_MoveToLocation => 35i32,
            Self::BT_MoveToTargetKnownPosition => 36i32,
            Self::BT_MoveToTargetActualPosition => 37i32,
            Self::BT_MoveToInteraction => 38i32,
            Self::BT_MoveToNPC => 39i32,
            Self::BT_FollowTargetKnownPosition => 40i32,
            Self::BT_FollowTargetActualPosition => 41i32,
            Self::BT_PickUpItem => 42i32,
            Self::BT_GrabItem => 43i32,
            Self::BT_PutDownItem => 44i32,
            Self::BT_Search => 45i32,
            Self::BT_LimitedSearch => 46i32,
            Self::BT_MoveTo => 47i32,
            Self::BT_Reposition => 48i32,
            Self::BT_SituationMoveTo => 49i32,
            Self::BT_FormationMove => 50i32,
            Self::BT_SituationJumpTo => 51i32,
            Self::BT_AmbientWalk => 52i32,
            Self::BT_AmbientStand => 53i32,
            Self::BT_CrowdAmbientStand => 54i32,
            Self::BT_AmbientItemUse => 55i32,
            Self::BT_AmbientLook => 56i32,
            Self::BT_Act => 57i32,
            Self::BT_Patrol => 58i32,
            Self::BT_MoveToPosition => 59i32,
            Self::BT_AlertedStand => 60i32,
            Self::BT_AlertedDebug => 61i32,
            Self::BT_AttentionToPerson => 62i32,
            Self::BT_StunnedByFlashGrenade => 63i32,
            Self::BT_CuriousIdle => 64i32,
            Self::BT_InvestigateWeapon => 65i32,
            Self::BT_DeliverWeapon => 66i32,
            Self::BT_RecoverUnconscious => 67i32,
            Self::BT_GetOutfit => 68i32,
            Self::BT_RadioCall => 69i32,
            Self::BT_EscortOut => 70i32,
            Self::BT_StashItem => 71i32,
            Self::BT_CautiousSearchPosition => 72i32,
            Self::BT_LockdownWarning => 73i32,
            Self::BT_WakeUpUnconscious => 74i32,
            Self::BT_DeadBodyInvestigate => 75i32,
            Self::BT_GuardDeadBody => 76i32,
            Self::BT_DragDeadBody => 77i32,
            Self::BT_CuriousBystander => 78i32,
            Self::BT_DeadBodyBystander => 79i32,
            Self::BT_StandOffArrest => 80i32,
            Self::BT_StandOffReposition => 81i32,
            Self::BT_StandAndAim => 82i32,
            Self::BT_CloseCombat => 83i32,
            Self::BT_MoveToCloseCombat => 84i32,
            Self::BT_MoveAwayFromCloseCombat => 85i32,
            Self::BT_CoverFightSeasonTwo => 86i32,
            Self::BT_ShootFromPosition => 87i32,
            Self::BT_StandAndShoot => 88i32,
            Self::BT_CheckLastPosition => 89i32,
            Self::BT_ProtoSearchIdle => 90i32,
            Self::BT_ProtoApproachSearchArea => 91i32,
            Self::BT_ProtoSearchPosition => 92i32,
            Self::BT_ShootTarget => 93i32,
            Self::BT_TriggerAlarm => 94i32,
            Self::BT_MoveInCover => 95i32,
            Self::BT_MoveToCover => 96i32,
            Self::BT_HomeAttackOrigin => 97i32,
            Self::BT_Shoot => 98i32,
            Self::BT_Aim => 99i32,
            Self::BT_MoveToRandomNeighbourNode => 100i32,
            Self::BT_MoveToRandomNeighbourNodeAiming => 101i32,
            Self::BT_MoveToAndPlayCombatPositionAct => 102i32,
            Self::BT_MoveToAimingAndPlayCombatPositionAct => 103i32,
            Self::BT_PlayJumpyReaction => 104i32,
            Self::BT_JumpyInvestigation => 105i32,
            Self::BT_AgitatedPatrol => 106i32,
            Self::BT_AgitatedGuard => 107i32,
            Self::BT_HeroEscort => 108i32,
            Self::BT_Escort => 109i32,
            Self::BT_ControlledFormationMove => 110i32,
            Self::BT_EscortSearch => 111i32,
            Self::BT_LeadEscort => 112i32,
            Self::BT_LeadEscort2 => 113i32,
            Self::BT_AimReaction => 114i32,
            Self::BT_FollowHitman => 115i32,
            Self::BT_RideTheLightning => 116i32,
            Self::BT_Scared => 117i32,
            Self::BT_Flee => 118i32,
            Self::BT_AgitatedBystander => 119i32,
            Self::BT_SentryFrisk => 120i32,
            Self::BT_SentryIdle => 121i32,
            Self::BT_SentryWarning => 122i32,
            Self::BT_SentryCheckItem => 123i32,
            Self::BT_VIPScared => 124i32,
            Self::BT_VIPSafeRoomTrespasser => 125i32,
            Self::BT_DefendVIP => 126i32,
            Self::BT_CautiousVIP => 127i32,
            Self::BT_CautiousGuardVIP => 128i32,
            Self::BT_InfectedConfused => 129i32,
            Self::BT_EnterInfected => 130i32,
            Self::BT_CureInfected => 131i32,
            Self::BT_SickActInfected => 132i32,
            Self::BT_Smart => 133i32,
            Self::BT_Controlled => 134i32,
            Self::BT_SpeakTest => 135i32,
            Self::BT_Conversation => 136i32,
            Self::BT_RunToHelp => 137i32,
            Self::BT_WaitForDialog => 138i32,
            Self::BT_WaitForConfiguredAct => 139i32,
            Self::BT_TestFlashbangGrenadeThrow => 140i32,
            Self::BT_BEHAVIORS_END => 141i32,
            Self::BT_COMMANDS_BEGIN => 142i32,
            Self::BT_RenewEvent => 142i32,
            Self::BT_ExpireEvent => 143i32,
            Self::BT_ExpireEvents => 144i32,
            Self::BT_SetEventHandled => 145i32,
            Self::BT_RenewSharedEvent => 146i32,
            Self::BT_ExpireSharedEvent => 147i32,
            Self::BT_ExpireAllEvents => 148i32,
            Self::BT_CreateOrJoinSituation => 149i32,
            Self::BT_JoinSituation => 150i32,
            Self::BT_ForceActorToJoinSituation => 151i32,
            Self::BT_JoinSituationWithActor => 152i32,
            Self::BT_LeaveSituation => 153i32,
            Self::BT_Escalate => 154i32,
            Self::BT_GotoPhase => 155i32,
            Self::BT_RenewGoal => 156i32,
            Self::BT_ExpireGoal => 157i32,
            Self::BT_RenewGoalOf => 158i32,
            Self::BT_ExpireGoalOf => 159i32,
            Self::BT_SetTension => 160i32,
            Self::BT_TriggerSpotted => 161i32,
            Self::BT_CopyKnownLocation => 162i32,
            Self::BT_UpdateKnownLocation => 163i32,
            Self::BT_TransferKnownObjectPositions => 164i32,
            Self::BT_WitnessAttack => 165i32,
            Self::BT_Speak => 166i32,
            Self::BT_StartDynamicEnforcer => 167i32,
            Self::BT_StopDynamicEnforcer => 168i32,
            Self::BT_StartRangeBasedDynamicEnforcer => 169i32,
            Self::BT_StopRangeBasedDynamicEnforcerForLocation => 170i32,
            Self::BT_StopRangeBasedDynamicEnforcer => 171i32,
            Self::BT_SetDistracted => 172i32,
            Self::BT_IgnoreAllDistractionsExceptTheNewest => 173i32,
            Self::BT_IgnoreDistractions => 174i32,
            Self::BT_PerceptibleEntityNotifyWillReact => 175i32,
            Self::BT_PerceptibleEntityNotifyReacted => 176i32,
            Self::BT_PerceptibleEntityNotifyInvestigating => 177i32,
            Self::BT_PerceptibleEntityNotifyInvestigated => 178i32,
            Self::BT_PerceptibleEntityNotifyTerminate => 179i32,
            Self::BT_LeaveDistractionAssistantRole => 180i32,
            Self::BT_LeaveDistractionAssitingGuardRole => 181i32,
            Self::BT_RequestSuitcaseAssistanceOverRadio => 182i32,
            Self::BT_RequestSuitcaseAssistanceFaceToFace => 183i32,
            Self::BT_ExpireArrestReasons => 184i32,
            Self::BT_SetDialogSwitch_NPCID => 185i32,
            Self::BT_InfectedAssignToFollowPlayer => 186i32,
            Self::BT_InfectedRemoveFromFollowPlayer => 187i32,
            Self::BT_Log => 188i32,
            Self::BT_COMMANDS_END => 189i32,
            Self::BT_Invalid => 190i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECompiledBehaviorType {
     const TYPE_ID: &str = "ECompiledBehaviorType";
}

impl StaticVariant for Vec<ECompiledBehaviorType> {
     const TYPE_ID: &str = "TArray<ECompiledBehaviorType>";
}

impl StaticVariant for Vec<Vec<ECompiledBehaviorType>> {
     const TYPE_ID: &str = "TArray<TArray<ECompiledBehaviorType>>";
}

impl Variant for ECompiledBehaviorType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECompiledBehaviorType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECompiledBehaviorType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECompiledBehaviorType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECompiledBehaviorType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECompiledBehaviorType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECompiledConditionType {
    CT_IsCurrent,
    CT_Current,
    CT_IsExpired,
    CT_HasGoal,
    CT_HasGoalOnTarget,
    CT_HasUnhandledGoal,
    CT_MaxActorsWithGoal,
    CT_MinExpired,
    CT_MaxExpired,
    CT_MinAge,
    CT_MaxAge,
    CT_IsSharedOlder,
    CT_HasLongTermMemory,
    CT_IsSharedEventCurrent,
    CT_SharedEventCurrent,
    CT_IsSharedEventExpired,
    CT_MinSharedEventExpired,
    CT_MaxSharedEventExpired,
    CT_MinSharedEventAge,
    CT_MaxSharedEventAge,
    CT_IsNull,
    CT_IsEqual,
    CT_IsOfType,
    CT_IsOfActorType,
    CT_IsOfActorRank,
    CT_IsOfActorRole,
    CT_IsActorRoleBodyguard,
    CT_IsActorRoleVIP,
    CT_IsActorDeafBlind,
    CT_IsActorAlive,
    CT_IsActorConscious,
    CT_HasConfiguredAct,
    CT_HasConfiguredSpeak,
    CT_IsConfiguredConditionTrue,
    CT_HasTension,
    CT_HasTensionOrHigher,
    CT_IsAIModified,
    CT_HasSameOutfit,
    CT_IsLegal,
    CT_IsItemLegalOnHitman,
    CT_IsItemIllegalOnHitman,
    CT_IsItemSuspiciousOnHitman,
    CT_AreVisibleItemsLegal,
    CT_AreVisibleItemsIllegal,
    CT_AreVisibleItemsSuspicious,
    CT_AreVisibleWeaponsLegal,
    CT_AreVisibleWeaponsIllegal,
    CT_AreVisibleWeaponsSuspicious,
    CT_OnlyLegalWeaponsDropped,
    CT_IllegalWeaponDropped,
    CT_SuspiciousWeaponDropped,
    CT_OnlyLegalItemsDropped,
    CT_IllegalItemDropped,
    CT_SuspiciousItemDropped,
    CT_OnlyLegalWeaponsPickedUp,
    CT_IllegalWeaponPickedUp,
    CT_SuspiciousWeaponPickedUp,
    CT_OnlyLegalItemsPickedUp,
    CT_IllegalItemPickedUp,
    CT_SuspiciousItemPickedUp,
    CT_ThrownBy,
    CT_GetItemBeingThrownBy,
    CT_Owner,
    CT_PreviousOwner,
    CT_IsOwner,
    CT_IsPreviousOwner,
    CT_GetItemDroppedBy,
    CT_CausedBy,
    CT_BeingPickedUpBy,
    CT_IsSuitcase,
    CT_IsNotSuitcase,
    CT_IsVisiblyPerceptible,
    CT_HasCustomInvestigationAckSoundDef,
    CT_FindStashPointsForItem,
    CT_MinDistance,
    CT_MaxDistance,
    CT_MinActualDistance,
    CT_MinActualDistance2D,
    CT_MaxActualDistance,
    CT_MaxActualDistance2D,
    CT_ActualInsideSlice,
    CT_MaxDistanceToKnownPosition,
    CT_IsDistanceFromKnownToActualGreaterThan,
    CT_IsDistanceFromKnownToActualLessThan,
    CT_InSituation,
    CT_IsActorInSituation,
    CT_SituationTarget,
    CT_SituationHuntTarget,
    CT_IsSituationTarget,
    CT_SituationFromActors,
    CT_ActorsNotInSituation,
    CT_SituationFromTarget,
    CT_TargetsNotInSituation,
    CT_MaxSituationAge,
    CT_MinSituationAge,
    CT_InPhase,
    CT_MinPhaseAge,
    CT_MaxPhaseAge,
    CT_IsOrderInvalid,
    CT_IsSituationOlderThanSharedEvent,
    CT_HasOrder,
    CT_HasPendingOrder,
    CT_IsCombatDisabled,
    CT_CanJoinSituation,
    CT_InfectedMayFollowPlayer,
    CT_CanDistractionEscalateTo,
    CT_CanReactToDistractionType,
    CT_CanInvestigateDistraction,
    CT_IsCurrentDistractionTarget,
    CT_IsNotCurrentDistractionTarget,
    CT_IsHighestPriorityTypeToInvestigate,
    CT_IsHighestPriorityTypeToInvestigateFor,
    CT_IsHighestPriorityTypeToReact,
    CT_HasBystanderSomethingElseToInvestigate,
    CT_IsDistractionNewerThanCurrentOne,
    CT_ShouldDistractionDiscardNewOcurrences,
    CT_IsDistractionInterruptableByNewOcurrences,
    CT_IsSameDistractionTypeAsTheCurrentOne,
    CT_IsDistracted,
    CT_HasCustomDistractionAckSoundDef,
    CT_HasCustomDistractionStndSoundDef,
    CT_PerceptibleEntityEndAfterReact,
    CT_PerceptibleEntityEndAfterMoveTo,
    CT_FindSuitcaseAssitanceForCivilian,
    CT_FindSuitcaseAssitanceForSentry,
    CT_IsValidForSuitcaseAssistance,
    CT_SuitcaseAssistanceRequesterFaceToFace,
    CT_SuitcaseAssistanceRequesterRadio,
    CT_IsDistractionTargetBeingHandled,
    CT_CanArrestReasonEscalateTo,
    CT_IsHighestSeverityReasonToArrest,
    CT_Breakpoint,
    CT_Cooldown,
    CT_Trigger,
    CT_IsInSniperIsland,
    CT_SituationIsType,
    CT_IntRuntimeParamEqualsTo,
    CT_IsNewArrestEnabled,
    CT_IsDebugBuild,
    CT_GetRandomFightTarget,
    CT_IsCombatPositionActReady,
    CT_CurrentSetpieceVisualDistractions,
    CT_CurrentSetpieceSoundDistractions,
    CT_AreBehaviorsDisabled,
    CT_IsDifficultyEqual,
    CT_IsDifficultyGreaterOrEqual,
    CT_IsDifficultyLessOrEqual,
    CT_IsSeasonTwoCombatEnabled,
    CT_IsRealCombatSituation,
    CT_RemoveSituationsWithDesiredNumberOfCombatants,
    CT_RemoveCombatSituationsStandingDown,
    CT_CombatSituationsWithDesiredNumberOfCombatants,
    CT_CombatSituationsThatCanDiscardCombatants,
    CT_CombatSituationsStandingDown,
    CT_HasCombatFightOrder,
    CT_IsAccidentDeathContext,
    CT_IsAccidentScaleContext,
    CT_IsAccidentVictimDisposable,
    CT_IsAccidentBystandingGuardSearching,
}

impl Aligned for ECompiledConditionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECompiledConditionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CT_IsCurrent => 0i32,
            Self::CT_Current => 1i32,
            Self::CT_IsExpired => 2i32,
            Self::CT_HasGoal => 3i32,
            Self::CT_HasGoalOnTarget => 4i32,
            Self::CT_HasUnhandledGoal => 5i32,
            Self::CT_MaxActorsWithGoal => 6i32,
            Self::CT_MinExpired => 7i32,
            Self::CT_MaxExpired => 8i32,
            Self::CT_MinAge => 9i32,
            Self::CT_MaxAge => 10i32,
            Self::CT_IsSharedOlder => 11i32,
            Self::CT_HasLongTermMemory => 12i32,
            Self::CT_IsSharedEventCurrent => 13i32,
            Self::CT_SharedEventCurrent => 14i32,
            Self::CT_IsSharedEventExpired => 15i32,
            Self::CT_MinSharedEventExpired => 16i32,
            Self::CT_MaxSharedEventExpired => 17i32,
            Self::CT_MinSharedEventAge => 18i32,
            Self::CT_MaxSharedEventAge => 19i32,
            Self::CT_IsNull => 20i32,
            Self::CT_IsEqual => 21i32,
            Self::CT_IsOfType => 22i32,
            Self::CT_IsOfActorType => 23i32,
            Self::CT_IsOfActorRank => 24i32,
            Self::CT_IsOfActorRole => 25i32,
            Self::CT_IsActorRoleBodyguard => 26i32,
            Self::CT_IsActorRoleVIP => 27i32,
            Self::CT_IsActorDeafBlind => 28i32,
            Self::CT_IsActorAlive => 29i32,
            Self::CT_IsActorConscious => 30i32,
            Self::CT_HasConfiguredAct => 31i32,
            Self::CT_HasConfiguredSpeak => 32i32,
            Self::CT_IsConfiguredConditionTrue => 33i32,
            Self::CT_HasTension => 34i32,
            Self::CT_HasTensionOrHigher => 35i32,
            Self::CT_IsAIModified => 36i32,
            Self::CT_HasSameOutfit => 37i32,
            Self::CT_IsLegal => 38i32,
            Self::CT_IsItemLegalOnHitman => 39i32,
            Self::CT_IsItemIllegalOnHitman => 40i32,
            Self::CT_IsItemSuspiciousOnHitman => 41i32,
            Self::CT_AreVisibleItemsLegal => 42i32,
            Self::CT_AreVisibleItemsIllegal => 43i32,
            Self::CT_AreVisibleItemsSuspicious => 44i32,
            Self::CT_AreVisibleWeaponsLegal => 45i32,
            Self::CT_AreVisibleWeaponsIllegal => 46i32,
            Self::CT_AreVisibleWeaponsSuspicious => 47i32,
            Self::CT_OnlyLegalWeaponsDropped => 48i32,
            Self::CT_IllegalWeaponDropped => 49i32,
            Self::CT_SuspiciousWeaponDropped => 50i32,
            Self::CT_OnlyLegalItemsDropped => 51i32,
            Self::CT_IllegalItemDropped => 52i32,
            Self::CT_SuspiciousItemDropped => 53i32,
            Self::CT_OnlyLegalWeaponsPickedUp => 54i32,
            Self::CT_IllegalWeaponPickedUp => 55i32,
            Self::CT_SuspiciousWeaponPickedUp => 56i32,
            Self::CT_OnlyLegalItemsPickedUp => 57i32,
            Self::CT_IllegalItemPickedUp => 58i32,
            Self::CT_SuspiciousItemPickedUp => 59i32,
            Self::CT_ThrownBy => 60i32,
            Self::CT_GetItemBeingThrownBy => 61i32,
            Self::CT_Owner => 62i32,
            Self::CT_PreviousOwner => 63i32,
            Self::CT_IsOwner => 64i32,
            Self::CT_IsPreviousOwner => 65i32,
            Self::CT_GetItemDroppedBy => 66i32,
            Self::CT_CausedBy => 67i32,
            Self::CT_BeingPickedUpBy => 68i32,
            Self::CT_IsSuitcase => 69i32,
            Self::CT_IsNotSuitcase => 70i32,
            Self::CT_IsVisiblyPerceptible => 71i32,
            Self::CT_HasCustomInvestigationAckSoundDef => 72i32,
            Self::CT_FindStashPointsForItem => 73i32,
            Self::CT_MinDistance => 74i32,
            Self::CT_MaxDistance => 75i32,
            Self::CT_MinActualDistance => 76i32,
            Self::CT_MinActualDistance2D => 77i32,
            Self::CT_MaxActualDistance => 78i32,
            Self::CT_MaxActualDistance2D => 79i32,
            Self::CT_ActualInsideSlice => 80i32,
            Self::CT_MaxDistanceToKnownPosition => 81i32,
            Self::CT_IsDistanceFromKnownToActualGreaterThan => 82i32,
            Self::CT_IsDistanceFromKnownToActualLessThan => 83i32,
            Self::CT_InSituation => 84i32,
            Self::CT_IsActorInSituation => 85i32,
            Self::CT_SituationTarget => 86i32,
            Self::CT_SituationHuntTarget => 87i32,
            Self::CT_IsSituationTarget => 88i32,
            Self::CT_SituationFromActors => 89i32,
            Self::CT_ActorsNotInSituation => 90i32,
            Self::CT_SituationFromTarget => 91i32,
            Self::CT_TargetsNotInSituation => 92i32,
            Self::CT_MaxSituationAge => 93i32,
            Self::CT_MinSituationAge => 94i32,
            Self::CT_InPhase => 95i32,
            Self::CT_MinPhaseAge => 96i32,
            Self::CT_MaxPhaseAge => 97i32,
            Self::CT_IsOrderInvalid => 98i32,
            Self::CT_IsSituationOlderThanSharedEvent => 99i32,
            Self::CT_HasOrder => 100i32,
            Self::CT_HasPendingOrder => 101i32,
            Self::CT_IsCombatDisabled => 102i32,
            Self::CT_CanJoinSituation => 103i32,
            Self::CT_InfectedMayFollowPlayer => 104i32,
            Self::CT_CanDistractionEscalateTo => 105i32,
            Self::CT_CanReactToDistractionType => 106i32,
            Self::CT_CanInvestigateDistraction => 107i32,
            Self::CT_IsCurrentDistractionTarget => 108i32,
            Self::CT_IsNotCurrentDistractionTarget => 109i32,
            Self::CT_IsHighestPriorityTypeToInvestigate => 110i32,
            Self::CT_IsHighestPriorityTypeToInvestigateFor => 111i32,
            Self::CT_IsHighestPriorityTypeToReact => 112i32,
            Self::CT_HasBystanderSomethingElseToInvestigate => 113i32,
            Self::CT_IsDistractionNewerThanCurrentOne => 114i32,
            Self::CT_ShouldDistractionDiscardNewOcurrences => 115i32,
            Self::CT_IsDistractionInterruptableByNewOcurrences => 116i32,
            Self::CT_IsSameDistractionTypeAsTheCurrentOne => 117i32,
            Self::CT_IsDistracted => 118i32,
            Self::CT_HasCustomDistractionAckSoundDef => 119i32,
            Self::CT_HasCustomDistractionStndSoundDef => 120i32,
            Self::CT_PerceptibleEntityEndAfterReact => 121i32,
            Self::CT_PerceptibleEntityEndAfterMoveTo => 122i32,
            Self::CT_FindSuitcaseAssitanceForCivilian => 123i32,
            Self::CT_FindSuitcaseAssitanceForSentry => 124i32,
            Self::CT_IsValidForSuitcaseAssistance => 125i32,
            Self::CT_SuitcaseAssistanceRequesterFaceToFace => 126i32,
            Self::CT_SuitcaseAssistanceRequesterRadio => 127i32,
            Self::CT_IsDistractionTargetBeingHandled => 128i32,
            Self::CT_CanArrestReasonEscalateTo => 129i32,
            Self::CT_IsHighestSeverityReasonToArrest => 130i32,
            Self::CT_Breakpoint => 131i32,
            Self::CT_Cooldown => 132i32,
            Self::CT_Trigger => 133i32,
            Self::CT_IsInSniperIsland => 134i32,
            Self::CT_SituationIsType => 135i32,
            Self::CT_IntRuntimeParamEqualsTo => 136i32,
            Self::CT_IsNewArrestEnabled => 137i32,
            Self::CT_IsDebugBuild => 138i32,
            Self::CT_GetRandomFightTarget => 139i32,
            Self::CT_IsCombatPositionActReady => 140i32,
            Self::CT_CurrentSetpieceVisualDistractions => 141i32,
            Self::CT_CurrentSetpieceSoundDistractions => 142i32,
            Self::CT_AreBehaviorsDisabled => 143i32,
            Self::CT_IsDifficultyEqual => 144i32,
            Self::CT_IsDifficultyGreaterOrEqual => 145i32,
            Self::CT_IsDifficultyLessOrEqual => 146i32,
            Self::CT_IsSeasonTwoCombatEnabled => 147i32,
            Self::CT_IsRealCombatSituation => 148i32,
            Self::CT_RemoveSituationsWithDesiredNumberOfCombatants => 149i32,
            Self::CT_RemoveCombatSituationsStandingDown => 150i32,
            Self::CT_CombatSituationsWithDesiredNumberOfCombatants => 151i32,
            Self::CT_CombatSituationsThatCanDiscardCombatants => 152i32,
            Self::CT_CombatSituationsStandingDown => 153i32,
            Self::CT_HasCombatFightOrder => 154i32,
            Self::CT_IsAccidentDeathContext => 155i32,
            Self::CT_IsAccidentScaleContext => 156i32,
            Self::CT_IsAccidentVictimDisposable => 157i32,
            Self::CT_IsAccidentBystandingGuardSearching => 158i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECompiledConditionType {
     const TYPE_ID: &str = "ECompiledConditionType";
}

impl StaticVariant for Vec<ECompiledConditionType> {
     const TYPE_ID: &str = "TArray<ECompiledConditionType>";
}

impl StaticVariant for Vec<Vec<ECompiledConditionType>> {
     const TYPE_ID: &str = "TArray<TArray<ECompiledConditionType>>";
}

impl Variant for ECompiledConditionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECompiledConditionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECompiledConditionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECompiledConditionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECompiledConditionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECompiledConditionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EConstraintType {
    ECONSTRAINTTYPE_UNKNOWN,
    ECONSTRAINTTYPE_BALL_AND_SOCKET,
    ECONSTRAINTTYPE_HINGE,
    ECONSTRAINTTYPE_FIXED,
    ECONSTRAINTTYPE_DISTANCE,
    ECONSTRAINTTYPE_D6,
}

impl Aligned for EConstraintType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EConstraintType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECONSTRAINTTYPE_UNKNOWN => 0i32,
            Self::ECONSTRAINTTYPE_BALL_AND_SOCKET => 1i32,
            Self::ECONSTRAINTTYPE_HINGE => 2i32,
            Self::ECONSTRAINTTYPE_FIXED => 3i32,
            Self::ECONSTRAINTTYPE_DISTANCE => 4i32,
            Self::ECONSTRAINTTYPE_D6 => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EConstraintType {
     const TYPE_ID: &str = "EConstraintType";
}

impl StaticVariant for Vec<EConstraintType> {
     const TYPE_ID: &str = "TArray<EConstraintType>";
}

impl StaticVariant for Vec<Vec<EConstraintType>> {
     const TYPE_ID: &str = "TArray<TArray<EConstraintType>>";
}

impl Variant for EConstraintType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EConstraintType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EConstraintType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EConstraintType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EConstraintType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EConstraintType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EContinuity {
    C0,
    C1,
    C2,
}

impl Aligned for EContinuity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EContinuity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::C0 => 0i32,
            Self::C1 => 1i32,
            Self::C2 => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EContinuity {
     const TYPE_ID: &str = "EContinuity";
}

impl StaticVariant for Vec<EContinuity> {
     const TYPE_ID: &str = "TArray<EContinuity>";
}

impl StaticVariant for Vec<Vec<EContinuity>> {
     const TYPE_ID: &str = "TArray<TArray<EContinuity>>";
}

impl Variant for EContinuity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EContinuity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EContinuity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EContinuity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EContinuity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EContinuity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EControlButtonName {
    eCN_ABORT,
    eCN_ACTION,
    eCN_ACTIVATE_PROP,
    eCN_AGILITY_DOWN,
    eCN_AGILITY_ENTERWINDOW,
    eCN_AGILITY_SNEAKPASTWINDOW,
    eCN_AGILITY_THROWOVERRAIL,
    eCN_AGILITY_UP,
    eCN_AIM,
    eCN_COVER_ENTER,
    eCN_COVER_TAKEDOWN,
    eCN_COVER_TO_COVER,
    eCN_CROUCH,
    eCN_DRAGBODY,
    eCN_DUMPBODY,
    eCN_FIBERWIRE,
    eCN_INSTINCT,
    eCN_INVENTORY_HOLSTER,
    eCN_INVENTORY_LONGRANGE,
    eCN_MARK_TARGET,
    eCN_CHANGE_AMMO_NEXT,
    eCN_CHANGE_AMMO_PREVIOUS,
    eCN_INVENTORY_PROP,
    eCN_INVENTORY_SHORTRANGE,
    eCN_ITEM_DROP,
    eCN_ITEM_THROW,
    eCN_MELEE_HIT,
    eCN_MELEE_TAKEDOWN,
    eCN_PICKUP,
    eCN_RUN,
    eCN_WALK_SLOW,
    eCN_CONCEAL_RETRIEVE,
    eCN_SB_ACTIVATE,
    eCN_SB_CANCEL,
    eCN_SB_EXECUTE,
    eCN_SB_REMOVETAG,
    eCN_SHOOT,
    eCN_NOTEBOOK,
    eCN_PAUSE,
    eCN_NO_ICON,
}

impl Aligned for EControlButtonName {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EControlButtonName {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCN_ABORT => 0i32,
            Self::eCN_ACTION => 1i32,
            Self::eCN_ACTIVATE_PROP => 2i32,
            Self::eCN_AGILITY_DOWN => 3i32,
            Self::eCN_AGILITY_ENTERWINDOW => 4i32,
            Self::eCN_AGILITY_SNEAKPASTWINDOW => 5i32,
            Self::eCN_AGILITY_THROWOVERRAIL => 6i32,
            Self::eCN_AGILITY_UP => 7i32,
            Self::eCN_AIM => 8i32,
            Self::eCN_COVER_ENTER => 9i32,
            Self::eCN_COVER_TAKEDOWN => 10i32,
            Self::eCN_COVER_TO_COVER => 11i32,
            Self::eCN_CROUCH => 12i32,
            Self::eCN_DRAGBODY => 13i32,
            Self::eCN_DUMPBODY => 14i32,
            Self::eCN_FIBERWIRE => 15i32,
            Self::eCN_INSTINCT => 16i32,
            Self::eCN_INVENTORY_HOLSTER => 17i32,
            Self::eCN_INVENTORY_LONGRANGE => 18i32,
            Self::eCN_MARK_TARGET => 19i32,
            Self::eCN_CHANGE_AMMO_NEXT => 20i32,
            Self::eCN_CHANGE_AMMO_PREVIOUS => 21i32,
            Self::eCN_INVENTORY_PROP => 22i32,
            Self::eCN_INVENTORY_SHORTRANGE => 23i32,
            Self::eCN_ITEM_DROP => 24i32,
            Self::eCN_ITEM_THROW => 25i32,
            Self::eCN_MELEE_HIT => 26i32,
            Self::eCN_MELEE_TAKEDOWN => 27i32,
            Self::eCN_PICKUP => 28i32,
            Self::eCN_RUN => 29i32,
            Self::eCN_WALK_SLOW => 30i32,
            Self::eCN_CONCEAL_RETRIEVE => 31i32,
            Self::eCN_SB_ACTIVATE => 32i32,
            Self::eCN_SB_CANCEL => 33i32,
            Self::eCN_SB_EXECUTE => 34i32,
            Self::eCN_SB_REMOVETAG => 35i32,
            Self::eCN_SHOOT => 36i32,
            Self::eCN_NOTEBOOK => 37i32,
            Self::eCN_PAUSE => 38i32,
            Self::eCN_NO_ICON => 39i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EControlButtonName {
     const TYPE_ID: &str = "EControlButtonName";
}

impl StaticVariant for Vec<EControlButtonName> {
     const TYPE_ID: &str = "TArray<EControlButtonName>";
}

impl StaticVariant for Vec<Vec<EControlButtonName>> {
     const TYPE_ID: &str = "TArray<TArray<EControlButtonName>>";
}

impl Variant for EControlButtonName {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EControlButtonName")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EControlButtonName".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EControlButtonName>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EControlButtonName>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EControlButtonName>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EControllerButton {
    BUTTON_NONE,
    BUTTON_CROSS,
    BUTTON_TRIANGLE,
    BUTTON_SQUARE,
    BUTTON_CIRCLE,
    BUTTON_UP,
    BUTTON_RIGHT,
    BUTTON_DOWN,
    BUTTON_LEFT,
    BUTTON_R1,
    BUTTON_R2,
    BUTTON_R3,
    BUTTON_R_STICK,
    BUTTON_L1,
    BUTTON_L2,
    BUTTON_L3,
    BUTTON_L_STICK,
    BUTTON_START,
    BUTTON_SELECT,
    BUTTON_UP_DOWN,
    BUTTON_LEFT_RIGHT,
    BUTTON_LEFT_RIGHT_UP_DOWN,
    BUTTON_L1_R1,
    BUTTON_L2_R2,
    BUTTON_KEYBOARD,
    BUTTON_ESCAPE,
}

impl Aligned for EControllerButton {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EControllerButton {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BUTTON_NONE => 0i32,
            Self::BUTTON_CROSS => 1i32,
            Self::BUTTON_TRIANGLE => 2i32,
            Self::BUTTON_SQUARE => 3i32,
            Self::BUTTON_CIRCLE => 4i32,
            Self::BUTTON_UP => 5i32,
            Self::BUTTON_RIGHT => 6i32,
            Self::BUTTON_DOWN => 7i32,
            Self::BUTTON_LEFT => 8i32,
            Self::BUTTON_R1 => 9i32,
            Self::BUTTON_R2 => 10i32,
            Self::BUTTON_R3 => 11i32,
            Self::BUTTON_R_STICK => 12i32,
            Self::BUTTON_L1 => 13i32,
            Self::BUTTON_L2 => 14i32,
            Self::BUTTON_L3 => 15i32,
            Self::BUTTON_L_STICK => 16i32,
            Self::BUTTON_START => 17i32,
            Self::BUTTON_SELECT => 18i32,
            Self::BUTTON_UP_DOWN => 19i32,
            Self::BUTTON_LEFT_RIGHT => 20i32,
            Self::BUTTON_LEFT_RIGHT_UP_DOWN => 21i32,
            Self::BUTTON_L1_R1 => 22i32,
            Self::BUTTON_L2_R2 => 23i32,
            Self::BUTTON_KEYBOARD => 24i32,
            Self::BUTTON_ESCAPE => 25i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EControllerButton {
     const TYPE_ID: &str = "EControllerButton";
}

impl StaticVariant for Vec<EControllerButton> {
     const TYPE_ID: &str = "TArray<EControllerButton>";
}

impl StaticVariant for Vec<Vec<EControllerButton>> {
     const TYPE_ID: &str = "TArray<TArray<EControllerButton>>";
}

impl Variant for EControllerButton {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EControllerButton")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EControllerButton".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EControllerButton>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EControllerButton>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EControllerButton>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EConversationID {
    eCI_GuardCivilian_Distraction_Investigation,
    eCI_HearBulletImpact_Distraction_Investigation,
    eCI_HearItemImpact_Distraction_Investigation,
    eCI_HearCarAlarm_Distraction_Investigation,
    eCI_SeeItemToss_Distraction_Investigation,
    eCI_HearRadio_Distraction_Investigation,
    eCI_HearPain_Distraction_Investigation,
    eCI_HearAccident_Distraction_Investigation,
    eCI_HearCuriousItemSound_Distraction_Investigation,
    eCI_HearCuriousSound_Distraction_Investigation,
    eCI_SeeSuspiciousPerceptible_Distraction_Investigation,
    eCI_SeeInterestingItem_Distraction_Investigation,
    eCI_HearFootSteps_Distraction_Investigation,
    eCI_HearAngryDialog_Distraction_Investigation,
    eCI_HearHelpDialog_Distraction_Investigation,
    eCI_HearWarning_Distraction_Investigation,
    eCI_SightInvestigation_Distraction_Investigation,
    eCI_HearBulletImpact_Distraction_StandDown,
    eCI_HearItemImpact_Distraction_StandDown,
    eCI_HearCarAlarm_Distraction_StandDown,
    eCI_SeeItemToss_Distraction_StandDown,
    eCI_HearRadio_Distraction_StandDown,
    eCI_HearPain_Distraction_StandDown,
    eCI_HearAccident_Distraction_StandDown,
    eCI_HearCuriousItemSound_Distraction_StandDown,
    eCI_HearCuriousSound_Distraction_StandDown,
    eCI_SeeSuspiciousPerceptible_Distraction_StandDown,
    eCI_SeeInterestingItem_Distraction_StandDown,
    eCI_HearFootSteps_Distraction_StandDown,
    eCI_HearAngryDialog_Distraction_StandDown,
    eCI_HearHelpDialog_Distraction_StandDown,
    eCI_HearWarning_Distraction_StandDown,
    eCI_SightInvestigation_Distraction_StandDown,
    eCI_Suitcase_Distraction_DeliverToGuard,
    eCI_Suitcase_Distraction_RadioRequestHelp,
    eCI_Count,
}

impl Aligned for EConversationID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EConversationID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCI_GuardCivilian_Distraction_Investigation => 0i32,
            Self::eCI_HearBulletImpact_Distraction_Investigation => 1i32,
            Self::eCI_HearItemImpact_Distraction_Investigation => 2i32,
            Self::eCI_HearCarAlarm_Distraction_Investigation => 3i32,
            Self::eCI_SeeItemToss_Distraction_Investigation => 4i32,
            Self::eCI_HearRadio_Distraction_Investigation => 5i32,
            Self::eCI_HearPain_Distraction_Investigation => 6i32,
            Self::eCI_HearAccident_Distraction_Investigation => 7i32,
            Self::eCI_HearCuriousItemSound_Distraction_Investigation => 8i32,
            Self::eCI_HearCuriousSound_Distraction_Investigation => 9i32,
            Self::eCI_SeeSuspiciousPerceptible_Distraction_Investigation => 10i32,
            Self::eCI_SeeInterestingItem_Distraction_Investigation => 11i32,
            Self::eCI_HearFootSteps_Distraction_Investigation => 12i32,
            Self::eCI_HearAngryDialog_Distraction_Investigation => 13i32,
            Self::eCI_HearHelpDialog_Distraction_Investigation => 14i32,
            Self::eCI_HearWarning_Distraction_Investigation => 15i32,
            Self::eCI_SightInvestigation_Distraction_Investigation => 16i32,
            Self::eCI_HearBulletImpact_Distraction_StandDown => 17i32,
            Self::eCI_HearItemImpact_Distraction_StandDown => 18i32,
            Self::eCI_HearCarAlarm_Distraction_StandDown => 19i32,
            Self::eCI_SeeItemToss_Distraction_StandDown => 20i32,
            Self::eCI_HearRadio_Distraction_StandDown => 21i32,
            Self::eCI_HearPain_Distraction_StandDown => 22i32,
            Self::eCI_HearAccident_Distraction_StandDown => 23i32,
            Self::eCI_HearCuriousItemSound_Distraction_StandDown => 24i32,
            Self::eCI_HearCuriousSound_Distraction_StandDown => 25i32,
            Self::eCI_SeeSuspiciousPerceptible_Distraction_StandDown => 26i32,
            Self::eCI_SeeInterestingItem_Distraction_StandDown => 27i32,
            Self::eCI_HearFootSteps_Distraction_StandDown => 28i32,
            Self::eCI_HearAngryDialog_Distraction_StandDown => 29i32,
            Self::eCI_HearHelpDialog_Distraction_StandDown => 30i32,
            Self::eCI_HearWarning_Distraction_StandDown => 31i32,
            Self::eCI_SightInvestigation_Distraction_StandDown => 32i32,
            Self::eCI_Suitcase_Distraction_DeliverToGuard => 33i32,
            Self::eCI_Suitcase_Distraction_RadioRequestHelp => 34i32,
            Self::eCI_Count => 35i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EConversationID {
     const TYPE_ID: &str = "EConversationID";
}

impl StaticVariant for Vec<EConversationID> {
     const TYPE_ID: &str = "TArray<EConversationID>";
}

impl StaticVariant for Vec<Vec<EConversationID>> {
     const TYPE_ID: &str = "TArray<TArray<EConversationID>>";
}

impl Variant for EConversationID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EConversationID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EConversationID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EConversationID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EConversationID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EConversationID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EConversationRole {
    eCR_Leader,
    eCR_Assistant,
}

impl Aligned for EConversationRole {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EConversationRole {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCR_Leader => 0i32,
            Self::eCR_Assistant => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EConversationRole {
     const TYPE_ID: &str = "EConversationRole";
}

impl StaticVariant for Vec<EConversationRole> {
     const TYPE_ID: &str = "TArray<EConversationRole>";
}

impl StaticVariant for Vec<Vec<EConversationRole>> {
     const TYPE_ID: &str = "TArray<TArray<EConversationRole>>";
}

impl Variant for EConversationRole {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EConversationRole")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EConversationRole".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EConversationRole>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EConversationRole>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EConversationRole>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECoordinateSpace {
    CSPACE_INVALID,
    CSPACE_OBJECT_TO_WORLD,
    CSPACE_OBJECT_TO_PARENT,
    CSPACE_SEQUENCE_ORIGIN,
    CSPACE_CHARACTER_RELATIVE,
}

impl Aligned for ECoordinateSpace {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECoordinateSpace {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CSPACE_INVALID => 0i32,
            Self::CSPACE_OBJECT_TO_WORLD => 1i32,
            Self::CSPACE_OBJECT_TO_PARENT => 2i32,
            Self::CSPACE_SEQUENCE_ORIGIN => 3i32,
            Self::CSPACE_CHARACTER_RELATIVE => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECoordinateSpace {
     const TYPE_ID: &str = "ECoordinateSpace";
}

impl StaticVariant for Vec<ECoordinateSpace> {
     const TYPE_ID: &str = "TArray<ECoordinateSpace>";
}

impl StaticVariant for Vec<Vec<ECoordinateSpace>> {
     const TYPE_ID: &str = "TArray<TArray<ECoordinateSpace>>";
}

impl Variant for ECoordinateSpace {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECoordinateSpace")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECoordinateSpace".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECoordinateSpace>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECoordinateSpace>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECoordinateSpace>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECoverPosition {
    COVER_POSITION_NONE,
    COVER_POSITION_LEFT,
    COVER_POSITION_RIGHT,
    COVER_POSITION_MIDDLE,
}

impl Aligned for ECoverPosition {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECoverPosition {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::COVER_POSITION_NONE => 0i32,
            Self::COVER_POSITION_LEFT => 1i32,
            Self::COVER_POSITION_RIGHT => 2i32,
            Self::COVER_POSITION_MIDDLE => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECoverPosition {
     const TYPE_ID: &str = "ECoverPosition";
}

impl StaticVariant for Vec<ECoverPosition> {
     const TYPE_ID: &str = "TArray<ECoverPosition>";
}

impl StaticVariant for Vec<Vec<ECoverPosition>> {
     const TYPE_ID: &str = "TArray<TArray<ECoverPosition>>";
}

impl Variant for ECoverPosition {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECoverPosition")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECoverPosition".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECoverPosition>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECoverPosition>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECoverPosition>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECppTypeFlags {
    EDITOR_ONLY,
    EDITOR_ONLY_CRITICAL,
    RESETABLE,
    RESETABLE_COND,
    RESETABLE_STATIC,
}

impl Aligned for ECppTypeFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECppTypeFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDITOR_ONLY => 1i32,
            Self::EDITOR_ONLY_CRITICAL => 2i32,
            Self::RESETABLE => 4i32,
            Self::RESETABLE_COND => 8i32,
            Self::RESETABLE_STATIC => 16i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECppTypeFlags {
     const TYPE_ID: &str = "ECppTypeFlags";
}

impl StaticVariant for Vec<ECppTypeFlags> {
     const TYPE_ID: &str = "TArray<ECppTypeFlags>";
}

impl StaticVariant for Vec<Vec<ECppTypeFlags>> {
     const TYPE_ID: &str = "TArray<TArray<ECppTypeFlags>>";
}

impl Variant for ECppTypeFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECppTypeFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECppTypeFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECppTypeFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECppTypeFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECppTypeFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECrossHairType {
    CROSSHAIR_NONE,
    CROSSHAIR_PISTOL,
    CROSSHAIR_REVOLVER,
    CROSSHAIR_SMG,
    CROSSHAIR_RIFLE,
    CROSSHAIR_SHOTGUN,
    CROSSHAIR_SNIPER,
    CROSSHAIR_HARDBALLER,
    CROSSHAIR_UNAIMED,
    CROSSHAIR_POINTER,
    CROSSHAIR_WORLDCENTERMARKER,
    CROSSHAIR_BLINDFIRE,
    CROSSHAIR_RANGEINDICATOR,
    CROSSHAIR_DOT,
}

impl Aligned for ECrossHairType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECrossHairType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CROSSHAIR_NONE => 0i32,
            Self::CROSSHAIR_PISTOL => 1i32,
            Self::CROSSHAIR_REVOLVER => 2i32,
            Self::CROSSHAIR_SMG => 3i32,
            Self::CROSSHAIR_RIFLE => 4i32,
            Self::CROSSHAIR_SHOTGUN => 5i32,
            Self::CROSSHAIR_SNIPER => 6i32,
            Self::CROSSHAIR_HARDBALLER => 7i32,
            Self::CROSSHAIR_UNAIMED => 8i32,
            Self::CROSSHAIR_POINTER => 9i32,
            Self::CROSSHAIR_WORLDCENTERMARKER => 10i32,
            Self::CROSSHAIR_BLINDFIRE => 11i32,
            Self::CROSSHAIR_RANGEINDICATOR => 12i32,
            Self::CROSSHAIR_DOT => 13i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECrossHairType {
     const TYPE_ID: &str = "ECrossHairType";
}

impl StaticVariant for Vec<ECrossHairType> {
     const TYPE_ID: &str = "TArray<ECrossHairType>";
}

impl StaticVariant for Vec<Vec<ECrossHairType>> {
     const TYPE_ID: &str = "TArray<TArray<ECrossHairType>>";
}

impl Variant for ECrossHairType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECrossHairType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECrossHairType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECrossHairType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECrossHairType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECrossHairType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECrowdFlowCandidates {
    NONE,
    EVERYONE,
    SPAWNED_ON_FLOW,
}

impl Aligned for ECrowdFlowCandidates {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECrowdFlowCandidates {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NONE => 0i32,
            Self::EVERYONE => 1i32,
            Self::SPAWNED_ON_FLOW => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECrowdFlowCandidates {
     const TYPE_ID: &str = "ECrowdFlowCandidates";
}

impl StaticVariant for Vec<ECrowdFlowCandidates> {
     const TYPE_ID: &str = "TArray<ECrowdFlowCandidates>";
}

impl StaticVariant for Vec<Vec<ECrowdFlowCandidates>> {
     const TYPE_ID: &str = "TArray<TArray<ECrowdFlowCandidates>>";
}

impl Variant for ECrowdFlowCandidates {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECrowdFlowCandidates")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECrowdFlowCandidates".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECrowdFlowCandidates>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECrowdFlowCandidates>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECrowdFlowCandidates>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ECustomSoundDefType {
    eCSDT_Distraction_InvestigationAck,
    eCSDT_Distraction_InvestigationInvestigate,
    eCSDT_Distraction_InvestigationStnd,
}

impl Aligned for ECustomSoundDefType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ECustomSoundDefType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCSDT_Distraction_InvestigationAck => 0i32,
            Self::eCSDT_Distraction_InvestigationInvestigate => 1i32,
            Self::eCSDT_Distraction_InvestigationStnd => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ECustomSoundDefType {
     const TYPE_ID: &str = "ECustomSoundDefType";
}

impl StaticVariant for Vec<ECustomSoundDefType> {
     const TYPE_ID: &str = "TArray<ECustomSoundDefType>";
}

impl StaticVariant for Vec<Vec<ECustomSoundDefType>> {
     const TYPE_ID: &str = "TArray<TArray<ECustomSoundDefType>>";
}

impl Variant for ECustomSoundDefType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ECustomSoundDefType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ECustomSoundDefType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ECustomSoundDefType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ECustomSoundDefType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ECustomSoundDefType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDamageEvent {
    eDE_UNDEFINED,
    eDE_InCloset,
    eDE_Subdue,
    eDE_CloseCombat,
    eDE_PushOver,
    eDE_KickDownStairs,
    eDE_DeadlyThrow,
    eDE_Shoot,
    eDE_Sedated,
    eDE_InstantTakeDown,
    eDE_CoupDeGrace,
    eDE_ContextKill,
    eDE_Garotte,
    eDE_Poison,
    eDE_Electric,
    eDE_SuspendedObject,
    eDE_Burn,
    eDE_Drop,
    eDE_Drown,
}

impl Aligned for EDamageEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDamageEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDE_UNDEFINED => 0i32,
            Self::eDE_InCloset => 1i32,
            Self::eDE_Subdue => 2i32,
            Self::eDE_CloseCombat => 4i32,
            Self::eDE_PushOver => 16i32,
            Self::eDE_KickDownStairs => 32i32,
            Self::eDE_DeadlyThrow => 64i32,
            Self::eDE_Shoot => 128i32,
            Self::eDE_Sedated => 256i32,
            Self::eDE_InstantTakeDown => 512i32,
            Self::eDE_CoupDeGrace => 1024i32,
            Self::eDE_ContextKill => 2048i32,
            Self::eDE_Garotte => 4096i32,
            Self::eDE_Poison => 8192i32,
            Self::eDE_Electric => 16384i32,
            Self::eDE_SuspendedObject => 32768i32,
            Self::eDE_Burn => 65536i32,
            Self::eDE_Drop => 131072i32,
            Self::eDE_Drown => 262144i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDamageEvent {
     const TYPE_ID: &str = "EDamageEvent";
}

impl StaticVariant for Vec<EDamageEvent> {
     const TYPE_ID: &str = "TArray<EDamageEvent>";
}

impl StaticVariant for Vec<Vec<EDamageEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EDamageEvent>>";
}

impl Variant for EDamageEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDamageEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDamageEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDamageEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDamageEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDamageEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDamageResponse {
    eDR_Fractured,
    eDR_Detached,
    eDR_Destroyed,
    eDR_Collided,
    eDR_Count,
}

impl Aligned for EDamageResponse {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDamageResponse {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDR_Fractured => 0i32,
            Self::eDR_Detached => 1i32,
            Self::eDR_Destroyed => 2i32,
            Self::eDR_Collided => 3i32,
            Self::eDR_Count => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDamageResponse {
     const TYPE_ID: &str = "EDamageResponse";
}

impl StaticVariant for Vec<EDamageResponse> {
     const TYPE_ID: &str = "TArray<EDamageResponse>";
}

impl StaticVariant for Vec<Vec<EDamageResponse>> {
     const TYPE_ID: &str = "TArray<TArray<EDamageResponse>>";
}

impl Variant for EDamageResponse {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDamageResponse")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDamageResponse".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDamageResponse>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDamageResponse>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDamageResponse>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDeathAnimationType {
    DAT_None,
    DAT_SingleShot,
    DAT_BurstShot,
    DAT_HeavyShot,
    DAT_Unknown,
}

impl Aligned for EDeathAnimationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDeathAnimationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DAT_None => 0i32,
            Self::DAT_SingleShot => 1i32,
            Self::DAT_BurstShot => 2i32,
            Self::DAT_HeavyShot => 3i32,
            Self::DAT_Unknown => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDeathAnimationType {
     const TYPE_ID: &str = "EDeathAnimationType";
}

impl StaticVariant for Vec<EDeathAnimationType> {
     const TYPE_ID: &str = "TArray<EDeathAnimationType>";
}

impl StaticVariant for Vec<Vec<EDeathAnimationType>> {
     const TYPE_ID: &str = "TArray<TArray<EDeathAnimationType>>";
}

impl Variant for EDeathAnimationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDeathAnimationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDeathAnimationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDeathAnimationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDeathAnimationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDeathAnimationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDeathBehavior {
    eDB_IMPACT_ANIM,
    eDB_NO_IMPACT_ANIM,
    eDB_NO_VELOCITY,
    eDB_NO_RAGDOLL,
}

impl Aligned for EDeathBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDeathBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDB_IMPACT_ANIM => 0i32,
            Self::eDB_NO_IMPACT_ANIM => 1i32,
            Self::eDB_NO_VELOCITY => 2i32,
            Self::eDB_NO_RAGDOLL => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDeathBehavior {
     const TYPE_ID: &str = "EDeathBehavior";
}

impl StaticVariant for Vec<EDeathBehavior> {
     const TYPE_ID: &str = "TArray<EDeathBehavior>";
}

impl StaticVariant for Vec<Vec<EDeathBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<EDeathBehavior>>";
}

impl Variant for EDeathBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDeathBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDeathBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDeathBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDeathBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDeathBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDeathContext {
    eDC_UNDEFINED,
    eDC_NOT_HERO,
    eDC_HIDDEN,
    eDC_ACCIDENT,
    eDC_MURDER,
}

impl Aligned for EDeathContext {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDeathContext {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDC_UNDEFINED => 0i32,
            Self::eDC_NOT_HERO => 1i32,
            Self::eDC_HIDDEN => 2i32,
            Self::eDC_ACCIDENT => 3i32,
            Self::eDC_MURDER => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDeathContext {
     const TYPE_ID: &str = "EDeathContext";
}

impl StaticVariant for Vec<EDeathContext> {
     const TYPE_ID: &str = "TArray<EDeathContext>";
}

impl StaticVariant for Vec<Vec<EDeathContext>> {
     const TYPE_ID: &str = "TArray<TArray<EDeathContext>>";
}

impl Variant for EDeathContext {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDeathContext")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDeathContext".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDeathContext>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDeathContext>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDeathContext>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDeathType {
    eDT_UNDEFINED,
    eDT_SLAP,
    eDT_PUNCH,
    eDT_PACIFY,
    eDT_KILL,
    eDT_BLOODY_KILL,
}

impl Aligned for EDeathType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDeathType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDT_UNDEFINED => 0i32,
            Self::eDT_SLAP => 1i32,
            Self::eDT_PUNCH => 2i32,
            Self::eDT_PACIFY => 3i32,
            Self::eDT_KILL => 4i32,
            Self::eDT_BLOODY_KILL => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDeathType {
     const TYPE_ID: &str = "EDeathType";
}

impl StaticVariant for Vec<EDeathType> {
     const TYPE_ID: &str = "TArray<EDeathType>";
}

impl StaticVariant for Vec<Vec<EDeathType>> {
     const TYPE_ID: &str = "TArray<TArray<EDeathType>>";
}

impl Variant for EDeathType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDeathType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDeathType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDeathType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDeathType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDeathType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDebugExclusionLayerState {
    DEBUGELSTATE_UNBLOCKED,
    DEBUGELSTATE_BLOCKED,
    DEBUGELSTATE_UNKNOWN,
}

impl Aligned for EDebugExclusionLayerState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDebugExclusionLayerState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DEBUGELSTATE_UNBLOCKED => 0i32,
            Self::DEBUGELSTATE_BLOCKED => 1i32,
            Self::DEBUGELSTATE_UNKNOWN => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDebugExclusionLayerState {
     const TYPE_ID: &str = "EDebugExclusionLayerState";
}

impl StaticVariant for Vec<EDebugExclusionLayerState> {
     const TYPE_ID: &str = "TArray<EDebugExclusionLayerState>";
}

impl StaticVariant for Vec<Vec<EDebugExclusionLayerState>> {
     const TYPE_ID: &str = "TArray<TArray<EDebugExclusionLayerState>>";
}

impl Variant for EDebugExclusionLayerState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDebugExclusionLayerState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDebugExclusionLayerState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDebugExclusionLayerState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDebugExclusionLayerState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDebugExclusionLayerState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDebugSpatialInfoVerbosity {
    EDSIV_Overview,
    EDSIV_HierachicalView,
    EDSIV_Full,
}

impl Aligned for EDebugSpatialInfoVerbosity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDebugSpatialInfoVerbosity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDSIV_Overview => 0i32,
            Self::EDSIV_HierachicalView => 1i32,
            Self::EDSIV_Full => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDebugSpatialInfoVerbosity {
     const TYPE_ID: &str = "EDebugSpatialInfoVerbosity";
}

impl StaticVariant for Vec<EDebugSpatialInfoVerbosity> {
     const TYPE_ID: &str = "TArray<EDebugSpatialInfoVerbosity>";
}

impl StaticVariant for Vec<Vec<EDebugSpatialInfoVerbosity>> {
     const TYPE_ID: &str = "TArray<TArray<EDebugSpatialInfoVerbosity>>";
}

impl Variant for EDebugSpatialInfoVerbosity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDebugSpatialInfoVerbosity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDebugSpatialInfoVerbosity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDebugSpatialInfoVerbosity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDebugSpatialInfoVerbosity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDebugSpatialInfoVerbosity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EDefaultCollidableLayer {
    DCL_STATIC,
    DCL_KINEMATIC,
    DCL_KINEMATIC_TRANSPARENT,
    DCL_DYNAMIC,
    DCL_DYNAMIC_TRANSPARENT,
    DCL_COLLIDE_ALL,
    DCL_STATIC_TRANSPARENT,
    DCL_COLLIDE_STATIC_ONLY,
    DCL_DYNAMIC_NO_CHARACTER,
    DCL_UNUSED_LAST,
}

impl Aligned for EDefaultCollidableLayer {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EDefaultCollidableLayer {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DCL_STATIC => 0i8,
            Self::DCL_KINEMATIC => 1i8,
            Self::DCL_KINEMATIC_TRANSPARENT => 2i8,
            Self::DCL_DYNAMIC => 3i8,
            Self::DCL_DYNAMIC_TRANSPARENT => 4i8,
            Self::DCL_COLLIDE_ALL => 5i8,
            Self::DCL_STATIC_TRANSPARENT => 6i8,
            Self::DCL_COLLIDE_STATIC_ONLY => 7i8,
            Self::DCL_DYNAMIC_NO_CHARACTER => 8i8,
            Self::DCL_UNUSED_LAST => 9i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDefaultCollidableLayer {
     const TYPE_ID: &str = "EDefaultCollidableLayer";
}

impl StaticVariant for Vec<EDefaultCollidableLayer> {
     const TYPE_ID: &str = "TArray<EDefaultCollidableLayer>";
}

impl StaticVariant for Vec<Vec<EDefaultCollidableLayer>> {
     const TYPE_ID: &str = "TArray<TArray<EDefaultCollidableLayer>>";
}

impl Variant for EDefaultCollidableLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDefaultCollidableLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDefaultCollidableLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDefaultCollidableLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDefaultCollidableLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDefaultCollidableLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EDestructibleInteractionType {
    eDIT_SHOT,
    eDIT_EXPLOSION,
    eDIT_COLLISION,
    eDIT_FRACTURE_AND_DETACH_ALL,
    eDIT_OUT_OF_WORLD,
    eDIT_COUNT,
}

impl Aligned for EDestructibleInteractionType {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EDestructibleInteractionType {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDIT_SHOT => 0i8,
            Self::eDIT_EXPLOSION => 1i8,
            Self::eDIT_COLLISION => 2i8,
            Self::eDIT_FRACTURE_AND_DETACH_ALL => 3i8,
            Self::eDIT_OUT_OF_WORLD => 4i8,
            Self::eDIT_COUNT => 5i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDestructibleInteractionType {
     const TYPE_ID: &str = "EDestructibleInteractionType";
}

impl StaticVariant for Vec<EDestructibleInteractionType> {
     const TYPE_ID: &str = "TArray<EDestructibleInteractionType>";
}

impl StaticVariant for Vec<Vec<EDestructibleInteractionType>> {
     const TYPE_ID: &str = "TArray<TArray<EDestructibleInteractionType>>";
}

impl Variant for EDestructibleInteractionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDestructibleInteractionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDestructibleInteractionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDestructibleInteractionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDestructibleInteractionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDestructibleInteractionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDetachUsage {
    EDU_NEVER,
    EDU_ALWAYS,
    EDU_RAGDOLL_ONLY,
}

impl Aligned for EDetachUsage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDetachUsage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDU_NEVER => 0i32,
            Self::EDU_ALWAYS => 1i32,
            Self::EDU_RAGDOLL_ONLY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDetachUsage {
     const TYPE_ID: &str = "EDetachUsage";
}

impl StaticVariant for Vec<EDetachUsage> {
     const TYPE_ID: &str = "TArray<EDetachUsage>";
}

impl StaticVariant for Vec<Vec<EDetachUsage>> {
     const TYPE_ID: &str = "TArray<TArray<EDetachUsage>>";
}

impl Variant for EDetachUsage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDetachUsage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDetachUsage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDetachUsage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDetachUsage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDetachUsage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDetectedNatType {
    NAT_UNSET,
    NAT_1,
    NAT_2,
    NAT_3,
}

impl Aligned for EDetectedNatType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDetectedNatType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NAT_UNSET => 0i32,
            Self::NAT_1 => 1i32,
            Self::NAT_2 => 2i32,
            Self::NAT_3 => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDetectedNatType {
     const TYPE_ID: &str = "EDetectedNatType";
}

impl StaticVariant for Vec<EDetectedNatType> {
     const TYPE_ID: &str = "TArray<EDetectedNatType>";
}

impl StaticVariant for Vec<Vec<EDetectedNatType>> {
     const TYPE_ID: &str = "TArray<TArray<EDetectedNatType>>";
}

impl Variant for EDetectedNatType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDetectedNatType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDetectedNatType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDetectedNatType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDetectedNatType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDetectedNatType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDialogEventEndReason {
    EDialogEvent_Completed,
    EDialogEvent_Stopped,
}

impl Aligned for EDialogEventEndReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDialogEventEndReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDialogEvent_Completed => 0i32,
            Self::EDialogEvent_Stopped => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDialogEventEndReason {
     const TYPE_ID: &str = "EDialogEventEndReason";
}

impl StaticVariant for Vec<EDialogEventEndReason> {
     const TYPE_ID: &str = "TArray<EDialogEventEndReason>";
}

impl StaticVariant for Vec<Vec<EDialogEventEndReason>> {
     const TYPE_ID: &str = "TArray<TArray<EDialogEventEndReason>>";
}

impl Variant for EDialogEventEndReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDialogEventEndReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDialogEventEndReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDialogEventEndReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDialogEventEndReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDialogEventEndReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDialogEventItemType {
    eDEIT_WavFile,
    eDEIT_RandomContainer,
    eDEIT_SwitchContainer,
    eDEIT_SequenceContainer,
    eDEIT_Invalid,
}

impl Aligned for EDialogEventItemType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDialogEventItemType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDEIT_WavFile => 1i32,
            Self::eDEIT_RandomContainer => 2i32,
            Self::eDEIT_SwitchContainer => 3i32,
            Self::eDEIT_SequenceContainer => 4i32,
            Self::eDEIT_Invalid => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDialogEventItemType {
     const TYPE_ID: &str = "EDialogEventItemType";
}

impl StaticVariant for Vec<EDialogEventItemType> {
     const TYPE_ID: &str = "TArray<EDialogEventItemType>";
}

impl StaticVariant for Vec<Vec<EDialogEventItemType>> {
     const TYPE_ID: &str = "TArray<TArray<EDialogEventItemType>>";
}

impl Variant for EDialogEventItemType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDialogEventItemType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDialogEventItemType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDialogEventItemType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDialogEventItemType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDialogEventItemType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDialogueLine {
    Hello,
    MoveAlong,
    WhatsGoingOn,
    DropWeapon01,
    DropWeapon02,
    DropWeapon03,
    DropWeapon04,
    DropWeaponSecondWarning,
    Comply01,
    Comply02,
    YouAskedForIt,
    DropWeapon_Single01,
    DropWeapon_Double01,
    DropWeapon_Multiple01,
    DropWeapon_Comply_Single01,
    DropWeapon_Comply_Double01,
    DropWeapon_Comply_Multiple01,
    DropWeapon_RunAway01,
    DropWeapon_RunAway_Comply01,
    DropWeapon_Escalate_Single01,
    DropWeapon_Escalate_Double01,
    DropWeapon_Escalate_Multiple01,
}

impl Aligned for EDialogueLine {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDialogueLine {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Hello => 0i32,
            Self::MoveAlong => 1i32,
            Self::WhatsGoingOn => 2i32,
            Self::DropWeapon01 => 3i32,
            Self::DropWeapon02 => 4i32,
            Self::DropWeapon03 => 5i32,
            Self::DropWeapon04 => 6i32,
            Self::DropWeaponSecondWarning => 7i32,
            Self::Comply01 => 8i32,
            Self::Comply02 => 9i32,
            Self::YouAskedForIt => 10i32,
            Self::DropWeapon_Single01 => 11i32,
            Self::DropWeapon_Double01 => 12i32,
            Self::DropWeapon_Multiple01 => 13i32,
            Self::DropWeapon_Comply_Single01 => 14i32,
            Self::DropWeapon_Comply_Double01 => 15i32,
            Self::DropWeapon_Comply_Multiple01 => 16i32,
            Self::DropWeapon_RunAway01 => 17i32,
            Self::DropWeapon_RunAway_Comply01 => 18i32,
            Self::DropWeapon_Escalate_Single01 => 19i32,
            Self::DropWeapon_Escalate_Double01 => 20i32,
            Self::DropWeapon_Escalate_Multiple01 => 21i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDialogueLine {
     const TYPE_ID: &str = "EDialogueLine";
}

impl StaticVariant for Vec<EDialogueLine> {
     const TYPE_ID: &str = "TArray<EDialogueLine>";
}

impl StaticVariant for Vec<Vec<EDialogueLine>> {
     const TYPE_ID: &str = "TArray<TArray<EDialogueLine>>";
}

impl Variant for EDialogueLine {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDialogueLine")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDialogueLine".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDialogueLine>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDialogueLine>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDialogueLine>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDifficultyLevel {
    eDL_NO_FLAGS,
    eDL_EASY,
    eDL_NORMAL,
    eDL_HARD,
    eDL_VERY_HARD,
    eDL_ALL_FLAGS,
}

impl Aligned for EDifficultyLevel {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDifficultyLevel {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDL_NO_FLAGS => 0i32,
            Self::eDL_EASY => 1i32,
            Self::eDL_NORMAL => 2i32,
            Self::eDL_HARD => 4i32,
            Self::eDL_VERY_HARD => 8i32,
            Self::eDL_ALL_FLAGS => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDifficultyLevel {
     const TYPE_ID: &str = "EDifficultyLevel";
}

impl StaticVariant for Vec<EDifficultyLevel> {
     const TYPE_ID: &str = "TArray<EDifficultyLevel>";
}

impl StaticVariant for Vec<Vec<EDifficultyLevel>> {
     const TYPE_ID: &str = "TArray<TArray<EDifficultyLevel>>";
}

impl Variant for EDifficultyLevel {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDifficultyLevel")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDifficultyLevel".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDifficultyLevel>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDifficultyLevel>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDifficultyLevel>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDifficultyParameter {
    EDP_Invalid,
    EDP_AIAttentionGainMultiplier,
    EDP_AIAudioPerceptionAlwaysEmitFootstepSoundEvents,
    EDP_AICombat_ActiveCombatants_MinimumNumber,
    EDP_AICombat_ActiveCombatants_MinimumNumberWhenAllVIPsAreDead,
    EDP_AICombat_ActiveCombatants_MaximumNumber,
    EDP_AICombat_ActiveCombatants_MinimumAmountForMedium,
    EDP_AICombat_ActiveCombatants_MinimumAmountForMany,
    EDP_AICombat_ShootingAccuracyResetPeriod_Minimum,
    EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_FewCombatants,
    EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_MediumCombatants,
    EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_ManyCombatants,
    EDP_AICombat_Leaders_NumberOfActiveCombatantsNeededForOneLeader,
    EDP_AICombat_Leaders_NumberOfActiveCombatantsNeededForTwoLeaders,
    EDP_AICombat_MaximumInterestingCombatLifetime,
    EDP_AICombat_MaximumInterestingTimeSinceLastCombat,
    EDP_AICombat_ShootingAccuracyInitialBuildUp_MinimumDuration,
    EDP_AICombat_ShootingAccuracyInitialBuildUp_MaximumDuration,
    EDP_AICombat_ShootingAccuracy_MinimumDistance,
    EDP_AICombat_FlashGrenadeThrow_GlobalCooldown,
    EDP_AICombat_FlashGrenadeThrow_AggressionTriggerCooldown,
    EDP_AICombat_FlashGrenadeThrow_TargetCampingTriggerCooldown,
    EDP_AICombat_FlashGrenadeThrow_LargeRelocationTriggerCooldown,
    EDP_AIDisguise_FollowWarningsDelay,
    EDP_AIDisguise_BreakOnVeryCloseDistance,
    EDP_AIEscortOut_MaxForbiddenMovement,
    EDP_AIEscortOut_EscortEscalateDistance,
    EDP_AIEscortOut_MaxTimeToHonorWarning,
    EDP_AIEscortOut_EscortHardWarningDistance,
    EDP_AIIllegalActionAttentionModifier,
    EDP_AIInvestigateCautious_Disturbance_Radius,
    EDP_AIInvestigateCautious_Search_ClearDisturbanceBackRadius,
    EDP_AIInvestigateCautious_Search_ClearDisturbanceFrontRadius,
    EDP_AIInvestigateCautious_Search_ClearDisturbanceRespectSoftReservationThreshold,
    EDP_AIInvestigateCautiousAttentionToPersonEnabled,
    EDP_AIInvestigateDisguiseMembersFollowDistance,
    EDP_AILongTermMemory_DisableArrest,
    EDP_AIRunningAttentionModifier,
    EDP_AISentry_WarningDelay,
    EDP_AISuspiciousMovementDisguiseAttentionModifier,
    EDP_AISuspiciousMovementSensorEnabled,
    EDP_AISuspiciousLostTargetTime,
    EDP_AllowInstinctGlow,
    EDP_ArrestEscalateIllegalWeapon,
    EDP_ArrestEscalateMaximum,
    EDP_ArrestEscalateMoving,
    EDP_ArrestEscalateRunning,
    EDP_ArrestTargetLostTime,
    EDP_CloseCombatChainFailDamage,
    EDP_CloseCombatChoiceWindowLength,
    EDP_CloseCombatChokePressCount_Civilian,
    EDP_CloseCombatChokePressCount_Elite,
    EDP_CloseCombatChokePressCount_Guard,
    EDP_CloseCombatCounterEndLength,
    EDP_CloseCombatCounterFailDamage,
    EDP_CloseCombatShowSnapNeckPressCount_Civilian,
    EDP_CloseCombatShowSnapNeckPressCount_Elite,
    EDP_CloseCombatShowSnapNeckPressCount_Guard,
    EDP_DamageMultiplierHandgun,
    EDP_DamageMultiplierSlowgun,
    EDP_DamageMultiplierAssaultRifle,
    EDP_DamageMultiplierSMG,
    EDP_DamageMultiplierSniper,
    EDP_DamageMultiplierRPG,
    EDP_DamageMultiplierKnife,
    EDP_DamageMultiplierShotgun,
    EDP_DamageMultiplierSpotter,
    EDP_DamageMultiplierHandgun_NPC,
    EDP_DamageMultiplierSlowgun_NPC,
    EDP_DamageMultiplierAssaultRifle_NPC,
    EDP_DamageMultiplierSMG_NPC,
    EDP_DamageMultiplierSniper_NPC,
    EDP_DamageMultiplierRPG_NPC,
    EDP_DamageMultiplierKnife_NPC,
    EDP_DamageMultiplierShotgun_NPC,
    EDP_DamageMultiplierSpotter_NPC,
    EDP_DisguiseRuiningEnabled,
    EDP_GameMissionSaveLimit,
    EDP_GameOpportunitiesEnabled,
    EDP_HearRangeBulletImpact,
    EDP_HearRangeBulletImpactOnBody,
    EDP_HearRangeCloseCombatBreakNeck,
    EDP_HearRangeCloseCombatChoke,
    EDP_HearRangeCloseCombatFiberWire,
    EDP_HearRangeCloseCombatHitFromBehind,
    EDP_HearRangeCloseCombatL1,
    EDP_HearRangeCloseCombatL2,
    EDP_HearRangeCloseCombatL3,
    EDP_HearRangeEventAccident,
    EDP_HearRangeEventAlarm,
    EDP_HearRangeEventExplosion,
    EDP_HearRangeEventRadio,
    EDP_HearRangeEventStrange,
    EDP_HearRangeEventThrownItem,
    EDP_HearRangeFootstepWalkSlow,
    EDP_HearRangeFootstepWalk,
    EDP_HearRangeFootstepRun,
    EDP_HearRangeFootstepCrouchWalkSlow,
    EDP_HearRangeFootstepCrouchWalk,
    EDP_HearRangeFootstepCrouchRun,
    EDP_HearRangeFootstepVegetationLVAWalkSlow,
    EDP_HearRangeFootstepVegetationLVAWalk,
    EDP_HearRangeFootstepVegetationLVARun,
    EDP_HearRangeFootstepVegetationLVACrouchWalkSlow,
    EDP_HearRangeFootstepVegetationLVACrouchWalk,
    EDP_HearRangeFootstepVegetationLVACrouchRun,
    EDP_HearRangeGunEmpty,
    EDP_HearRangeGunShot,
    EDP_HearRangeGunSilenced,
    EDP_HearRangeGunSuperSilenced,
    EDP_HearRangeSpeakAngry,
    EDP_HearRangeSpeakHelp,
    EDP_HearRangeSpeakHelpLoud,
    EDP_HearRangeSpeakPain,
    EDP_HearRangeSpeakPainLow,
    EDP_HearRangeSpeakWarning,
    EDP_HitmanDamageReceivedMultiplier,
    EDP_InstinctModeBurnRate,
    EDP_InstinctRegenCap,
    EDP_InstinctRegenRate,
    EDP_ManhuntGroupMaxSearchTime,
    EDP_ManhuntGroupSearchAreaHackMaxDistance,
    EDP_ManhuntGroupSearchAreaRadius,
    EDP_MaxCoverShootActorCountMultiplier,
    EDP_MinAttentionToForceLookAt,
    EDP_MinAttentionToForceLookAtIfIncreasing,
    EDP_NPCDamageReceivedMultiplier,
    EDP_PlayerDamagePerSecondDistance,
    EDP_PlayerDamagePerSecondLimitFar,
    EDP_PlayerDamagePerSecondLimitNear,
    EDP_PlayerDamagePerSecondThreshold,
    EDP_PlayerHitPointsMax,
    EDP_PlayerHitPointsRegenerationDelay,
    EDP_PlayerHitPointsRegenerationPerSecond,
    EDP_SecurityCameras,
    EDP_SightReactionMinAttention,
    EDP_SightInvestigationMinAttention,
    EDP_ShootSpreadMax,
    EDP_ShootSpreadMin,
    EDP_ShootSpreadRange,
    EDP_SocialGreetingAngle,
    EDP_SocialGreetingCooldown,
    EDP_SocialGreetingCooldownAlertLevel,
    EDP_SocialGreetingCooldownLastSpeak,
    EDP_SocialGreetingCooldownPlayer,
    EDP_SocialGreetingCooldownSequence,
    EDP_SocialGreetingDistance,
    EDP_SocialLookAtTimeMax,
    EDP_SocialLookAtTimeMin,
    EDP_SocialSillyCooldown,
    EDP_SocialSillyDistance,
    EDP_SocialSillyTriggerTime,
    EDP_SocialStandingCooldown,
    EDP_SocialStandingDistance,
    EDP_SocialStandingDistanceImmediate,
    EDP_SocialStandingTriggerTime,
    EDP_SpotHitmanShootingDistance,
    EDP_StrictItemRules,
    EDP_COUNT,
}

impl Aligned for EDifficultyParameter {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDifficultyParameter {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDP_Invalid => 0i32,
            Self::EDP_AIAttentionGainMultiplier => 1i32,
            Self::EDP_AIAudioPerceptionAlwaysEmitFootstepSoundEvents => 2i32,
            Self::EDP_AICombat_ActiveCombatants_MinimumNumber => 3i32,
            Self::EDP_AICombat_ActiveCombatants_MinimumNumberWhenAllVIPsAreDead => 4i32,
            Self::EDP_AICombat_ActiveCombatants_MaximumNumber => 5i32,
            Self::EDP_AICombat_ActiveCombatants_MinimumAmountForMedium => 6i32,
            Self::EDP_AICombat_ActiveCombatants_MinimumAmountForMany => 7i32,
            Self::EDP_AICombat_ShootingAccuracyResetPeriod_Minimum => 8i32,
            Self::EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_FewCombatants => 9i32,
            Self::EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_MediumCombatants => 10i32,
            Self::EDP_AICombat_ShootingAccuracyResetPeriod_Maximum_ManyCombatants => 11i32,
            Self::EDP_AICombat_Leaders_NumberOfActiveCombatantsNeededForOneLeader => 12i32,
            Self::EDP_AICombat_Leaders_NumberOfActiveCombatantsNeededForTwoLeaders => 13i32,
            Self::EDP_AICombat_MaximumInterestingCombatLifetime => 14i32,
            Self::EDP_AICombat_MaximumInterestingTimeSinceLastCombat => 15i32,
            Self::EDP_AICombat_ShootingAccuracyInitialBuildUp_MinimumDuration => 16i32,
            Self::EDP_AICombat_ShootingAccuracyInitialBuildUp_MaximumDuration => 17i32,
            Self::EDP_AICombat_ShootingAccuracy_MinimumDistance => 18i32,
            Self::EDP_AICombat_FlashGrenadeThrow_GlobalCooldown => 19i32,
            Self::EDP_AICombat_FlashGrenadeThrow_AggressionTriggerCooldown => 20i32,
            Self::EDP_AICombat_FlashGrenadeThrow_TargetCampingTriggerCooldown => 21i32,
            Self::EDP_AICombat_FlashGrenadeThrow_LargeRelocationTriggerCooldown => 22i32,
            Self::EDP_AIDisguise_FollowWarningsDelay => 23i32,
            Self::EDP_AIDisguise_BreakOnVeryCloseDistance => 24i32,
            Self::EDP_AIEscortOut_MaxForbiddenMovement => 25i32,
            Self::EDP_AIEscortOut_EscortEscalateDistance => 26i32,
            Self::EDP_AIEscortOut_MaxTimeToHonorWarning => 27i32,
            Self::EDP_AIEscortOut_EscortHardWarningDistance => 28i32,
            Self::EDP_AIIllegalActionAttentionModifier => 29i32,
            Self::EDP_AIInvestigateCautious_Disturbance_Radius => 30i32,
            Self::EDP_AIInvestigateCautious_Search_ClearDisturbanceBackRadius => 31i32,
            Self::EDP_AIInvestigateCautious_Search_ClearDisturbanceFrontRadius => 32i32,
            Self::EDP_AIInvestigateCautious_Search_ClearDisturbanceRespectSoftReservationThreshold => 33i32,
            Self::EDP_AIInvestigateCautiousAttentionToPersonEnabled => 34i32,
            Self::EDP_AIInvestigateDisguiseMembersFollowDistance => 35i32,
            Self::EDP_AILongTermMemory_DisableArrest => 36i32,
            Self::EDP_AIRunningAttentionModifier => 37i32,
            Self::EDP_AISentry_WarningDelay => 38i32,
            Self::EDP_AISuspiciousMovementDisguiseAttentionModifier => 39i32,
            Self::EDP_AISuspiciousMovementSensorEnabled => 40i32,
            Self::EDP_AISuspiciousLostTargetTime => 41i32,
            Self::EDP_AllowInstinctGlow => 42i32,
            Self::EDP_ArrestEscalateIllegalWeapon => 43i32,
            Self::EDP_ArrestEscalateMaximum => 44i32,
            Self::EDP_ArrestEscalateMoving => 45i32,
            Self::EDP_ArrestEscalateRunning => 46i32,
            Self::EDP_ArrestTargetLostTime => 47i32,
            Self::EDP_CloseCombatChainFailDamage => 48i32,
            Self::EDP_CloseCombatChoiceWindowLength => 49i32,
            Self::EDP_CloseCombatChokePressCount_Civilian => 50i32,
            Self::EDP_CloseCombatChokePressCount_Elite => 51i32,
            Self::EDP_CloseCombatChokePressCount_Guard => 52i32,
            Self::EDP_CloseCombatCounterEndLength => 53i32,
            Self::EDP_CloseCombatCounterFailDamage => 54i32,
            Self::EDP_CloseCombatShowSnapNeckPressCount_Civilian => 55i32,
            Self::EDP_CloseCombatShowSnapNeckPressCount_Elite => 56i32,
            Self::EDP_CloseCombatShowSnapNeckPressCount_Guard => 57i32,
            Self::EDP_DamageMultiplierHandgun => 58i32,
            Self::EDP_DamageMultiplierSlowgun => 59i32,
            Self::EDP_DamageMultiplierAssaultRifle => 60i32,
            Self::EDP_DamageMultiplierSMG => 61i32,
            Self::EDP_DamageMultiplierSniper => 62i32,
            Self::EDP_DamageMultiplierRPG => 63i32,
            Self::EDP_DamageMultiplierKnife => 64i32,
            Self::EDP_DamageMultiplierShotgun => 65i32,
            Self::EDP_DamageMultiplierSpotter => 66i32,
            Self::EDP_DamageMultiplierHandgun_NPC => 67i32,
            Self::EDP_DamageMultiplierSlowgun_NPC => 68i32,
            Self::EDP_DamageMultiplierAssaultRifle_NPC => 69i32,
            Self::EDP_DamageMultiplierSMG_NPC => 70i32,
            Self::EDP_DamageMultiplierSniper_NPC => 71i32,
            Self::EDP_DamageMultiplierRPG_NPC => 72i32,
            Self::EDP_DamageMultiplierKnife_NPC => 73i32,
            Self::EDP_DamageMultiplierShotgun_NPC => 74i32,
            Self::EDP_DamageMultiplierSpotter_NPC => 75i32,
            Self::EDP_DisguiseRuiningEnabled => 76i32,
            Self::EDP_GameMissionSaveLimit => 77i32,
            Self::EDP_GameOpportunitiesEnabled => 78i32,
            Self::EDP_HearRangeBulletImpact => 79i32,
            Self::EDP_HearRangeBulletImpactOnBody => 80i32,
            Self::EDP_HearRangeCloseCombatBreakNeck => 81i32,
            Self::EDP_HearRangeCloseCombatChoke => 82i32,
            Self::EDP_HearRangeCloseCombatFiberWire => 83i32,
            Self::EDP_HearRangeCloseCombatHitFromBehind => 84i32,
            Self::EDP_HearRangeCloseCombatL1 => 85i32,
            Self::EDP_HearRangeCloseCombatL2 => 86i32,
            Self::EDP_HearRangeCloseCombatL3 => 87i32,
            Self::EDP_HearRangeEventAccident => 88i32,
            Self::EDP_HearRangeEventAlarm => 89i32,
            Self::EDP_HearRangeEventExplosion => 90i32,
            Self::EDP_HearRangeEventRadio => 91i32,
            Self::EDP_HearRangeEventStrange => 92i32,
            Self::EDP_HearRangeEventThrownItem => 93i32,
            Self::EDP_HearRangeFootstepWalkSlow => 94i32,
            Self::EDP_HearRangeFootstepWalk => 95i32,
            Self::EDP_HearRangeFootstepRun => 96i32,
            Self::EDP_HearRangeFootstepCrouchWalkSlow => 97i32,
            Self::EDP_HearRangeFootstepCrouchWalk => 98i32,
            Self::EDP_HearRangeFootstepCrouchRun => 99i32,
            Self::EDP_HearRangeFootstepVegetationLVAWalkSlow => 100i32,
            Self::EDP_HearRangeFootstepVegetationLVAWalk => 101i32,
            Self::EDP_HearRangeFootstepVegetationLVARun => 102i32,
            Self::EDP_HearRangeFootstepVegetationLVACrouchWalkSlow => 103i32,
            Self::EDP_HearRangeFootstepVegetationLVACrouchWalk => 104i32,
            Self::EDP_HearRangeFootstepVegetationLVACrouchRun => 105i32,
            Self::EDP_HearRangeGunEmpty => 106i32,
            Self::EDP_HearRangeGunShot => 107i32,
            Self::EDP_HearRangeGunSilenced => 108i32,
            Self::EDP_HearRangeGunSuperSilenced => 109i32,
            Self::EDP_HearRangeSpeakAngry => 110i32,
            Self::EDP_HearRangeSpeakHelp => 111i32,
            Self::EDP_HearRangeSpeakHelpLoud => 112i32,
            Self::EDP_HearRangeSpeakPain => 113i32,
            Self::EDP_HearRangeSpeakPainLow => 114i32,
            Self::EDP_HearRangeSpeakWarning => 115i32,
            Self::EDP_HitmanDamageReceivedMultiplier => 116i32,
            Self::EDP_InstinctModeBurnRate => 117i32,
            Self::EDP_InstinctRegenCap => 118i32,
            Self::EDP_InstinctRegenRate => 119i32,
            Self::EDP_ManhuntGroupMaxSearchTime => 120i32,
            Self::EDP_ManhuntGroupSearchAreaHackMaxDistance => 121i32,
            Self::EDP_ManhuntGroupSearchAreaRadius => 122i32,
            Self::EDP_MaxCoverShootActorCountMultiplier => 123i32,
            Self::EDP_MinAttentionToForceLookAt => 124i32,
            Self::EDP_MinAttentionToForceLookAtIfIncreasing => 125i32,
            Self::EDP_NPCDamageReceivedMultiplier => 126i32,
            Self::EDP_PlayerDamagePerSecondDistance => 127i32,
            Self::EDP_PlayerDamagePerSecondLimitFar => 128i32,
            Self::EDP_PlayerDamagePerSecondLimitNear => 129i32,
            Self::EDP_PlayerDamagePerSecondThreshold => 130i32,
            Self::EDP_PlayerHitPointsMax => 131i32,
            Self::EDP_PlayerHitPointsRegenerationDelay => 132i32,
            Self::EDP_PlayerHitPointsRegenerationPerSecond => 133i32,
            Self::EDP_SecurityCameras => 134i32,
            Self::EDP_SightReactionMinAttention => 135i32,
            Self::EDP_SightInvestigationMinAttention => 136i32,
            Self::EDP_ShootSpreadMax => 137i32,
            Self::EDP_ShootSpreadMin => 138i32,
            Self::EDP_ShootSpreadRange => 139i32,
            Self::EDP_SocialGreetingAngle => 140i32,
            Self::EDP_SocialGreetingCooldown => 141i32,
            Self::EDP_SocialGreetingCooldownAlertLevel => 142i32,
            Self::EDP_SocialGreetingCooldownLastSpeak => 143i32,
            Self::EDP_SocialGreetingCooldownPlayer => 144i32,
            Self::EDP_SocialGreetingCooldownSequence => 145i32,
            Self::EDP_SocialGreetingDistance => 146i32,
            Self::EDP_SocialLookAtTimeMax => 147i32,
            Self::EDP_SocialLookAtTimeMin => 148i32,
            Self::EDP_SocialSillyCooldown => 149i32,
            Self::EDP_SocialSillyDistance => 150i32,
            Self::EDP_SocialSillyTriggerTime => 151i32,
            Self::EDP_SocialStandingCooldown => 152i32,
            Self::EDP_SocialStandingDistance => 153i32,
            Self::EDP_SocialStandingDistanceImmediate => 154i32,
            Self::EDP_SocialStandingTriggerTime => 155i32,
            Self::EDP_SpotHitmanShootingDistance => 156i32,
            Self::EDP_StrictItemRules => 157i32,
            Self::EDP_COUNT => 158i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDifficultyParameter {
     const TYPE_ID: &str = "EDifficultyParameter";
}

impl StaticVariant for Vec<EDifficultyParameter> {
     const TYPE_ID: &str = "TArray<EDifficultyParameter>";
}

impl StaticVariant for Vec<Vec<EDifficultyParameter>> {
     const TYPE_ID: &str = "TArray<TArray<EDifficultyParameter>>";
}

impl Variant for EDifficultyParameter {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDifficultyParameter")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDifficultyParameter".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDifficultyParameter>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDifficultyParameter>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDifficultyParameter>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDisconnectReason {
    eNOTIFICATION,
    eCONNECTION_LOST,
    eNETWORK_STATE,
}

impl Aligned for EDisconnectReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDisconnectReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNOTIFICATION => 0i32,
            Self::eCONNECTION_LOST => 1i32,
            Self::eNETWORK_STATE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDisconnectReason {
     const TYPE_ID: &str = "EDisconnectReason";
}

impl StaticVariant for Vec<EDisconnectReason> {
     const TYPE_ID: &str = "TArray<EDisconnectReason>";
}

impl StaticVariant for Vec<Vec<EDisconnectReason>> {
     const TYPE_ID: &str = "TArray<TArray<EDisconnectReason>>";
}

impl Variant for EDisconnectReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDisconnectReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDisconnectReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDisconnectReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDisconnectReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDisconnectReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDisposalType {
    DISPOSAL_UNDEFINED,
    DISPOSAL_NOTHING,
    DISPOSAL_HOLSTER,
    DISPOSAL_HIDE,
    DISPOSAL_PLACE,
    DISPOSAL_DROP,
    DISPOSAL_DROP_HIDE,
    DISPOSAL_DESTROY,
    DISPOSAL_COUNT,
}

impl Aligned for EDisposalType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDisposalType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DISPOSAL_UNDEFINED => 0i32,
            Self::DISPOSAL_NOTHING => 1i32,
            Self::DISPOSAL_HOLSTER => 2i32,
            Self::DISPOSAL_HIDE => 3i32,
            Self::DISPOSAL_PLACE => 4i32,
            Self::DISPOSAL_DROP => 5i32,
            Self::DISPOSAL_DROP_HIDE => 6i32,
            Self::DISPOSAL_DESTROY => 7i32,
            Self::DISPOSAL_COUNT => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDisposalType {
     const TYPE_ID: &str = "EDisposalType";
}

impl StaticVariant for Vec<EDisposalType> {
     const TYPE_ID: &str = "TArray<EDisposalType>";
}

impl StaticVariant for Vec<Vec<EDisposalType>> {
     const TYPE_ID: &str = "TArray<TArray<EDisposalType>>";
}

impl Variant for EDisposalType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDisposalType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDisposalType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDisposalType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDisposalType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDisposalType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDisturbanceType {
    DT_Generic,
    DT_SeeWeapon,
    DT_BodyNeedsBagging,
    DT_SoundCloseCombat,
    DT_SoundGunSilenced,
    DT_SoundBulletImpact,
    DT_SoundNeckBreak,
    DT_SoundSpeakPain,
    DT_SoundGunshot,
    DT_SoundExplosion,
    DT_SeeExplosion,
    DT_DeadBody,
    DT_HitmanNearDeadBody,
    DT_HitmanNearPacifiedBody,
    DT_SeeTakeKeyCard,
    DT_SeeTakeSecurityTape,
    DT_SeeChangeOutfit,
    DT_SeeTrespasser,
    DT_SeeBrokenDisguise,
    DT_SeeIllegalWeapon,
    DT_SeeDraggingBody,
    DT_SeeDeath,
    DT_SeeKilling,
    DT_UnconsciousVictim,
    DT_HuntTarget,
    DT_CrowdAlerted,
    DT_SeeGunshotVictim,
    DT_SoundThrownItem,
    DT_SoundThrownItemSeenThrowing,
    DT_HitByItemOrCoin,
    DT_PrivateAreaViolated,
    DT_SetpieceInteraction,
    DT_IllegalAction,
    DT_KnockdownMelee,
    DT_KnockdownThrow,
    DT_BumpedTooMuch,
    DT_Murder,
    DT_Strangle,
    DT_GotShot,
    DT_MurderAttempt,
    DT_LongTermMemory,
    DT_Accident,
    DT_MAX,
}

impl Aligned for EDisturbanceType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDisturbanceType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DT_Generic => 0i32,
            Self::DT_SeeWeapon => 1i32,
            Self::DT_BodyNeedsBagging => 2i32,
            Self::DT_SoundCloseCombat => 3i32,
            Self::DT_SoundGunSilenced => 4i32,
            Self::DT_SoundBulletImpact => 5i32,
            Self::DT_SoundNeckBreak => 6i32,
            Self::DT_SoundSpeakPain => 7i32,
            Self::DT_SoundGunshot => 8i32,
            Self::DT_SoundExplosion => 9i32,
            Self::DT_SeeExplosion => 10i32,
            Self::DT_DeadBody => 11i32,
            Self::DT_HitmanNearDeadBody => 12i32,
            Self::DT_HitmanNearPacifiedBody => 13i32,
            Self::DT_SeeTakeKeyCard => 14i32,
            Self::DT_SeeTakeSecurityTape => 15i32,
            Self::DT_SeeChangeOutfit => 16i32,
            Self::DT_SeeTrespasser => 17i32,
            Self::DT_SeeBrokenDisguise => 18i32,
            Self::DT_SeeIllegalWeapon => 19i32,
            Self::DT_SeeDraggingBody => 20i32,
            Self::DT_SeeDeath => 21i32,
            Self::DT_SeeKilling => 22i32,
            Self::DT_UnconsciousVictim => 23i32,
            Self::DT_HuntTarget => 24i32,
            Self::DT_CrowdAlerted => 25i32,
            Self::DT_SeeGunshotVictim => 26i32,
            Self::DT_SoundThrownItem => 27i32,
            Self::DT_SoundThrownItemSeenThrowing => 28i32,
            Self::DT_HitByItemOrCoin => 29i32,
            Self::DT_PrivateAreaViolated => 30i32,
            Self::DT_SetpieceInteraction => 31i32,
            Self::DT_IllegalAction => 32i32,
            Self::DT_KnockdownMelee => 33i32,
            Self::DT_KnockdownThrow => 34i32,
            Self::DT_BumpedTooMuch => 35i32,
            Self::DT_Murder => 36i32,
            Self::DT_Strangle => 37i32,
            Self::DT_GotShot => 38i32,
            Self::DT_MurderAttempt => 39i32,
            Self::DT_LongTermMemory => 40i32,
            Self::DT_Accident => 41i32,
            Self::DT_MAX => 42i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDisturbanceType {
     const TYPE_ID: &str = "EDisturbanceType";
}

impl StaticVariant for Vec<EDisturbanceType> {
     const TYPE_ID: &str = "TArray<EDisturbanceType>";
}

impl StaticVariant for Vec<Vec<EDisturbanceType>> {
     const TYPE_ID: &str = "TArray<TArray<EDisturbanceType>>";
}

impl Variant for EDisturbanceType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDisturbanceType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDisturbanceType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDisturbanceType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDisturbanceType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDisturbanceType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDramaEventAction {
    eDEA_NONE,
    eDEA_TERMINATE_DRAMA,
    eDEA_DONE_DRAMA,
    eDEA_STOP_BEHAVIOR,
    eDEA_DONT_STOP_SPEAK,
    eDEA_RESET_CASTING,
    eDEA_RESET_STATE,
}

impl Aligned for EDramaEventAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDramaEventAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDEA_NONE => 0i32,
            Self::eDEA_TERMINATE_DRAMA => 1i32,
            Self::eDEA_DONE_DRAMA => 2i32,
            Self::eDEA_STOP_BEHAVIOR => 4i32,
            Self::eDEA_DONT_STOP_SPEAK => 8i32,
            Self::eDEA_RESET_CASTING => 16i32,
            Self::eDEA_RESET_STATE => 32i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDramaEventAction {
     const TYPE_ID: &str = "EDramaEventAction";
}

impl StaticVariant for Vec<EDramaEventAction> {
     const TYPE_ID: &str = "TArray<EDramaEventAction>";
}

impl StaticVariant for Vec<Vec<EDramaEventAction>> {
     const TYPE_ID: &str = "TArray<TArray<EDramaEventAction>>";
}

impl Variant for EDramaEventAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDramaEventAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDramaEventAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDramaEventAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDramaEventAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDramaEventAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDramaSituationDescriptors {
    eDSD_NONE,
    eDSD_HERO,
    eDSD_CONVERSATION,
    eDSD_DISTRACTION,
    eDSD_URGENT,
    eDSD_SICK,
    eDSD_DEATH,
    eDSD_ALERT,
    eDSD_PARANOID,
    eDSD_SCARY,
    eDSD_TRIVIAL,
    eDSD_PREOCCUPIED,
    eDSD_PRIVATE,
}

impl Aligned for EDramaSituationDescriptors {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDramaSituationDescriptors {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDSD_NONE => 0i32,
            Self::eDSD_HERO => 1i32,
            Self::eDSD_CONVERSATION => 2i32,
            Self::eDSD_DISTRACTION => 4i32,
            Self::eDSD_URGENT => 8i32,
            Self::eDSD_SICK => 16i32,
            Self::eDSD_DEATH => 32i32,
            Self::eDSD_ALERT => 64i32,
            Self::eDSD_PARANOID => 128i32,
            Self::eDSD_SCARY => 256i32,
            Self::eDSD_TRIVIAL => 512i32,
            Self::eDSD_PREOCCUPIED => 1024i32,
            Self::eDSD_PRIVATE => 2048i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDramaSituationDescriptors {
     const TYPE_ID: &str = "EDramaSituationDescriptors";
}

impl StaticVariant for Vec<EDramaSituationDescriptors> {
     const TYPE_ID: &str = "TArray<EDramaSituationDescriptors>";
}

impl StaticVariant for Vec<Vec<EDramaSituationDescriptors>> {
     const TYPE_ID: &str = "TArray<TArray<EDramaSituationDescriptors>>";
}

impl Variant for EDramaSituationDescriptors {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDramaSituationDescriptors")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDramaSituationDescriptors".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDramaSituationDescriptors>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDramaSituationDescriptors>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDramaSituationDescriptors>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDramaStateFlag {
    eDSF_DEFAULT,
    eDSF_ENABLED,
    eDSF_CAST,
    eDSF_RESUMING,
    eDSF_RUNNING,
    eDSF_DONE,
    eDSF_TERMINATED,
}

impl Aligned for EDramaStateFlag {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDramaStateFlag {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDSF_DEFAULT => 0i32,
            Self::eDSF_ENABLED => 1i32,
            Self::eDSF_CAST => 2i32,
            Self::eDSF_RESUMING => 4i32,
            Self::eDSF_RUNNING => 8i32,
            Self::eDSF_DONE => 16i32,
            Self::eDSF_TERMINATED => 32i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDramaStateFlag {
     const TYPE_ID: &str = "EDramaStateFlag";
}

impl StaticVariant for Vec<EDramaStateFlag> {
     const TYPE_ID: &str = "TArray<EDramaStateFlag>";
}

impl StaticVariant for Vec<Vec<EDramaStateFlag>> {
     const TYPE_ID: &str = "TArray<TArray<EDramaStateFlag>>";
}

impl Variant for EDramaStateFlag {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDramaStateFlag")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDramaStateFlag".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDramaStateFlag>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDramaStateFlag>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDramaStateFlag>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EDynamicVariableType {
    DV_Invalid,
    DV_Me,
    DV_Hitman,
    DV_InSight,
    DV_RecentlyInSight,
    DV_Sounds,
    DV_NumVariables,
}

impl Aligned for EDynamicVariableType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EDynamicVariableType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DV_Invalid => -1i32,
            Self::DV_Me => 0i32,
            Self::DV_Hitman => 1i32,
            Self::DV_InSight => 2i32,
            Self::DV_RecentlyInSight => 3i32,
            Self::DV_Sounds => 4i32,
            Self::DV_NumVariables => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EDynamicVariableType {
     const TYPE_ID: &str = "EDynamicVariableType";
}

impl StaticVariant for Vec<EDynamicVariableType> {
     const TYPE_ID: &str = "TArray<EDynamicVariableType>";
}

impl StaticVariant for Vec<Vec<EDynamicVariableType>> {
     const TYPE_ID: &str = "TArray<TArray<EDynamicVariableType>>";
}

impl Variant for EDynamicVariableType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EDynamicVariableType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EDynamicVariableType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EDynamicVariableType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EDynamicVariableType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EDynamicVariableType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EEngineFrameUpdatePriority {
    eFUP_AILogger,
    eFUP_GridManager,
    eFrameUpdatePriority_HitmanStart,
    eFUP_ActorManager_Prepare,
    eFrameUpdatePriority_CrowdSyncAI,
    eFrameUpdatePriority_PlayerCommunicationEarly,
    eFrameUpdatePriority_Scatter,
    eFrameUpdatePriority_VolumeTriggerManager,
    eFrameUpdatePriority_DistanceToCamManager,
    eFrameUpdatePriority_Door,
    eFUP_GameEntityManager,
    eFrameUpdatePriority_AreaManager,
    eFrameUpdatePriority_SpeechManager,
    eFUP_SmoothOperator,
    eFUP_LimitedVisionArea,
    eFUP_WindManager,
    eFrameUpdatePriority_KeywordDebug,
    eFUP_DebugUPlot,
    eFUP_IntelManager,
    eFrameUpdatePriority_LocalizationManager,
    eFrameUpdatePriority_SubtitleManager,
    eFrameUpdatePriority_HttpManager,
    eFrameUpdatePriority_WebsocketManager,
    eFrameUpdatePriority_OnlineEventsClient,
    eFrameUpdatePriority_OnlineEventManager,
    eFrameUpdatePriority_OnlineManager,
    eFrameUpdatePriority_EntitlementManager,
    eFrameUpdatePriority_MetricsManager,
    eFUP_SoundGateManager,
    eFUP_SoundAmbienceManager,
    eFrameUpdatePriority_UserProfileManager,
    eFrameUpdatePriority_RenderManager,
    eFrameUpdatePriority_TextInputDialog,
    eFrameUpdatePriority_SystemDialog,
    eFrameUpdatePriority_ContractsManager,
    eFUP_ParticleHeirEmitting,
    eFrameUpdatePriority_EditorServer,
    eFrameUpdatePriority_DebugConsole,
    eFrameUpdatePriority_GraphicsSettingsManager,
    eFrameUpdatePriority_ContractsGameManager,
    eFrameUpdatePriority_Weapon,
    eFrameUpdatePriority_CrowdDensityEntity,
    eFrameUpdatePriority_ActBehaviorStateCondition,
    eFrameUpdatePriority_ActorCanSeeCondition,
    eFrameUpdatePriority_DebugCheckKey,
    eFrameUpdatePriority_KeyControl,
    eFUP_LookAtTrigger,
    eFUP_FootstepEventConsumer,
    eFUP_BloodSplatCreator,
    eFrameUpdatePriority_PersistentEntityManager,
    eFUP_ProjectedCrowdRegion,
    eFrameUpdatePriority_Timers,
    eFrameUpdatePriority_ConditionalTimer,
    eFrameUpdatePriority_ValueEntityManager,
    eFrameUpdatePriority_ActorCounter,
    eFrameUpdatePriority_WaveformGeneratorManager,
    eFUP_ItsATrap,
    eFrameUpdatePriority_SecurityCamera,
    eFrameUpdatePriority_QueryingAIOutput,
    eFrameUpdatePriority_Projectile,
    eFrameUpdatePriority_MassImpulseCharacterExploder,
    eFrameUpdatePriority_Hitman,
    eFrameUpdatePriority_AudioManagerWwise,
    eFUP_GridManagerWaitForJobs,
    eFUP_ActorManager_StateUpdate_Pre,
    eFUP_ActorManager_StateUpdate,
    eFrameUpdatePriority_ActorAnimUpdate,
    eFrameUpdatePriority_CrowdSyncAll,
    eFrameUpdatePriority_CrowdCulling,
    eFrameUpdatePriority_PreCrowd,
    eFrameUpdatePriority_Crowd,
    eFrameUpdatePriority_PhysicsStart,
    eFrameUpdatePriority_ActorManager_AIUpdate,
    eFUP_SmuggleSituationManager,
    eFrameUpdatePriority_ActorManager3,
    eFrameUpdatePriority_CharacterTemplateAspect,
    eFrameUpdatePriority_Hitman2,
    eFrameUpdatePriority_PlayerCommunicationLate,
    eFrameUpdatePriority_ParticleDecalSpawn,
    eFrameUpdatePriority_ParticleColliderEmission,
    eFrameUpdatePriority_Physics,
    eFrameUpdatePriority_EntityManager,
    eFrameUpdatePriority_FreeCameraControlEntity,
    eFrameUpdatePriority_RenderVideoPlayer,
    eFrameUpdatePriority_AnimPlayerEntityManager,
    eFrameUpdatePriority_CameraAlignedBoneAnimator,
    eFrameUpdatePriority_ClothCharacterEntity,
    eFrameUpdatePriority_TextureStreamingCameraControlEntity,
    eFrameUpdatePriority_PostFilter,
    eFrameUpdatePriority_VideoPlayerControl,
    eFrameUpdatePriority_TrackDollyController,
    eFrameUpdatePriority_TestGroup,
    eFrameUpdatePriority_LookAtEntity,
    eFUP_InfoDisplay,
    eFUP_CrowdPossedAct,
    eFUP_SoundCollisionManager,
    eFUP_AudioLevelMeter,
    eFUP_ActorInstanceEntityManager,
    eFUP_WorldInventory,
    eFUP_DestructionSystem,
    eFUP_DestructionSystemPostTick,
    eFUP_DecalSpawnManager,
    eFrameUpdatePriority_DebugHandlers,
    eFrameUpdatePriority_OSD,
    eFrameUpdatePriority_Default,
    eFrameUpdatePriority_SecuritySystemCameraUI,
    eFrameUpdatePriority_ThrownItemUI,
    eFrameUpdatePriority_SequenceManager,
    eFrameUpdatePriority_StartPathfinderUpdate,
    eFrameUpdatePriority_VisibilitySensorWait,
    eFrameUpdatePriority_ActionManagerStart,
    eFrameUpdatePriority_PathFinderJobManager,
    eFrameUpdateLinkedEntity,
    eFrameUpdatePriority_RayProbeEntity,
    eFrameUpdatePriority_GhostEntity,
    eFrameUpdateLinkedEntityManagerMainThread,
    eFUP_syncDestructionEffects,
    eFrameUpdatePriority_RaycastsStart,
    eFrameUpdatePriority_ActorStartNetworkUpdate,
    eFrameUpdatePriority_TextureManager,
    eFrameUpdatePriority_NotificationsController,
    eFrameUpdatePriority_WaitForPathfinderUpdate,
    eFrameUpdatePriority_LevelManager,
    eFrameUpdatePriority_OutfitStreamingManager,
}

impl Aligned for EEngineFrameUpdatePriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EEngineFrameUpdatePriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFUP_AILogger => 0i32,
            Self::eFUP_GridManager => 1i32,
            Self::eFrameUpdatePriority_HitmanStart => 2i32,
            Self::eFUP_ActorManager_Prepare => 3i32,
            Self::eFrameUpdatePriority_CrowdSyncAI => 4i32,
            Self::eFrameUpdatePriority_PlayerCommunicationEarly => 5i32,
            Self::eFrameUpdatePriority_Scatter => 6i32,
            Self::eFrameUpdatePriority_VolumeTriggerManager => 7i32,
            Self::eFrameUpdatePriority_DistanceToCamManager => 8i32,
            Self::eFrameUpdatePriority_Door => 9i32,
            Self::eFUP_GameEntityManager => 10i32,
            Self::eFrameUpdatePriority_AreaManager => 11i32,
            Self::eFrameUpdatePriority_SpeechManager => 12i32,
            Self::eFUP_SmoothOperator => 13i32,
            Self::eFUP_LimitedVisionArea => 14i32,
            Self::eFUP_WindManager => 15i32,
            Self::eFrameUpdatePriority_KeywordDebug => 16i32,
            Self::eFUP_DebugUPlot => 17i32,
            Self::eFUP_IntelManager => 18i32,
            Self::eFrameUpdatePriority_LocalizationManager => 19i32,
            Self::eFrameUpdatePriority_SubtitleManager => 20i32,
            Self::eFrameUpdatePriority_HttpManager => 21i32,
            Self::eFrameUpdatePriority_WebsocketManager => 22i32,
            Self::eFrameUpdatePriority_OnlineEventsClient => 23i32,
            Self::eFrameUpdatePriority_OnlineEventManager => 24i32,
            Self::eFrameUpdatePriority_OnlineManager => 25i32,
            Self::eFrameUpdatePriority_EntitlementManager => 26i32,
            Self::eFrameUpdatePriority_MetricsManager => 27i32,
            Self::eFUP_SoundGateManager => 28i32,
            Self::eFUP_SoundAmbienceManager => 29i32,
            Self::eFrameUpdatePriority_UserProfileManager => 30i32,
            Self::eFrameUpdatePriority_RenderManager => 31i32,
            Self::eFrameUpdatePriority_TextInputDialog => 32i32,
            Self::eFrameUpdatePriority_SystemDialog => 33i32,
            Self::eFrameUpdatePriority_ContractsManager => 34i32,
            Self::eFUP_ParticleHeirEmitting => 35i32,
            Self::eFrameUpdatePriority_EditorServer => 36i32,
            Self::eFrameUpdatePriority_DebugConsole => 37i32,
            Self::eFrameUpdatePriority_GraphicsSettingsManager => 38i32,
            Self::eFrameUpdatePriority_ContractsGameManager => 39i32,
            Self::eFrameUpdatePriority_Weapon => 40i32,
            Self::eFrameUpdatePriority_CrowdDensityEntity => 41i32,
            Self::eFrameUpdatePriority_ActBehaviorStateCondition => 42i32,
            Self::eFrameUpdatePriority_ActorCanSeeCondition => 43i32,
            Self::eFrameUpdatePriority_DebugCheckKey => 44i32,
            Self::eFrameUpdatePriority_KeyControl => 45i32,
            Self::eFUP_LookAtTrigger => 46i32,
            Self::eFUP_FootstepEventConsumer => 47i32,
            Self::eFUP_BloodSplatCreator => 48i32,
            Self::eFrameUpdatePriority_PersistentEntityManager => 49i32,
            Self::eFUP_ProjectedCrowdRegion => 50i32,
            Self::eFrameUpdatePriority_Timers => 51i32,
            Self::eFrameUpdatePriority_ConditionalTimer => 52i32,
            Self::eFrameUpdatePriority_ValueEntityManager => 53i32,
            Self::eFrameUpdatePriority_ActorCounter => 54i32,
            Self::eFrameUpdatePriority_WaveformGeneratorManager => 55i32,
            Self::eFUP_ItsATrap => 56i32,
            Self::eFrameUpdatePriority_SecurityCamera => 57i32,
            Self::eFrameUpdatePriority_QueryingAIOutput => 58i32,
            Self::eFrameUpdatePriority_Projectile => 59i32,
            Self::eFrameUpdatePriority_MassImpulseCharacterExploder => 60i32,
            Self::eFrameUpdatePriority_Hitman => 61i32,
            Self::eFrameUpdatePriority_AudioManagerWwise => 62i32,
            Self::eFUP_GridManagerWaitForJobs => 63i32,
            Self::eFUP_ActorManager_StateUpdate_Pre => 64i32,
            Self::eFUP_ActorManager_StateUpdate => 65i32,
            Self::eFrameUpdatePriority_ActorAnimUpdate => 66i32,
            Self::eFrameUpdatePriority_CrowdSyncAll => 67i32,
            Self::eFrameUpdatePriority_CrowdCulling => 68i32,
            Self::eFrameUpdatePriority_PreCrowd => 69i32,
            Self::eFrameUpdatePriority_Crowd => 70i32,
            Self::eFrameUpdatePriority_PhysicsStart => 71i32,
            Self::eFrameUpdatePriority_ActorManager_AIUpdate => 72i32,
            Self::eFUP_SmuggleSituationManager => 73i32,
            Self::eFrameUpdatePriority_ActorManager3 => 74i32,
            Self::eFrameUpdatePriority_CharacterTemplateAspect => 75i32,
            Self::eFrameUpdatePriority_Hitman2 => 76i32,
            Self::eFrameUpdatePriority_PlayerCommunicationLate => 77i32,
            Self::eFrameUpdatePriority_ParticleDecalSpawn => 78i32,
            Self::eFrameUpdatePriority_ParticleColliderEmission => 79i32,
            Self::eFrameUpdatePriority_Physics => 80i32,
            Self::eFrameUpdatePriority_EntityManager => 81i32,
            Self::eFrameUpdatePriority_FreeCameraControlEntity => 82i32,
            Self::eFrameUpdatePriority_RenderVideoPlayer => 83i32,
            Self::eFrameUpdatePriority_AnimPlayerEntityManager => 84i32,
            Self::eFrameUpdatePriority_CameraAlignedBoneAnimator => 85i32,
            Self::eFrameUpdatePriority_ClothCharacterEntity => 86i32,
            Self::eFrameUpdatePriority_TextureStreamingCameraControlEntity => 87i32,
            Self::eFrameUpdatePriority_PostFilter => 88i32,
            Self::eFrameUpdatePriority_VideoPlayerControl => 89i32,
            Self::eFrameUpdatePriority_TrackDollyController => 90i32,
            Self::eFrameUpdatePriority_TestGroup => 91i32,
            Self::eFrameUpdatePriority_LookAtEntity => 92i32,
            Self::eFUP_InfoDisplay => 93i32,
            Self::eFUP_CrowdPossedAct => 94i32,
            Self::eFUP_SoundCollisionManager => 95i32,
            Self::eFUP_AudioLevelMeter => 96i32,
            Self::eFUP_ActorInstanceEntityManager => 97i32,
            Self::eFUP_WorldInventory => 98i32,
            Self::eFUP_DestructionSystem => 99i32,
            Self::eFUP_DestructionSystemPostTick => 100i32,
            Self::eFUP_DecalSpawnManager => 101i32,
            Self::eFrameUpdatePriority_DebugHandlers => 102i32,
            Self::eFrameUpdatePriority_OSD => 103i32,
            Self::eFrameUpdatePriority_Default => 104i32,
            Self::eFrameUpdatePriority_SecuritySystemCameraUI => 105i32,
            Self::eFrameUpdatePriority_ThrownItemUI => 106i32,
            Self::eFrameUpdatePriority_SequenceManager => 107i32,
            Self::eFrameUpdatePriority_StartPathfinderUpdate => 108i32,
            Self::eFrameUpdatePriority_VisibilitySensorWait => 109i32,
            Self::eFrameUpdatePriority_ActionManagerStart => 110i32,
            Self::eFrameUpdatePriority_PathFinderJobManager => 111i32,
            Self::eFrameUpdateLinkedEntity => 200i32,
            Self::eFrameUpdatePriority_RayProbeEntity => 201i32,
            Self::eFrameUpdatePriority_GhostEntity => 202i32,
            Self::eFrameUpdateLinkedEntityManagerMainThread => 203i32,
            Self::eFUP_syncDestructionEffects => 204i32,
            Self::eFrameUpdatePriority_RaycastsStart => 205i32,
            Self::eFrameUpdatePriority_ActorStartNetworkUpdate => 206i32,
            Self::eFrameUpdatePriority_TextureManager => 500i32,
            Self::eFrameUpdatePriority_NotificationsController => 501i32,
            Self::eFrameUpdatePriority_WaitForPathfinderUpdate => 502i32,
            Self::eFrameUpdatePriority_LevelManager => 1000i32,
            Self::eFrameUpdatePriority_OutfitStreamingManager => 1001i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EEngineFrameUpdatePriority {
     const TYPE_ID: &str = "EEngineFrameUpdatePriority";
}

impl StaticVariant for Vec<EEngineFrameUpdatePriority> {
     const TYPE_ID: &str = "TArray<EEngineFrameUpdatePriority>";
}

impl StaticVariant for Vec<Vec<EEngineFrameUpdatePriority>> {
     const TYPE_ID: &str = "TArray<TArray<EEngineFrameUpdatePriority>>";
}

impl Variant for EEngineFrameUpdatePriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EEngineFrameUpdatePriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EEngineFrameUpdatePriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EEngineFrameUpdatePriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EEngineFrameUpdatePriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EEngineFrameUpdatePriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EEngineModeId {
    EngineMode_Invalid,
    EngineMode_SinglePlayer,
    EngineMode_SplitScreen,
    EngineMode_Multiplayer,
    EngineMode_Max,
}

impl Aligned for EEngineModeId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EEngineModeId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EngineMode_Invalid => -1i32,
            Self::EngineMode_SinglePlayer => 0i32,
            Self::EngineMode_SplitScreen => 1i32,
            Self::EngineMode_Multiplayer => 2i32,
            Self::EngineMode_Max => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EEngineModeId {
     const TYPE_ID: &str = "EEngineModeId";
}

impl StaticVariant for Vec<EEngineModeId> {
     const TYPE_ID: &str = "TArray<EEngineModeId>";
}

impl StaticVariant for Vec<Vec<EEngineModeId>> {
     const TYPE_ID: &str = "TArray<TArray<EEngineModeId>>";
}

impl Variant for EEngineModeId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EEngineModeId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EEngineModeId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EEngineModeId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EEngineModeId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EEngineModeId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EEntityOrdering {
    EO_LOW,
    EO_NORMAL,
    EO_HIGH,
}

impl Aligned for EEntityOrdering {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EEntityOrdering {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EO_LOW => 0i32,
            Self::EO_NORMAL => 1i32,
            Self::EO_HIGH => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EEntityOrdering {
     const TYPE_ID: &str = "EEntityOrdering";
}

impl StaticVariant for Vec<EEntityOrdering> {
     const TYPE_ID: &str = "TArray<EEntityOrdering>";
}

impl StaticVariant for Vec<Vec<EEntityOrdering>> {
     const TYPE_ID: &str = "TArray<TArray<EEntityOrdering>>";
}

impl Variant for EEntityOrdering {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EEntityOrdering")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EEntityOrdering".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EEntityOrdering>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EEntityOrdering>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EEntityOrdering>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EEquipAbility {
    EA_EQUIP_IN_HANDS,
    EA_CANNOT_BE_EQUIPPED,
}

impl Aligned for EEquipAbility {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EEquipAbility {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EA_EQUIP_IN_HANDS => 0i32,
            Self::EA_CANNOT_BE_EQUIPPED => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EEquipAbility {
     const TYPE_ID: &str = "EEquipAbility";
}

impl StaticVariant for Vec<EEquipAbility> {
     const TYPE_ID: &str = "TArray<EEquipAbility>";
}

impl StaticVariant for Vec<Vec<EEquipAbility>> {
     const TYPE_ID: &str = "TArray<TArray<EEquipAbility>>";
}

impl Variant for EEquipAbility {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EEquipAbility")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EEquipAbility".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EEquipAbility>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EEquipAbility>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EEquipAbility>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EEvergreenMenuLabelPurpose {
    NONE,
    ACTION_KILL_TYPE,
    POISON_LETHAL,
    POISON_EMETIC,
    POISON_SEDATIVE,
    ITEMRARITY_COMMON,
    ITEMRARITY_RARE,
    ITEMRARITY_EPIC,
    ITEMRARITY_LEGENDARY,
    LOSE_ON_WOUNDED,
}

impl Aligned for EEvergreenMenuLabelPurpose {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EEvergreenMenuLabelPurpose {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NONE => 0i32,
            Self::ACTION_KILL_TYPE => 1i32,
            Self::POISON_LETHAL => 2i32,
            Self::POISON_EMETIC => 3i32,
            Self::POISON_SEDATIVE => 4i32,
            Self::ITEMRARITY_COMMON => 5i32,
            Self::ITEMRARITY_RARE => 6i32,
            Self::ITEMRARITY_EPIC => 7i32,
            Self::ITEMRARITY_LEGENDARY => 8i32,
            Self::LOSE_ON_WOUNDED => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EEvergreenMenuLabelPurpose {
     const TYPE_ID: &str = "EEvergreenMenuLabelPurpose";
}

impl StaticVariant for Vec<EEvergreenMenuLabelPurpose> {
     const TYPE_ID: &str = "TArray<EEvergreenMenuLabelPurpose>";
}

impl StaticVariant for Vec<Vec<EEvergreenMenuLabelPurpose>> {
     const TYPE_ID: &str = "TArray<TArray<EEvergreenMenuLabelPurpose>>";
}

impl Variant for EEvergreenMenuLabelPurpose {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EEvergreenMenuLabelPurpose")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EEvergreenMenuLabelPurpose".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EEvergreenMenuLabelPurpose>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EEvergreenMenuLabelPurpose>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EEvergreenMenuLabelPurpose>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EExclusionLayer {
    EL_NONE,
    EL_STORY,
    EL_AMBIENT,
}

impl Aligned for EExclusionLayer {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EExclusionLayer {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EL_NONE => 0i32,
            Self::EL_STORY => 1i32,
            Self::EL_AMBIENT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EExclusionLayer {
     const TYPE_ID: &str = "EExclusionLayer";
}

impl StaticVariant for Vec<EExclusionLayer> {
     const TYPE_ID: &str = "TArray<EExclusionLayer>";
}

impl StaticVariant for Vec<Vec<EExclusionLayer>> {
     const TYPE_ID: &str = "TArray<TArray<EExclusionLayer>>";
}

impl Variant for EExclusionLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EExclusionLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EExclusionLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EExclusionLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EExclusionLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EExclusionLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EExtendedPropertyType {
    TYPE_RESOURCEPTR,
    TYPE_INT32,
    TYPE_UINT32,
    TYPE_FLOAT,
    TYPE_STRING,
    TYPE_BOOL,
    TYPE_ENTITYREF,
    TYPE_VARIANT,
}

impl Aligned for EExtendedPropertyType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EExtendedPropertyType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TYPE_RESOURCEPTR => 0i32,
            Self::TYPE_INT32 => 1i32,
            Self::TYPE_UINT32 => 2i32,
            Self::TYPE_FLOAT => 3i32,
            Self::TYPE_STRING => 4i32,
            Self::TYPE_BOOL => 5i32,
            Self::TYPE_ENTITYREF => 6i32,
            Self::TYPE_VARIANT => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EExtendedPropertyType {
     const TYPE_ID: &str = "EExtendedPropertyType";
}

impl StaticVariant for Vec<EExtendedPropertyType> {
     const TYPE_ID: &str = "TArray<EExtendedPropertyType>";
}

impl StaticVariant for Vec<Vec<EExtendedPropertyType>> {
     const TYPE_ID: &str = "TArray<TArray<EExtendedPropertyType>>";
}

impl Variant for EExtendedPropertyType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EExtendedPropertyType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EExtendedPropertyType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EExtendedPropertyType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EExtendedPropertyType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EExtendedPropertyType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EFSMInternalEvent {
    eFSMEvent_Completed,
    eFSMEvent_Failed,
    eFSMEvent_Choice,
    eFSMEvent_Max,
}

impl Aligned for EFSMInternalEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EFSMInternalEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFSMEvent_Completed => 0i32,
            Self::eFSMEvent_Failed => 1i32,
            Self::eFSMEvent_Choice => 2i32,
            Self::eFSMEvent_Max => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EFSMInternalEvent {
     const TYPE_ID: &str = "EFSMInternalEvent";
}

impl StaticVariant for Vec<EFSMInternalEvent> {
     const TYPE_ID: &str = "TArray<EFSMInternalEvent>";
}

impl StaticVariant for Vec<Vec<EFSMInternalEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EFSMInternalEvent>>";
}

impl Variant for EFSMInternalEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EFSMInternalEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EFSMInternalEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EFSMInternalEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EFSMInternalEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EFSMInternalEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EFSMStateStatus {
    eInactive,
    eActive,
    eCompleted,
    eFailed,
    eInterrupted,
}

impl Aligned for EFSMStateStatus {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EFSMStateStatus {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eInactive => 0i32,
            Self::eActive => 1i32,
            Self::eCompleted => 2i32,
            Self::eFailed => 3i32,
            Self::eInterrupted => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EFSMStateStatus {
     const TYPE_ID: &str = "EFSMStateStatus";
}

impl StaticVariant for Vec<EFSMStateStatus> {
     const TYPE_ID: &str = "TArray<EFSMStateStatus>";
}

impl StaticVariant for Vec<Vec<EFSMStateStatus>> {
     const TYPE_ID: &str = "TArray<TArray<EFSMStateStatus>>";
}

impl Variant for EFSMStateStatus {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EFSMStateStatus")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EFSMStateStatus".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EFSMStateStatus>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EFSMStateStatus>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EFSMStateStatus>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EFilterMaskBit {
    eFilterMaskBit_ObjectCollision,
    eFilterMaskBit_OpaqueCollision,
    eFilterMaskBit_UNUSED_LAST,
}

impl Aligned for EFilterMaskBit {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EFilterMaskBit {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFilterMaskBit_ObjectCollision => 0i8,
            Self::eFilterMaskBit_OpaqueCollision => 1i8,
            Self::eFilterMaskBit_UNUSED_LAST => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EFilterMaskBit {
     const TYPE_ID: &str = "EFilterMaskBit";
}

impl StaticVariant for Vec<EFilterMaskBit> {
     const TYPE_ID: &str = "TArray<EFilterMaskBit>";
}

impl StaticVariant for Vec<Vec<EFilterMaskBit>> {
     const TYPE_ID: &str = "TArray<TArray<EFilterMaskBit>>";
}

impl Variant for EFilterMaskBit {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EFilterMaskBit")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EFilterMaskBit".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EFilterMaskBit>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EFilterMaskBit>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EFilterMaskBit>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EFocusBarState {
    FOCUS_BAR_NORMAL,
    FOCUS_BAR_INSTINCT,
    FOCUS_BAR_BURNING,
}

impl Aligned for EFocusBarState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EFocusBarState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FOCUS_BAR_NORMAL => 0i32,
            Self::FOCUS_BAR_INSTINCT => 1i32,
            Self::FOCUS_BAR_BURNING => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EFocusBarState {
     const TYPE_ID: &str = "EFocusBarState";
}

impl StaticVariant for Vec<EFocusBarState> {
     const TYPE_ID: &str = "TArray<EFocusBarState>";
}

impl StaticVariant for Vec<Vec<EFocusBarState>> {
     const TYPE_ID: &str = "TArray<TArray<EFocusBarState>>";
}

impl Variant for EFocusBarState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EFocusBarState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EFocusBarState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EFocusBarState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EFocusBarState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EFocusBarState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EFontFlags {
    FV_Original,
    FV_NoAutoFit,
    FV_Normal,
    FV_Italic,
    FV_Bold,
    FV_BoldItalic,
    FV_FauxItalic,
    FV_FauxBold,
    FV_FauxBoldItalic,
}

impl Aligned for EFontFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EFontFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FV_Original => 16i32,
            Self::FV_NoAutoFit => 32i32,
            Self::FV_Normal => 0i32,
            Self::FV_Italic => 1i32,
            Self::FV_Bold => 2i32,
            Self::FV_BoldItalic => 3i32,
            Self::FV_FauxItalic => 4i32,
            Self::FV_FauxBold => 8i32,
            Self::FV_FauxBoldItalic => 12i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EFontFlags {
     const TYPE_ID: &str = "EFontFlags";
}

impl StaticVariant for Vec<EFontFlags> {
     const TYPE_ID: &str = "TArray<EFontFlags>";
}

impl StaticVariant for Vec<Vec<EFontFlags>> {
     const TYPE_ID: &str = "TArray<TArray<EFontFlags>>";
}

impl Variant for EFontFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EFontFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EFontFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EFontFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EFontFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EFontFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGSBodyPart {
    GSBODYPART_UNKNOWN,
    GSBODYPART_HEAD,
    GSBODYPART_TORSO,
    GSBODYPART_ARM,
    GSBODYPART_LEG,
}

impl Aligned for EGSBodyPart {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGSBodyPart {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GSBODYPART_UNKNOWN => 0i32,
            Self::GSBODYPART_HEAD => 1i32,
            Self::GSBODYPART_TORSO => 2i32,
            Self::GSBODYPART_ARM => 3i32,
            Self::GSBODYPART_LEG => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGSBodyPart {
     const TYPE_ID: &str = "EGSBodyPart";
}

impl StaticVariant for Vec<EGSBodyPart> {
     const TYPE_ID: &str = "TArray<EGSBodyPart>";
}

impl StaticVariant for Vec<Vec<EGSBodyPart>> {
     const TYPE_ID: &str = "TArray<TArray<EGSBodyPart>>";
}

impl Variant for EGSBodyPart {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGSBodyPart")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGSBodyPart".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGSBodyPart>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGSBodyPart>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGSBodyPart>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGSEvent {
    GSEvent_StrayBullet,
    GSEvent_TookDamage,
    GSEvent_UsedCover,
    GSEvent_UsedRun,
    GSEvent_UsedEliminate,
    GSEvent_UsedChokeOut,
    GSEvent_UsedKnockOutByHand,
    GSEvent_Pacified,
    GSEvent_TargetPacified,
    GSEvent_Recover,
    GSEvent_CaughtArmed,
    GSEvent_BodyFound,
    GSEvent_InvestigateCurious,
    GSEvent_NPCKilled,
    GSEvent_KilledNPCHidden,
    GSEvent_InvestigateCautious,
    GSEvent_PrecisionAimedKill,
    GSEvent_BlendInActivated,
    GSEvent_PropKill,
    GSEvent_SpottedThroughDisguise,
    GSEvent_TakeOutNonLethal,
    GSEvent_TargetKilled,
    GSEvent_NonTargetKilled,
    GSEvent_AllTargetsKilled,
    GSEvent_AccidentKill,
    GSEvent_ObjectiveUpdate,
    GSEvent_TargetAccidentKill,
    GSEvent_ObjectiveActivate,
    GSEvent_Headshot,
    GSEvent_Fiberwire,
    GSEvent_UsedEliminateSilent,
    GSEvent_ItemFound,
    GSEvent_ItemStashed,
    GSEvent_BodyBagPlaced,
    GSEvent_Projectile_HeadShot,
    GSEvent_Projectile_BodyShot,
    GSEvent_Projectile_Crowd_HeadShot,
    GSEvent_Projectile_Crowd_BodyShot,
    GSEvent_Projectile_Missed,
    GSEvent_Projectile_MultiKillTargets,
}

impl Aligned for EGSEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGSEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GSEvent_StrayBullet => 0i32,
            Self::GSEvent_TookDamage => 1i32,
            Self::GSEvent_UsedCover => 2i32,
            Self::GSEvent_UsedRun => 3i32,
            Self::GSEvent_UsedEliminate => 4i32,
            Self::GSEvent_UsedChokeOut => 5i32,
            Self::GSEvent_UsedKnockOutByHand => 6i32,
            Self::GSEvent_Pacified => 7i32,
            Self::GSEvent_TargetPacified => 8i32,
            Self::GSEvent_Recover => 9i32,
            Self::GSEvent_CaughtArmed => 10i32,
            Self::GSEvent_BodyFound => 11i32,
            Self::GSEvent_InvestigateCurious => 12i32,
            Self::GSEvent_NPCKilled => 13i32,
            Self::GSEvent_KilledNPCHidden => 14i32,
            Self::GSEvent_InvestigateCautious => 15i32,
            Self::GSEvent_PrecisionAimedKill => 16i32,
            Self::GSEvent_BlendInActivated => 17i32,
            Self::GSEvent_PropKill => 18i32,
            Self::GSEvent_SpottedThroughDisguise => 19i32,
            Self::GSEvent_TakeOutNonLethal => 20i32,
            Self::GSEvent_TargetKilled => 21i32,
            Self::GSEvent_NonTargetKilled => 22i32,
            Self::GSEvent_AllTargetsKilled => 23i32,
            Self::GSEvent_AccidentKill => 24i32,
            Self::GSEvent_ObjectiveUpdate => 25i32,
            Self::GSEvent_TargetAccidentKill => 26i32,
            Self::GSEvent_ObjectiveActivate => 27i32,
            Self::GSEvent_Headshot => 28i32,
            Self::GSEvent_Fiberwire => 29i32,
            Self::GSEvent_UsedEliminateSilent => 30i32,
            Self::GSEvent_ItemFound => 31i32,
            Self::GSEvent_ItemStashed => 32i32,
            Self::GSEvent_BodyBagPlaced => 33i32,
            Self::GSEvent_Projectile_HeadShot => 34i32,
            Self::GSEvent_Projectile_BodyShot => 35i32,
            Self::GSEvent_Projectile_Crowd_HeadShot => 36i32,
            Self::GSEvent_Projectile_Crowd_BodyShot => 37i32,
            Self::GSEvent_Projectile_Missed => 38i32,
            Self::GSEvent_Projectile_MultiKillTargets => 39i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGSEvent {
     const TYPE_ID: &str = "EGSEvent";
}

impl StaticVariant for Vec<EGSEvent> {
     const TYPE_ID: &str = "TArray<EGSEvent>";
}

impl StaticVariant for Vec<Vec<EGSEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EGSEvent>>";
}

impl Variant for EGSEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGSEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGSEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGSEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGSEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGSEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGSExplodingPropType {
    eGSExplodingProp_Unknown,
    eGSExplodingProp_Barrel,
    eGSExplodingProp_PetrolCan,
    eGSExplodingProp_GasCanister,
    eGSExplodingProp_GasTank,
    eGSExplodingProp_Mine,
    eGSExplodingProp_Pig,
    eGSExplodingProp_Pigeon,
    eGSExplodingProp_FireworksBox,
    eGSExplodingProp_Car,
}

impl Aligned for EGSExplodingPropType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGSExplodingPropType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGSExplodingProp_Unknown => 0i32,
            Self::eGSExplodingProp_Barrel => 1i32,
            Self::eGSExplodingProp_PetrolCan => 2i32,
            Self::eGSExplodingProp_GasCanister => 3i32,
            Self::eGSExplodingProp_GasTank => 4i32,
            Self::eGSExplodingProp_Mine => 5i32,
            Self::eGSExplodingProp_Pig => 6i32,
            Self::eGSExplodingProp_Pigeon => 7i32,
            Self::eGSExplodingProp_FireworksBox => 8i32,
            Self::eGSExplodingProp_Car => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGSExplodingPropType {
     const TYPE_ID: &str = "EGSExplodingPropType";
}

impl StaticVariant for Vec<EGSExplodingPropType> {
     const TYPE_ID: &str = "TArray<EGSExplodingPropType>";
}

impl StaticVariant for Vec<Vec<EGSExplodingPropType>> {
     const TYPE_ID: &str = "TArray<TArray<EGSExplodingPropType>>";
}

impl Variant for EGSExplodingPropType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGSExplodingPropType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGSExplodingPropType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGSExplodingPropType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGSExplodingPropType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGSExplodingPropType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGSKillSituation {
    GSKILLSITUATION_UNKNOWN,
    GSKILLSITUATION_CLOSECOMBAT,
    GSKILLSITUATION_SILENT,
    GSKILLSITUATION_ENVIRONMENT,
    GSKILLSITUATION_ACTION,
    GSKILLSITUATION_DEADLYTHROW,
    GSKILLSITUATION_PULLTHROUGHWINDOW,
    GSKILLSITUATION_PUSHOVERRAILING,
    GSKILLSITUATION_PACIFY,
    GSKILLSITUATION_FIBERWIRE,
}

impl Aligned for EGSKillSituation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGSKillSituation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GSKILLSITUATION_UNKNOWN => 0i32,
            Self::GSKILLSITUATION_CLOSECOMBAT => 1i32,
            Self::GSKILLSITUATION_SILENT => 2i32,
            Self::GSKILLSITUATION_ENVIRONMENT => 3i32,
            Self::GSKILLSITUATION_ACTION => 4i32,
            Self::GSKILLSITUATION_DEADLYTHROW => 5i32,
            Self::GSKILLSITUATION_PULLTHROUGHWINDOW => 6i32,
            Self::GSKILLSITUATION_PUSHOVERRAILING => 7i32,
            Self::GSKILLSITUATION_PACIFY => 8i32,
            Self::GSKILLSITUATION_FIBERWIRE => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGSKillSituation {
     const TYPE_ID: &str = "EGSKillSituation";
}

impl StaticVariant for Vec<EGSKillSituation> {
     const TYPE_ID: &str = "TArray<EGSKillSituation>";
}

impl StaticVariant for Vec<Vec<EGSKillSituation>> {
     const TYPE_ID: &str = "TArray<TArray<EGSKillSituation>>";
}

impl Variant for EGSKillSituation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGSKillSituation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGSKillSituation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGSKillSituation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGSKillSituation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGSKillSituation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGSKillVictim {
    GSKILLVICTIM_UNKNOWN,
    GSKILLVICTIM_CIVILIAN,
    GSKILLVICTIM_GUARD,
    GSKILLVICTIM_TARGET,
}

impl Aligned for EGSKillVictim {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGSKillVictim {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GSKILLVICTIM_UNKNOWN => 0i32,
            Self::GSKILLVICTIM_CIVILIAN => 1i32,
            Self::GSKILLVICTIM_GUARD => 2i32,
            Self::GSKILLVICTIM_TARGET => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGSKillVictim {
     const TYPE_ID: &str = "EGSKillVictim";
}

impl StaticVariant for Vec<EGSKillVictim> {
     const TYPE_ID: &str = "TArray<EGSKillVictim>";
}

impl StaticVariant for Vec<Vec<EGSKillVictim>> {
     const TYPE_ID: &str = "TArray<TArray<EGSKillVictim>>";
}

impl Variant for EGSKillVictim {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGSKillVictim")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGSKillVictim".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGSKillVictim>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGSKillVictim>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGSKillVictim>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGait {
    eGait_Normal,
    eGait_Reposition,
    eGait_Alert,
    eGait_Scared,
    eGait_Prone,
    eGait_Dead,
    eGait_Angry,
    eGait_Applause,
    eGait_BeatUp_000cm_01_Dual_A,
    eGait_BeatUp_000cm_01_Dual_B,
    eGait_BeatUp_000cm_02_Dual_A,
    eGait_BeatUp_000cm_02_Dual_B,
    eGait_BeatUp_Wall_Dual_A,
    eGait_BeatUp_Wall_Dual_B,
    eGait_Chatting,
    eGait_Cheer,
    eGait_Clap,
    eGait_Climb_Up_Fall,
    eGait_Concerned,
    eGait_Couples_A,
    eGait_Couples_B,
    eGait_Couples_C,
    eGait_Dance_Drunk,
    eGait_Dance_Dual_A,
    eGait_Dance_Dual_B,
    eGait_Dance_Party,
    eGait_Dance_Party_A,
    eGait_Dance_Party_B,
    eGait_Dance_Party_C,
    eGait_Dance_Party_D,
    eGait_Dance_Party_E,
    eGait_Dance_Party_F,
    eGait_Dance_Rave,
    eGait_Dance_Rave_A,
    eGait_Dance_Rave_B,
    eGait_Dance_Rave_C,
    eGait_Dance_Rave_D,
    eGait_Dance_Rave_E,
    eGait_Dance_Rave_F,
    eGait_Dance_Rave_Zone_Out_A,
    eGait_Dance_Rave_Zone_Out_B,
    eGait_Dance_Rave_Zone_Out_C,
    eGait_Dance_Rave_Zone_Out_D,
    eGait_Dance_Rave_Zone_Out_E,
    eGait_Dance_Rave_Zone_Out_F,
    eGait_Dance_Rave_Zone_Out_G,
    eGait_Dance_Rave_Zone_Out_H,
    eGait_Excited,
    eGait_Fanatic_Fans,
    eGait_Freeze_A,
    eGait_Freeze_B,
    eGait_Freeze_C,
    eGait_Freeze_Lean_Wall,
    eGait_Haggle,
    eGait_Interested,
    eGait_Jeer,
    eGait_Lean_Rail,
    eGait_Lean_Wall,
    eGait_Lie_WritheInPain,
    eGait_LookAt_Race_A,
    eGait_LookAt_Race_B,
    eGait_LookUp_Excited,
    eGait_Mingle,
    eGait_Mingle_120cm,
    eGait_Mingle_Drunk,
    eGait_Mingle_Rave_A,
    eGait_Mingle_Rave_B,
    eGait_Mingle_Rave_C,
    eGait_Mingle_Mumbai_A,
    eGait_Mingle_Mumbai_B,
    eGait_Mingle_Race,
    eGait_Mingle_Race_Rail,
    eGait_Mingle_Wall,
    eGait_Pacing_Angry,
    eGait_Party,
    eGait_Protest,
    eGait_Push_Gate,
    eGait_Rally,
    eGait_Reaction_TearGas,
    eGait_Shocked,
    eGait_Shop,
    eGait_Sit_020cm,
    eGait_Sit_040cm,
    eGait_Sit_100cm,
    eGait_Sit_ChairBasic,
    eGait_Sit_ChairBasic_LeanForward,
    eGait_Sit_Chair_Rave_A,
    eGait_Sit_Chair_Rave_B,
    eGait_Sit_Chair_Rave_C,
    eGait_Sit_Ground_Hungover,
    eGait_Squat_Relaxed,
    eGait_Squat_Sorting,
    eGait_Throw_Rice,
    eGait_Wait_Excited,
    eGait_Wait_InLine,
    eGait_WarmHands_100cm,
    eGait_Wave_Mexican,
    eGait_Yell_Up,
    eGait_Custom0,
    eGait_Custom1,
    eGait_Custom2,
    eGait_Custom3,
    eGait_Custom4,
    eGait_Custom5,
    eGait_Custom6,
    eGait_Custom7,
    eGait_Custom8,
    eGait_Custom9,
}

impl Aligned for EGait {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGait {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGait_Normal => 0i32,
            Self::eGait_Reposition => 1i32,
            Self::eGait_Alert => 2i32,
            Self::eGait_Scared => 3i32,
            Self::eGait_Prone => 4i32,
            Self::eGait_Dead => 5i32,
            Self::eGait_Angry => 6i32,
            Self::eGait_Applause => 7i32,
            Self::eGait_BeatUp_000cm_01_Dual_A => 8i32,
            Self::eGait_BeatUp_000cm_01_Dual_B => 9i32,
            Self::eGait_BeatUp_000cm_02_Dual_A => 10i32,
            Self::eGait_BeatUp_000cm_02_Dual_B => 11i32,
            Self::eGait_BeatUp_Wall_Dual_A => 12i32,
            Self::eGait_BeatUp_Wall_Dual_B => 13i32,
            Self::eGait_Chatting => 14i32,
            Self::eGait_Cheer => 15i32,
            Self::eGait_Clap => 16i32,
            Self::eGait_Climb_Up_Fall => 17i32,
            Self::eGait_Concerned => 18i32,
            Self::eGait_Couples_A => 19i32,
            Self::eGait_Couples_B => 20i32,
            Self::eGait_Couples_C => 21i32,
            Self::eGait_Dance_Drunk => 22i32,
            Self::eGait_Dance_Dual_A => 23i32,
            Self::eGait_Dance_Dual_B => 24i32,
            Self::eGait_Dance_Party => 25i32,
            Self::eGait_Dance_Party_A => 26i32,
            Self::eGait_Dance_Party_B => 27i32,
            Self::eGait_Dance_Party_C => 28i32,
            Self::eGait_Dance_Party_D => 29i32,
            Self::eGait_Dance_Party_E => 30i32,
            Self::eGait_Dance_Party_F => 31i32,
            Self::eGait_Dance_Rave => 32i32,
            Self::eGait_Dance_Rave_A => 33i32,
            Self::eGait_Dance_Rave_B => 34i32,
            Self::eGait_Dance_Rave_C => 35i32,
            Self::eGait_Dance_Rave_D => 36i32,
            Self::eGait_Dance_Rave_E => 37i32,
            Self::eGait_Dance_Rave_F => 38i32,
            Self::eGait_Dance_Rave_Zone_Out_A => 39i32,
            Self::eGait_Dance_Rave_Zone_Out_B => 40i32,
            Self::eGait_Dance_Rave_Zone_Out_C => 41i32,
            Self::eGait_Dance_Rave_Zone_Out_D => 42i32,
            Self::eGait_Dance_Rave_Zone_Out_E => 43i32,
            Self::eGait_Dance_Rave_Zone_Out_F => 44i32,
            Self::eGait_Dance_Rave_Zone_Out_G => 45i32,
            Self::eGait_Dance_Rave_Zone_Out_H => 46i32,
            Self::eGait_Excited => 47i32,
            Self::eGait_Fanatic_Fans => 48i32,
            Self::eGait_Freeze_A => 49i32,
            Self::eGait_Freeze_B => 50i32,
            Self::eGait_Freeze_C => 51i32,
            Self::eGait_Freeze_Lean_Wall => 52i32,
            Self::eGait_Haggle => 53i32,
            Self::eGait_Interested => 54i32,
            Self::eGait_Jeer => 55i32,
            Self::eGait_Lean_Rail => 56i32,
            Self::eGait_Lean_Wall => 57i32,
            Self::eGait_Lie_WritheInPain => 58i32,
            Self::eGait_LookAt_Race_A => 59i32,
            Self::eGait_LookAt_Race_B => 60i32,
            Self::eGait_LookUp_Excited => 61i32,
            Self::eGait_Mingle => 62i32,
            Self::eGait_Mingle_120cm => 63i32,
            Self::eGait_Mingle_Drunk => 64i32,
            Self::eGait_Mingle_Rave_A => 65i32,
            Self::eGait_Mingle_Rave_B => 66i32,
            Self::eGait_Mingle_Rave_C => 67i32,
            Self::eGait_Mingle_Mumbai_A => 68i32,
            Self::eGait_Mingle_Mumbai_B => 69i32,
            Self::eGait_Mingle_Race => 70i32,
            Self::eGait_Mingle_Race_Rail => 71i32,
            Self::eGait_Mingle_Wall => 72i32,
            Self::eGait_Pacing_Angry => 73i32,
            Self::eGait_Party => 74i32,
            Self::eGait_Protest => 75i32,
            Self::eGait_Push_Gate => 76i32,
            Self::eGait_Rally => 77i32,
            Self::eGait_Reaction_TearGas => 78i32,
            Self::eGait_Shocked => 79i32,
            Self::eGait_Shop => 80i32,
            Self::eGait_Sit_020cm => 81i32,
            Self::eGait_Sit_040cm => 82i32,
            Self::eGait_Sit_100cm => 83i32,
            Self::eGait_Sit_ChairBasic => 84i32,
            Self::eGait_Sit_ChairBasic_LeanForward => 85i32,
            Self::eGait_Sit_Chair_Rave_A => 86i32,
            Self::eGait_Sit_Chair_Rave_B => 87i32,
            Self::eGait_Sit_Chair_Rave_C => 88i32,
            Self::eGait_Sit_Ground_Hungover => 89i32,
            Self::eGait_Squat_Relaxed => 90i32,
            Self::eGait_Squat_Sorting => 91i32,
            Self::eGait_Throw_Rice => 92i32,
            Self::eGait_Wait_Excited => 93i32,
            Self::eGait_Wait_InLine => 94i32,
            Self::eGait_WarmHands_100cm => 95i32,
            Self::eGait_Wave_Mexican => 96i32,
            Self::eGait_Yell_Up => 97i32,
            Self::eGait_Custom0 => 98i32,
            Self::eGait_Custom1 => 99i32,
            Self::eGait_Custom2 => 100i32,
            Self::eGait_Custom3 => 101i32,
            Self::eGait_Custom4 => 102i32,
            Self::eGait_Custom5 => 103i32,
            Self::eGait_Custom6 => 104i32,
            Self::eGait_Custom7 => 105i32,
            Self::eGait_Custom8 => 106i32,
            Self::eGait_Custom9 => 107i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGait {
     const TYPE_ID: &str = "EGait";
}

impl StaticVariant for Vec<EGait> {
     const TYPE_ID: &str = "TArray<EGait>";
}

impl StaticVariant for Vec<Vec<EGait>> {
     const TYPE_ID: &str = "TArray<TArray<EGait>>";
}

impl Variant for EGait {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGait")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGait".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGait>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGait>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGait>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGameEventArgType {
    GE_ARGS_KILL,
    GE_ARGS_PRIORITYKILL,
    GE_ARGS_SITUATION,
    GE_ARGS_INVENTORY,
    GE_ARGS_EXPLODINGPROP,
    GE_ARGS_EVENT,
    GE_ARGS_CHECKPOINTEVENT,
    GE_ARGS_AI_SITUATION,
}

impl Aligned for EGameEventArgType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGameEventArgType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GE_ARGS_KILL => 0i32,
            Self::GE_ARGS_PRIORITYKILL => 1i32,
            Self::GE_ARGS_SITUATION => 2i32,
            Self::GE_ARGS_INVENTORY => 3i32,
            Self::GE_ARGS_EXPLODINGPROP => 4i32,
            Self::GE_ARGS_EVENT => 5i32,
            Self::GE_ARGS_CHECKPOINTEVENT => 6i32,
            Self::GE_ARGS_AI_SITUATION => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGameEventArgType {
     const TYPE_ID: &str = "EGameEventArgType";
}

impl StaticVariant for Vec<EGameEventArgType> {
     const TYPE_ID: &str = "TArray<EGameEventArgType>";
}

impl StaticVariant for Vec<Vec<EGameEventArgType>> {
     const TYPE_ID: &str = "TArray<TArray<EGameEventArgType>>";
}

impl Variant for EGameEventArgType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGameEventArgType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGameEventArgType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGameEventArgType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGameEventArgType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGameEventArgType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGameEventType {
    GET_GameplayStart,
    GET_GameplayStop,
    GET_IntroCutStart,
    GET_IntroCutEnd,
    GET_ProfilingStart,
    GET_SavegameRestored,
    GET_PlayingAfterLoad,
    GET_COUNT,
}

impl Aligned for EGameEventType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGameEventType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GET_GameplayStart => 0i32,
            Self::GET_GameplayStop => 1i32,
            Self::GET_IntroCutStart => 2i32,
            Self::GET_IntroCutEnd => 3i32,
            Self::GET_ProfilingStart => 4i32,
            Self::GET_SavegameRestored => 5i32,
            Self::GET_PlayingAfterLoad => 6i32,
            Self::GET_COUNT => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGameEventType {
     const TYPE_ID: &str = "EGameEventType";
}

impl StaticVariant for Vec<EGameEventType> {
     const TYPE_ID: &str = "TArray<EGameEventType>";
}

impl StaticVariant for Vec<Vec<EGameEventType>> {
     const TYPE_ID: &str = "TArray<TArray<EGameEventType>>";
}

impl Variant for EGameEventType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGameEventType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGameEventType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGameEventType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGameEventType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGameEventType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGameModeId {
    GameMode_Invalid,
    GameMode_Normal,
    GameMode_Sniper,
    GameMode_Versus,
    GameMode_Max,
}

impl Aligned for EGameModeId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGameModeId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GameMode_Invalid => -1i32,
            Self::GameMode_Normal => 0i32,
            Self::GameMode_Sniper => 1i32,
            Self::GameMode_Versus => 2i32,
            Self::GameMode_Max => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGameModeId {
     const TYPE_ID: &str = "EGameModeId";
}

impl StaticVariant for Vec<EGameModeId> {
     const TYPE_ID: &str = "TArray<EGameModeId>";
}

impl StaticVariant for Vec<Vec<EGameModeId>> {
     const TYPE_ID: &str = "TArray<TArray<EGameModeId>>";
}

impl Variant for EGameModeId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGameModeId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGameModeId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGameModeId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGameModeId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGameModeId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGameTension {
    EGT_Undefined,
    EGT_Ambient,
    EGT_Agitated,
    EGT_Searching,
    EGT_AlertedLow,
    EGT_AlertedHigh,
    EGT_Hunting,
    EGT_Arrest,
    EGT_Combat,
}

impl Aligned for EGameTension {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGameTension {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EGT_Undefined => 0i32,
            Self::EGT_Ambient => 1i32,
            Self::EGT_Agitated => 2i32,
            Self::EGT_Searching => 3i32,
            Self::EGT_AlertedLow => 4i32,
            Self::EGT_AlertedHigh => 5i32,
            Self::EGT_Hunting => 6i32,
            Self::EGT_Arrest => 7i32,
            Self::EGT_Combat => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGameTension {
     const TYPE_ID: &str = "EGameTension";
}

impl StaticVariant for Vec<EGameTension> {
     const TYPE_ID: &str = "TArray<EGameTension>";
}

impl StaticVariant for Vec<Vec<EGameTension>> {
     const TYPE_ID: &str = "TArray<TArray<EGameTension>>";
}

impl Variant for EGameTension {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGameTension")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGameTension".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGameTension>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGameTension>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGameTension>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGameUIMenu {
    eUIMenu_IntroMenu,
    eUIMenu_PauseMenu,
    eUIMenu_PhoneMenu,
    eUIMenu_MapMenu,
    eUIMenu_ModalDialogMenu,
    eUIMenu_GameplayMenu,
    eUIMenu_InventorySelectorMenu,
    eUIMenu_ActionSelectorMenu,
    eUIMenu_ActionSelectorInventoryMenu,
    eUIMenu_IntelSelectorMenu,
    eUIMenu_NotebookMenu,
    eUIMenu_LogbookMenu,
    eUIMenu_TutorialMenu,
    eUIMenu_SplashHintMenu,
    eUIMenu_EmoteMenu,
    eUIMenu_WardrobeMenu,
    eUIMenu_Count,
}

impl Aligned for EGameUIMenu {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGameUIMenu {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eUIMenu_IntroMenu => 0i32,
            Self::eUIMenu_PauseMenu => 1i32,
            Self::eUIMenu_PhoneMenu => 2i32,
            Self::eUIMenu_MapMenu => 3i32,
            Self::eUIMenu_ModalDialogMenu => 4i32,
            Self::eUIMenu_GameplayMenu => 5i32,
            Self::eUIMenu_InventorySelectorMenu => 6i32,
            Self::eUIMenu_ActionSelectorMenu => 7i32,
            Self::eUIMenu_ActionSelectorInventoryMenu => 8i32,
            Self::eUIMenu_IntelSelectorMenu => 9i32,
            Self::eUIMenu_NotebookMenu => 10i32,
            Self::eUIMenu_LogbookMenu => 11i32,
            Self::eUIMenu_TutorialMenu => 12i32,
            Self::eUIMenu_SplashHintMenu => 13i32,
            Self::eUIMenu_EmoteMenu => 14i32,
            Self::eUIMenu_WardrobeMenu => 15i32,
            Self::eUIMenu_Count => 16i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGameUIMenu {
     const TYPE_ID: &str = "EGameUIMenu";
}

impl StaticVariant for Vec<EGameUIMenu> {
     const TYPE_ID: &str = "TArray<EGameUIMenu>";
}

impl StaticVariant for Vec<Vec<EGameUIMenu>> {
     const TYPE_ID: &str = "TArray<TArray<EGameUIMenu>>";
}

impl Variant for EGameUIMenu {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGameUIMenu")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGameUIMenu".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGameUIMenu>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGameUIMenu>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGameUIMenu>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGestureCategory {
    EGC_None,
    EGC_AmbientDialog,
    EGC_TrespassWarn1,
    EGC_TrespassWarn2,
    EGC_TrespassWarn3,
    EGC_StopWarn,
}

impl Aligned for EGestureCategory {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGestureCategory {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EGC_None => 0i32,
            Self::EGC_AmbientDialog => 1i32,
            Self::EGC_TrespassWarn1 => 2i32,
            Self::EGC_TrespassWarn2 => 3i32,
            Self::EGC_TrespassWarn3 => 4i32,
            Self::EGC_StopWarn => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGestureCategory {
     const TYPE_ID: &str = "EGestureCategory";
}

impl StaticVariant for Vec<EGestureCategory> {
     const TYPE_ID: &str = "TArray<EGestureCategory>";
}

impl StaticVariant for Vec<Vec<EGestureCategory>> {
     const TYPE_ID: &str = "TArray<TArray<EGestureCategory>>";
}

impl Variant for EGestureCategory {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGestureCategory")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGestureCategory".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGestureCategory>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGestureCategory>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGestureCategory>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EGuardPointType {
    GPT_Hold,
    GPT_Combat,
    GPT_CombatAndHold,
    GPT_VIPSafeRoom,
}

impl Aligned for EGuardPointType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EGuardPointType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GPT_Hold => 0i32,
            Self::GPT_Combat => 1i32,
            Self::GPT_CombatAndHold => 2i32,
            Self::GPT_VIPSafeRoom => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EGuardPointType {
     const TYPE_ID: &str = "EGuardPointType";
}

impl StaticVariant for Vec<EGuardPointType> {
     const TYPE_ID: &str = "TArray<EGuardPointType>";
}

impl StaticVariant for Vec<Vec<EGuardPointType>> {
     const TYPE_ID: &str = "TArray<TArray<EGuardPointType>>";
}

impl Variant for EGuardPointType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EGuardPointType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EGuardPointType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EGuardPointType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EGuardPointType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EGuardPointType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5GameInputFlag {
    eGameInputActionPerform,
    eGameInputActionPickup,
    eGameInputActionAbort,
    eGameInputActionDoor,
    eGameInputWeaponZoomIn,
    eGameInputWeaponZoomOut,
    eGameInputActionShoot,
    eGameInputActionPrecisionShoot,
    eGameInputAimOTS,
    eGameInputCoverAction,
    eGameInputCoverAlternativeAction,
    eGameInputInventoryAccept,
    eGameInputEquipShortRange,
    eGameInputEquipLongRange,
    eGameInputHolsterItem,
    eGameInputDropItem,
    eGameInputDropSuitcase,
    eGameInputTogglePlacement,
    eGameInputActivatePropQuick,
    eGameInputActivateProp,
    eGameInputActivatePropHold,
    eGameInputActivatePropSecondary,
    eGameInputActivatePropInterruptibleStart,
    eGameInputActivatePropInterruptibleEnd,
    eGameInputConcealRetrieve,
    eGameInputGuideAction,
    eGameInputGuideActionHold,
    eGameInputGuideActionSecondary,
    eGameInputGuideEnterWindow,
    eGameInputGuideSneakPastWindow,
    eGameInputGuideKill,
    eGameInputSlideLadder,
    eGameInputCloseCombat,
    eGameInputFiberwire,
    eGameInputCloseCombatCounter,
    eGameInputCloseCombatTakeDown,
    eGameInputCloseCombatSnapNeck,
    eGameInputSurrender,
    eGameInputShowItem,
    eGameInputReload,
    eGameInputTakeDisguise,
    eGameInputDragDropBody,
    eGameInputDumpBody,
    eGameInputSneakToggle,
    eGameInputCamSwitch,
    eGameInputActivateRun,
    eGameInputActivateWalkSlow,
    eGameInputInstinctMode,
    eGameInputContractTargetTag,
    eGameInputThrow,
    eGameInputCloseCombatChainHigh,
    eGameInputCloseCombatChainLow,
    eGameInputCloseCombatChainCounter,
    eGameInputSkipCutSequence,
    eGameInputCloseCombatChokeStart,
    eGameInputCloseCombatChoke,
    eGameInputFocusedInteractionFaceUp,
    eGameInputFocusedInteractionFaceLeft,
    eGameInputFocusedInteractionFaceDown,
    eGameInputFocusedInteractionLeftStickAnalog,
    eGameInputRemoteAction,
    eGameInputChangeAmmoNext,
    eGameInputChangeAmmoPrevious,
    eGameInputDefault,
    eGameInputActionsNUM,
}

impl Aligned for EHM5GameInputFlag {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5GameInputFlag {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGameInputActionPerform => 0i32,
            Self::eGameInputActionPickup => 1i32,
            Self::eGameInputActionAbort => 2i32,
            Self::eGameInputActionDoor => 3i32,
            Self::eGameInputWeaponZoomIn => 4i32,
            Self::eGameInputWeaponZoomOut => 5i32,
            Self::eGameInputActionShoot => 6i32,
            Self::eGameInputActionPrecisionShoot => 7i32,
            Self::eGameInputAimOTS => 8i32,
            Self::eGameInputCoverAction => 9i32,
            Self::eGameInputCoverAlternativeAction => 10i32,
            Self::eGameInputInventoryAccept => 11i32,
            Self::eGameInputEquipShortRange => 12i32,
            Self::eGameInputEquipLongRange => 13i32,
            Self::eGameInputHolsterItem => 14i32,
            Self::eGameInputDropItem => 15i32,
            Self::eGameInputDropSuitcase => 16i32,
            Self::eGameInputTogglePlacement => 17i32,
            Self::eGameInputActivatePropQuick => 18i32,
            Self::eGameInputActivateProp => 19i32,
            Self::eGameInputActivatePropHold => 20i32,
            Self::eGameInputActivatePropSecondary => 21i32,
            Self::eGameInputActivatePropInterruptibleStart => 22i32,
            Self::eGameInputActivatePropInterruptibleEnd => 23i32,
            Self::eGameInputConcealRetrieve => 24i32,
            Self::eGameInputGuideAction => 25i32,
            Self::eGameInputGuideActionHold => 26i32,
            Self::eGameInputGuideActionSecondary => 27i32,
            Self::eGameInputGuideEnterWindow => 28i32,
            Self::eGameInputGuideSneakPastWindow => 29i32,
            Self::eGameInputGuideKill => 30i32,
            Self::eGameInputSlideLadder => 31i32,
            Self::eGameInputCloseCombat => 32i32,
            Self::eGameInputFiberwire => 33i32,
            Self::eGameInputCloseCombatCounter => 34i32,
            Self::eGameInputCloseCombatTakeDown => 35i32,
            Self::eGameInputCloseCombatSnapNeck => 36i32,
            Self::eGameInputSurrender => 37i32,
            Self::eGameInputShowItem => 38i32,
            Self::eGameInputReload => 39i32,
            Self::eGameInputTakeDisguise => 40i32,
            Self::eGameInputDragDropBody => 41i32,
            Self::eGameInputDumpBody => 42i32,
            Self::eGameInputSneakToggle => 43i32,
            Self::eGameInputCamSwitch => 44i32,
            Self::eGameInputActivateRun => 45i32,
            Self::eGameInputActivateWalkSlow => 46i32,
            Self::eGameInputInstinctMode => 47i32,
            Self::eGameInputContractTargetTag => 48i32,
            Self::eGameInputThrow => 49i32,
            Self::eGameInputCloseCombatChainHigh => 50i32,
            Self::eGameInputCloseCombatChainLow => 51i32,
            Self::eGameInputCloseCombatChainCounter => 52i32,
            Self::eGameInputSkipCutSequence => 53i32,
            Self::eGameInputCloseCombatChokeStart => 54i32,
            Self::eGameInputCloseCombatChoke => 55i32,
            Self::eGameInputFocusedInteractionFaceUp => 56i32,
            Self::eGameInputFocusedInteractionFaceLeft => 57i32,
            Self::eGameInputFocusedInteractionFaceDown => 58i32,
            Self::eGameInputFocusedInteractionLeftStickAnalog => 59i32,
            Self::eGameInputRemoteAction => 60i32,
            Self::eGameInputChangeAmmoNext => 61i32,
            Self::eGameInputChangeAmmoPrevious => 62i32,
            Self::eGameInputDefault => 63i32,
            Self::eGameInputActionsNUM => 64i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5GameInputFlag {
     const TYPE_ID: &str = "EHM5GameInputFlag";
}

impl StaticVariant for Vec<EHM5GameInputFlag> {
     const TYPE_ID: &str = "TArray<EHM5GameInputFlag>";
}

impl StaticVariant for Vec<Vec<EHM5GameInputFlag>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5GameInputFlag>>";
}

impl Variant for EHM5GameInputFlag {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5GameInputFlag")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5GameInputFlag".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5GameInputFlag>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5GameInputFlag>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5GameInputFlag>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundBulletType {
    ESBT_SMALL,
    ESBT_MEDIUM,
    ESBT_LARGE,
    ESBT_GORGEOUS,
    ESBT_ANY,
}

impl Aligned for EHM5SoundBulletType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundBulletType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESBT_SMALL => 0i32,
            Self::ESBT_MEDIUM => 1i32,
            Self::ESBT_LARGE => 2i32,
            Self::ESBT_GORGEOUS => 3i32,
            Self::ESBT_ANY => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundBulletType {
     const TYPE_ID: &str = "EHM5SoundBulletType";
}

impl StaticVariant for Vec<EHM5SoundBulletType> {
     const TYPE_ID: &str = "TArray<EHM5SoundBulletType>";
}

impl StaticVariant for Vec<Vec<EHM5SoundBulletType>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundBulletType>>";
}

impl Variant for EHM5SoundBulletType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundBulletType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundBulletType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundBulletType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundBulletType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundBulletType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundCloseCombatEvent {
    ECCE_PUNCH_FACE,
    ECCE_PUNCH_BODY,
    ECCE_ATTACK_ELBOW,
    ECCE_ATTACK_KNEE,
    ECCE_ATTACK_KICK,
    ECCE_SWOOSH_SHORT,
    ECCE_SWOOSH_LONG,
    ECCE_CLOTH_SWOOSH,
    ECCE_CLOTH_RUSTLE,
    ECCE_CLOTH_STRETCH,
    ECCE_GRAB,
    ECCE_BONE_BREAK,
    ECCE_NECK_SNAP,
    ECCE_BODY_FALL,
    ECCE_SKULL_CRACK,
    ECCE_ANY,
}

impl Aligned for EHM5SoundCloseCombatEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundCloseCombatEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECCE_PUNCH_FACE => 0i32,
            Self::ECCE_PUNCH_BODY => 1i32,
            Self::ECCE_ATTACK_ELBOW => 2i32,
            Self::ECCE_ATTACK_KNEE => 3i32,
            Self::ECCE_ATTACK_KICK => 4i32,
            Self::ECCE_SWOOSH_SHORT => 5i32,
            Self::ECCE_SWOOSH_LONG => 6i32,
            Self::ECCE_CLOTH_SWOOSH => 7i32,
            Self::ECCE_CLOTH_RUSTLE => 8i32,
            Self::ECCE_CLOTH_STRETCH => 9i32,
            Self::ECCE_GRAB => 10i32,
            Self::ECCE_BONE_BREAK => 11i32,
            Self::ECCE_NECK_SNAP => 12i32,
            Self::ECCE_BODY_FALL => 13i32,
            Self::ECCE_SKULL_CRACK => 14i32,
            Self::ECCE_ANY => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundCloseCombatEvent {
     const TYPE_ID: &str = "EHM5SoundCloseCombatEvent";
}

impl StaticVariant for Vec<EHM5SoundCloseCombatEvent> {
     const TYPE_ID: &str = "TArray<EHM5SoundCloseCombatEvent>";
}

impl StaticVariant for Vec<Vec<EHM5SoundCloseCombatEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundCloseCombatEvent>>";
}

impl Variant for EHM5SoundCloseCombatEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundCloseCombatEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundCloseCombatEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundCloseCombatEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundCloseCombatEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundCloseCombatEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundFootstepEmitterTarget {
    EFSAT_MAIN,
    EFSAT_NPC,
}

impl Aligned for EHM5SoundFootstepEmitterTarget {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundFootstepEmitterTarget {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EFSAT_MAIN => 0i32,
            Self::EFSAT_NPC => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundFootstepEmitterTarget {
     const TYPE_ID: &str = "EHM5SoundFootstepEmitterTarget";
}

impl StaticVariant for Vec<EHM5SoundFootstepEmitterTarget> {
     const TYPE_ID: &str = "TArray<EHM5SoundFootstepEmitterTarget>";
}

impl StaticVariant for Vec<Vec<EHM5SoundFootstepEmitterTarget>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundFootstepEmitterTarget>>";
}

impl Variant for EHM5SoundFootstepEmitterTarget {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundFootstepEmitterTarget")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundFootstepEmitterTarget".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundFootstepEmitterTarget>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundFootstepEmitterTarget>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundFootstepEmitterTarget>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundFootstepEvent {
    EFSE_START,
    EFSE_STOP,
    EFSE_LEFT,
    EFSE_RIGHT,
    EFSE_TURN,
    EFSE_SLIDE,
    EFSE_JUMP,
    EFSE_LAND,
}

impl Aligned for EHM5SoundFootstepEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundFootstepEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EFSE_START => 0i32,
            Self::EFSE_STOP => 1i32,
            Self::EFSE_LEFT => 2i32,
            Self::EFSE_RIGHT => 3i32,
            Self::EFSE_TURN => 4i32,
            Self::EFSE_SLIDE => 5i32,
            Self::EFSE_JUMP => 6i32,
            Self::EFSE_LAND => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundFootstepEvent {
     const TYPE_ID: &str = "EHM5SoundFootstepEvent";
}

impl StaticVariant for Vec<EHM5SoundFootstepEvent> {
     const TYPE_ID: &str = "TArray<EHM5SoundFootstepEvent>";
}

impl StaticVariant for Vec<Vec<EHM5SoundFootstepEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundFootstepEvent>>";
}

impl Variant for EHM5SoundFootstepEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundFootstepEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundFootstepEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundFootstepEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundFootstepEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundFootstepEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundFootstepStance {
    EFSS_SNEAK,
    EFSS_SNEAKRUN,
    EFSS_WALKSLOWLY,
    EFSS_WALK,
    EFSS_RUN,
    EFSS_ANY,
}

impl Aligned for EHM5SoundFootstepStance {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundFootstepStance {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EFSS_SNEAK => 0i32,
            Self::EFSS_SNEAKRUN => 1i32,
            Self::EFSS_WALKSLOWLY => 2i32,
            Self::EFSS_WALK => 3i32,
            Self::EFSS_RUN => 4i32,
            Self::EFSS_ANY => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundFootstepStance {
     const TYPE_ID: &str = "EHM5SoundFootstepStance";
}

impl StaticVariant for Vec<EHM5SoundFootstepStance> {
     const TYPE_ID: &str = "TArray<EHM5SoundFootstepStance>";
}

impl StaticVariant for Vec<Vec<EHM5SoundFootstepStance>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundFootstepStance>>";
}

impl Variant for EHM5SoundFootstepStance {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundFootstepStance")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundFootstepStance".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundFootstepStance>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundFootstepStance>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundFootstepStance>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundFootwearType {
    EFWT_UNDEFINED,
    EFWT_BAREFOOT,
    EFWT_SLIPPERS,
    EFWT_DISPOSABLE_SLIPPERS,
    EFWT_SANDALS,
    EFWT_SNEAKERS,
    EFWT_SNEAKERS_METALLEG,
    EFWT_LEATHER,
    EFWT_FEMALE_LEATHER,
    EFWT_BOOTS,
    EFWT_COWBOY_BOOTS,
    EFWT_FEMALE_COWBOY_BOOTS,
    EFWT_RUBBER_BOOTS,
    EFWT_HIGH_HEELS,
    EFWT_LEATHER_KEYS,
    EFWT_SWAT_BOOTS,
}

impl Aligned for EHM5SoundFootwearType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundFootwearType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EFWT_UNDEFINED => 0i32,
            Self::EFWT_BAREFOOT => 1i32,
            Self::EFWT_SLIPPERS => 2i32,
            Self::EFWT_DISPOSABLE_SLIPPERS => 3i32,
            Self::EFWT_SANDALS => 4i32,
            Self::EFWT_SNEAKERS => 5i32,
            Self::EFWT_SNEAKERS_METALLEG => 6i32,
            Self::EFWT_LEATHER => 7i32,
            Self::EFWT_FEMALE_LEATHER => 8i32,
            Self::EFWT_BOOTS => 9i32,
            Self::EFWT_COWBOY_BOOTS => 10i32,
            Self::EFWT_FEMALE_COWBOY_BOOTS => 11i32,
            Self::EFWT_RUBBER_BOOTS => 12i32,
            Self::EFWT_HIGH_HEELS => 13i32,
            Self::EFWT_LEATHER_KEYS => 14i32,
            Self::EFWT_SWAT_BOOTS => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundFootwearType {
     const TYPE_ID: &str = "EHM5SoundFootwearType";
}

impl StaticVariant for Vec<EHM5SoundFootwearType> {
     const TYPE_ID: &str = "TArray<EHM5SoundFootwearType>";
}

impl StaticVariant for Vec<Vec<EHM5SoundFootwearType>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundFootwearType>>";
}

impl Variant for EHM5SoundFootwearType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundFootwearType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundFootwearType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundFootwearType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundFootwearType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundFootwearType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHM5SoundRicochetType {
    ESRT_VARIATION1,
    ESRT_VARIATION2,
}

impl Aligned for EHM5SoundRicochetType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHM5SoundRicochetType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESRT_VARIATION1 => 0i32,
            Self::ESRT_VARIATION2 => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHM5SoundRicochetType {
     const TYPE_ID: &str = "EHM5SoundRicochetType";
}

impl StaticVariant for Vec<EHM5SoundRicochetType> {
     const TYPE_ID: &str = "TArray<EHM5SoundRicochetType>";
}

impl StaticVariant for Vec<Vec<EHM5SoundRicochetType>> {
     const TYPE_ID: &str = "TArray<TArray<EHM5SoundRicochetType>>";
}

impl Variant for EHM5SoundRicochetType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHM5SoundRicochetType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHM5SoundRicochetType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHM5SoundRicochetType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHM5SoundRicochetType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHM5SoundRicochetType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHUDElement {
    HUD_ELEMENT_NONE,
    HUD_ELEMENT_MINIMAP,
    HUD_ELEMENT_DISGUISE,
    HUD_ELEMENT_WEAPON_DISPLAY,
    HUD_ELEMENT_FOCUS_BAR,
    HUD_ELEMENT_RETICULES,
    HUD_ELEMENT_WEAPON_SELECTOR,
    HUD_ELEMENT_SPECIAL_BAR,
    HUD_ELEMENT_TEXT_MESSAGES,
    HUD_ELEMENT_CONTRACT_MARKS,
    HUD_ELEMENT_RATING_UPDATE,
    HUD_ELEMENT_RANKING,
    HUD_ELEMENT_CHALLENGES,
    HUD_ELEMENT_CUSTOM_TEXTS,
    HUD_ELEMENT_ACTION_BUTTONS,
    HUD_ELEMENT_ATTENTION_PEAKS,
    HUD_ELEMENT_RATING_TRACKER,
    HUD_ELEMENT_TARGET_TRACKER,
    HUD_ELEMENT_HINTS,
    HUD_ELEMENT_CONTRACT_SCORING,
    HUD_ELEMENT_TUTORIAL,
    HUD_ELEMENT_HEALTH_BAR,
    HUD_ELEMENT_OBJECTIVES,
    HUD_ALL_ELEMENTS,
}

impl Aligned for EHUDElement {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHUDElement {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HUD_ELEMENT_NONE => 0i32,
            Self::HUD_ELEMENT_MINIMAP => 1i32,
            Self::HUD_ELEMENT_DISGUISE => 2i32,
            Self::HUD_ELEMENT_WEAPON_DISPLAY => 4i32,
            Self::HUD_ELEMENT_FOCUS_BAR => 8i32,
            Self::HUD_ELEMENT_RETICULES => 16i32,
            Self::HUD_ELEMENT_WEAPON_SELECTOR => 32i32,
            Self::HUD_ELEMENT_SPECIAL_BAR => 64i32,
            Self::HUD_ELEMENT_TEXT_MESSAGES => 128i32,
            Self::HUD_ELEMENT_CONTRACT_MARKS => 256i32,
            Self::HUD_ELEMENT_RATING_UPDATE => 512i32,
            Self::HUD_ELEMENT_RANKING => 1024i32,
            Self::HUD_ELEMENT_CHALLENGES => 2048i32,
            Self::HUD_ELEMENT_CUSTOM_TEXTS => 4096i32,
            Self::HUD_ELEMENT_ACTION_BUTTONS => 8192i32,
            Self::HUD_ELEMENT_ATTENTION_PEAKS => 16384i32,
            Self::HUD_ELEMENT_RATING_TRACKER => 32768i32,
            Self::HUD_ELEMENT_TARGET_TRACKER => 65536i32,
            Self::HUD_ELEMENT_HINTS => 131072i32,
            Self::HUD_ELEMENT_CONTRACT_SCORING => 262144i32,
            Self::HUD_ELEMENT_TUTORIAL => 524288i32,
            Self::HUD_ELEMENT_HEALTH_BAR => 1048576i32,
            Self::HUD_ELEMENT_OBJECTIVES => 2097152i32,
            Self::HUD_ALL_ELEMENTS => 8388607i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHUDElement {
     const TYPE_ID: &str = "EHUDElement";
}

impl StaticVariant for Vec<EHUDElement> {
     const TYPE_ID: &str = "TArray<EHUDElement>";
}

impl StaticVariant for Vec<Vec<EHUDElement>> {
     const TYPE_ID: &str = "TArray<TArray<EHUDElement>>";
}

impl Variant for EHUDElement {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHUDElement")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHUDElement".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHUDElement>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHUDElement>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHUDElement>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHUDIconFlags {
    HUD_ICON_FLAG_POSITION,
    HUD_ICON_FLAG_VALUE,
    HUD_ICON_FLAG_SCALE,
    HUD_ICON_FLAG_TEXT,
}

impl Aligned for EHUDIconFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHUDIconFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HUD_ICON_FLAG_POSITION => 1i32,
            Self::HUD_ICON_FLAG_VALUE => 2i32,
            Self::HUD_ICON_FLAG_SCALE => 4i32,
            Self::HUD_ICON_FLAG_TEXT => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHUDIconFlags {
     const TYPE_ID: &str = "EHUDIconFlags";
}

impl StaticVariant for Vec<EHUDIconFlags> {
     const TYPE_ID: &str = "TArray<EHUDIconFlags>";
}

impl StaticVariant for Vec<Vec<EHUDIconFlags>> {
     const TYPE_ID: &str = "TArray<TArray<EHUDIconFlags>>";
}

impl Variant for EHUDIconFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHUDIconFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHUDIconFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHUDIconFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHUDIconFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHUDIconFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHUDIconType {
    HUD_ICON_NONE,
    HUD_ICON_ALARM_TIMER,
    HUD_ICON_CLOSECOMBAT,
    HUD_ICON_BREADCRUMB,
    HUD_ICON_EXIT,
    HUD_ICON_OBJECTIVE,
    HUD_ICON_TARGET,
    HUD_ICON_TUTORIAL_ARROW,
}

impl Aligned for EHUDIconType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHUDIconType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HUD_ICON_NONE => 0i32,
            Self::HUD_ICON_ALARM_TIMER => 1i32,
            Self::HUD_ICON_CLOSECOMBAT => 2i32,
            Self::HUD_ICON_BREADCRUMB => 3i32,
            Self::HUD_ICON_EXIT => 4i32,
            Self::HUD_ICON_OBJECTIVE => 5i32,
            Self::HUD_ICON_TARGET => 6i32,
            Self::HUD_ICON_TUTORIAL_ARROW => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHUDIconType {
     const TYPE_ID: &str = "EHUDIconType";
}

impl StaticVariant for Vec<EHUDIconType> {
     const TYPE_ID: &str = "TArray<EHUDIconType>";
}

impl StaticVariant for Vec<Vec<EHUDIconType>> {
     const TYPE_ID: &str = "TArray<TArray<EHUDIconType>>";
}

impl Variant for EHUDIconType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHUDIconType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHUDIconType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHUDIconType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHUDIconType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHUDIconType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHUDMessageStatus {
    HUD_MESSAGE_UNUSED,
    HUD_MESSAGE_ATTACH,
    HUD_MESSAGE_FADEIN,
    HUD_MESSAGE_DISPLAY,
    HUD_MESSAGE_FADEOUT,
}

impl Aligned for EHUDMessageStatus {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHUDMessageStatus {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HUD_MESSAGE_UNUSED => 0i32,
            Self::HUD_MESSAGE_ATTACH => 1i32,
            Self::HUD_MESSAGE_FADEIN => 2i32,
            Self::HUD_MESSAGE_DISPLAY => 3i32,
            Self::HUD_MESSAGE_FADEOUT => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHUDMessageStatus {
     const TYPE_ID: &str = "EHUDMessageStatus";
}

impl StaticVariant for Vec<EHUDMessageStatus> {
     const TYPE_ID: &str = "TArray<EHUDMessageStatus>";
}

impl StaticVariant for Vec<Vec<EHUDMessageStatus>> {
     const TYPE_ID: &str = "TArray<TArray<EHUDMessageStatus>>";
}

impl Variant for EHUDMessageStatus {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHUDMessageStatus")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHUDMessageStatus".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHUDMessageStatus>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHUDMessageStatus>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHUDMessageStatus>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHeroGameState {
    eHGS_Reserved_QueryALL,
    eHGS_Reserved_QueryAny,
    eHGS_InstinctModeActive,
    eHGS_IsHardToSee,
    eHGS_Sneaking,
    eHGS_InSequence,
    eHGS_InCloseCombat,
    eHGS_ItemHandlingActive,
    eHGS_CamSwitched,
    eHGS_SniperMode,
    eHGS_OTSMode,
    eHGS_DualWielding,
    eHGS_PreciseAim,
    eHGS_ActivatingAltFire,
    eHGS_FiredLastFrFocusBurnRate,
    eHGS_FiredLastFrFocusGainValue,
    eHGS_BurningFocus,
    eHGS_InsideCloset,
    eHGS_Peeking,
    eHGS_FocusedInteraction,
    eHGS_HoldsUtility,
    eHGS_FacingRight,
    eHGS_ThrowAiming,
    eHGS_PlaceItemAiming,
    eHGS_Reloading,
    eHGS_FiberWirePrimedAndReady,
    eHGS_OperatingDoorVRHandPush,
    eHGS_MvAgility,
    eHGS_MvCover,
    eHGS_MvDragging,
    eHGS_MvDrainPipe,
    eHGS_MvLedgeWalk,
    eHGS_MvLedgeHang,
    eHGS_MvLocomotion,
    eHGS_MvCloseCombat,
    eHGS_MvSurrendering,
    eHGS_MvFriskComplying,
    eHGS_MvShowItem,
    eHGS_MvThrow,
    eHGS_MvFiberWireKill,
    eHGS_MvAlign,
    eHGS_MvTakedown,
    eHGS_MvSubAction,
    eHGS_MvNewFullBody,
    eHGS_MvDisguiseSafeZone,
    eHGS_MvPlaceItem,
    eHGS_NUM,
}

impl Aligned for EHeroGameState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHeroGameState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHGS_Reserved_QueryALL => 0i32,
            Self::eHGS_Reserved_QueryAny => 1i32,
            Self::eHGS_InstinctModeActive => 2i32,
            Self::eHGS_IsHardToSee => 3i32,
            Self::eHGS_Sneaking => 4i32,
            Self::eHGS_InSequence => 5i32,
            Self::eHGS_InCloseCombat => 6i32,
            Self::eHGS_ItemHandlingActive => 7i32,
            Self::eHGS_CamSwitched => 8i32,
            Self::eHGS_SniperMode => 9i32,
            Self::eHGS_OTSMode => 10i32,
            Self::eHGS_DualWielding => 11i32,
            Self::eHGS_PreciseAim => 12i32,
            Self::eHGS_ActivatingAltFire => 13i32,
            Self::eHGS_FiredLastFrFocusBurnRate => 14i32,
            Self::eHGS_FiredLastFrFocusGainValue => 15i32,
            Self::eHGS_BurningFocus => 16i32,
            Self::eHGS_InsideCloset => 17i32,
            Self::eHGS_Peeking => 18i32,
            Self::eHGS_FocusedInteraction => 19i32,
            Self::eHGS_HoldsUtility => 20i32,
            Self::eHGS_FacingRight => 21i32,
            Self::eHGS_ThrowAiming => 22i32,
            Self::eHGS_PlaceItemAiming => 23i32,
            Self::eHGS_Reloading => 24i32,
            Self::eHGS_FiberWirePrimedAndReady => 25i32,
            Self::eHGS_OperatingDoorVRHandPush => 26i32,
            Self::eHGS_MvAgility => 27i32,
            Self::eHGS_MvCover => 28i32,
            Self::eHGS_MvDragging => 29i32,
            Self::eHGS_MvDrainPipe => 30i32,
            Self::eHGS_MvLedgeWalk => 31i32,
            Self::eHGS_MvLedgeHang => 32i32,
            Self::eHGS_MvLocomotion => 33i32,
            Self::eHGS_MvCloseCombat => 34i32,
            Self::eHGS_MvSurrendering => 35i32,
            Self::eHGS_MvFriskComplying => 36i32,
            Self::eHGS_MvShowItem => 37i32,
            Self::eHGS_MvThrow => 38i32,
            Self::eHGS_MvFiberWireKill => 39i32,
            Self::eHGS_MvAlign => 40i32,
            Self::eHGS_MvTakedown => 41i32,
            Self::eHGS_MvSubAction => 42i32,
            Self::eHGS_MvNewFullBody => 43i32,
            Self::eHGS_MvDisguiseSafeZone => 44i32,
            Self::eHGS_MvPlaceItem => 45i32,
            Self::eHGS_NUM => 46i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHeroGameState {
     const TYPE_ID: &str = "EHeroGameState";
}

impl StaticVariant for Vec<EHeroGameState> {
     const TYPE_ID: &str = "TArray<EHeroGameState>";
}

impl StaticVariant for Vec<Vec<EHeroGameState>> {
     const TYPE_ID: &str = "TArray<TArray<EHeroGameState>>";
}

impl Variant for EHeroGameState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHeroGameState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHeroGameState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHeroGameState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHeroGameState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHeroGameState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHeroHand {
    Left,
    Right,
}

impl Aligned for EHeroHand {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHeroHand {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Left => 0i32,
            Self::Right => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHeroHand {
     const TYPE_ID: &str = "EHeroHand";
}

impl StaticVariant for Vec<EHeroHand> {
     const TYPE_ID: &str = "TArray<EHeroHand>";
}

impl StaticVariant for Vec<Vec<EHeroHand>> {
     const TYPE_ID: &str = "TArray<TArray<EHeroHand>>";
}

impl Variant for EHeroHand {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHeroHand")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHeroHand".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHeroHand>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHeroHand>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHeroHand>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHintMessageSoundType {
    EHintMessageSound_None,
    EHintMessageSound_GeneralHint,
    EHintMessageSound_UsefulItem,
    EHintMessageSound_NeedsItem,
    EHintMessageSound_ObjectiveExit,
    EHintMessageSound_Target,
    EHintMessageSound_AccidentKill,
    EHintMessageSound_Trespassing,
    EHintMessageSound_CanBeTurnedOn,
    EHintMessageSound_CanBeTurnedOff,
    EHintMessageSound_Agility,
}

impl Aligned for EHintMessageSoundType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHintMessageSoundType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EHintMessageSound_None => 0i32,
            Self::EHintMessageSound_GeneralHint => 1i32,
            Self::EHintMessageSound_UsefulItem => 2i32,
            Self::EHintMessageSound_NeedsItem => 3i32,
            Self::EHintMessageSound_ObjectiveExit => 4i32,
            Self::EHintMessageSound_Target => 5i32,
            Self::EHintMessageSound_AccidentKill => 6i32,
            Self::EHintMessageSound_Trespassing => 7i32,
            Self::EHintMessageSound_CanBeTurnedOn => 8i32,
            Self::EHintMessageSound_CanBeTurnedOff => 9i32,
            Self::EHintMessageSound_Agility => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHintMessageSoundType {
     const TYPE_ID: &str = "EHintMessageSoundType";
}

impl StaticVariant for Vec<EHintMessageSoundType> {
     const TYPE_ID: &str = "TArray<EHintMessageSoundType>";
}

impl StaticVariant for Vec<Vec<EHintMessageSoundType>> {
     const TYPE_ID: &str = "TArray<TArray<EHintMessageSoundType>>";
}

impl Variant for EHintMessageSoundType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHintMessageSoundType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHintMessageSoundType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHintMessageSoundType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHintMessageSoundType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHintMessageSoundType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHintMessageType {
    EHintMessageType_Hint,
    EHintMessageType_InstinctHint,
    EHintMessageType_InstinctPrompt,
    EHintMessageType_Tutorial,
}

impl Aligned for EHintMessageType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHintMessageType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EHintMessageType_Hint => 0i32,
            Self::EHintMessageType_InstinctHint => 1i32,
            Self::EHintMessageType_InstinctPrompt => 2i32,
            Self::EHintMessageType_Tutorial => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHintMessageType {
     const TYPE_ID: &str = "EHintMessageType";
}

impl StaticVariant for Vec<EHintMessageType> {
     const TYPE_ID: &str = "TArray<EHintMessageType>";
}

impl StaticVariant for Vec<Vec<EHintMessageType>> {
     const TYPE_ID: &str = "TArray<TArray<EHintMessageType>>";
}

impl Variant for EHintMessageType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHintMessageType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHintMessageType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHintMessageType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHintMessageType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHintMessageType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EHitmanPermissionFlag {
    eHPFlag_InventorySelect,
    eHPFlag_CanHolsterItem,
    eHPFlag_CanDropItem,
    eHPFlag_CanDualWield,
    eHPFlag_CameraControl,
    eHPFlag_MovementControl,
    eHPFlag_AimControl,
    eHPFlag_CanOpenNotebook,
    eHPFlag_CanOpenPauseMenu,
    eHPFlag_PermissionsNUM,
}

impl Aligned for EHitmanPermissionFlag {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EHitmanPermissionFlag {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHPFlag_InventorySelect => 0i32,
            Self::eHPFlag_CanHolsterItem => 1i32,
            Self::eHPFlag_CanDropItem => 2i32,
            Self::eHPFlag_CanDualWield => 3i32,
            Self::eHPFlag_CameraControl => 4i32,
            Self::eHPFlag_MovementControl => 5i32,
            Self::eHPFlag_AimControl => 6i32,
            Self::eHPFlag_CanOpenNotebook => 7i32,
            Self::eHPFlag_CanOpenPauseMenu => 8i32,
            Self::eHPFlag_PermissionsNUM => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EHitmanPermissionFlag {
     const TYPE_ID: &str = "EHitmanPermissionFlag";
}

impl StaticVariant for Vec<EHitmanPermissionFlag> {
     const TYPE_ID: &str = "TArray<EHitmanPermissionFlag>";
}

impl StaticVariant for Vec<Vec<EHitmanPermissionFlag>> {
     const TYPE_ID: &str = "TArray<TArray<EHitmanPermissionFlag>>";
}

impl Variant for EHitmanPermissionFlag {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EHitmanPermissionFlag")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EHitmanPermissionFlag".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EHitmanPermissionFlag>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EHitmanPermissionFlag>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EHitmanPermissionFlag>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EIKEndEffector {
    BEE_Pelvis,
    BEE_SpineOrigin,
    BEE_SpineEnd,
    BEE_Head,
    BEE_LeftUpperArm,
    BEE_RightUpperArm,
    BEE_LeftForeArm,
    BEE_RightForeArm,
    BEE_LeftHand,
    BEE_LeftHandThumb,
    BEE_LeftHandIndex,
    BEE_LeftHandMiddle,
    BEE_LeftHandRing,
    BEE_LeftHandPinky,
    BEE_RightHand,
    BEE_RightHandThumb,
    BEE_RightHandIndex,
    BEE_RightHandMiddle,
    BEE_RightHandRing,
    BEE_RightHandPinky,
    BEE_LeftFoot,
    BEE_RightFoot,
    BEE_LeftToe,
    BEE_RightToe,
    BEE_Count,
}

impl Aligned for EIKEndEffector {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EIKEndEffector {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BEE_Pelvis => 0i32,
            Self::BEE_SpineOrigin => 1i32,
            Self::BEE_SpineEnd => 2i32,
            Self::BEE_Head => 3i32,
            Self::BEE_LeftUpperArm => 4i32,
            Self::BEE_RightUpperArm => 5i32,
            Self::BEE_LeftForeArm => 6i32,
            Self::BEE_RightForeArm => 7i32,
            Self::BEE_LeftHand => 8i32,
            Self::BEE_LeftHandThumb => 9i32,
            Self::BEE_LeftHandIndex => 10i32,
            Self::BEE_LeftHandMiddle => 11i32,
            Self::BEE_LeftHandRing => 12i32,
            Self::BEE_LeftHandPinky => 13i32,
            Self::BEE_RightHand => 14i32,
            Self::BEE_RightHandThumb => 15i32,
            Self::BEE_RightHandIndex => 16i32,
            Self::BEE_RightHandMiddle => 17i32,
            Self::BEE_RightHandRing => 18i32,
            Self::BEE_RightHandPinky => 19i32,
            Self::BEE_LeftFoot => 20i32,
            Self::BEE_RightFoot => 21i32,
            Self::BEE_LeftToe => 22i32,
            Self::BEE_RightToe => 23i32,
            Self::BEE_Count => 24i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EIKEndEffector {
     const TYPE_ID: &str = "EIKEndEffector";
}

impl StaticVariant for Vec<EIKEndEffector> {
     const TYPE_ID: &str = "TArray<EIKEndEffector>";
}

impl StaticVariant for Vec<Vec<EIKEndEffector>> {
     const TYPE_ID: &str = "TArray<TArray<EIKEndEffector>>";
}

impl Variant for EIKEndEffector {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EIKEndEffector")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EIKEndEffector".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EIKEndEffector>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EIKEndEffector>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EIKEndEffector>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EImpactEffectsOptions {
    eIE_None,
    eIE_BloodSplatter,
    eIE_Decals,
    eIE_MaterialImpactEffects,
    eIE_AmmoImpactEffect,
    eIE_All,
}

impl Aligned for EImpactEffectsOptions {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EImpactEffectsOptions {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIE_None => 0i32,
            Self::eIE_BloodSplatter => 1i32,
            Self::eIE_Decals => 2i32,
            Self::eIE_MaterialImpactEffects => 4i32,
            Self::eIE_AmmoImpactEffect => 8i32,
            Self::eIE_All => 16i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EImpactEffectsOptions {
     const TYPE_ID: &str = "EImpactEffectsOptions";
}

impl StaticVariant for Vec<EImpactEffectsOptions> {
     const TYPE_ID: &str = "TArray<EImpactEffectsOptions>";
}

impl StaticVariant for Vec<Vec<EImpactEffectsOptions>> {
     const TYPE_ID: &str = "TArray<TArray<EImpactEffectsOptions>>";
}

impl Variant for EImpactEffectsOptions {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EImpactEffectsOptions")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EImpactEffectsOptions".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EImpactEffectsOptions>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EImpactEffectsOptions>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EImpactEffectsOptions>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInformationBarMessage {
    eIBM_Clear,
    eIBM_LastEnemyKilledCP,
    eIBM_InvestigateStand,
    eIBM_BodyFound,
    eIBM_Suspicious,
    eIBM_DisguiseBlown,
    eIBM_Hunt,
    eIBM_Exposed,
    eIBM_LandMineArmed,
    eIBM_RadioOn,
    eIBM_Trespassing,
    eIBM_NUM,
}

impl Aligned for EInformationBarMessage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInformationBarMessage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIBM_Clear => 0i32,
            Self::eIBM_LastEnemyKilledCP => 1i32,
            Self::eIBM_InvestigateStand => 2i32,
            Self::eIBM_BodyFound => 3i32,
            Self::eIBM_Suspicious => 4i32,
            Self::eIBM_DisguiseBlown => 5i32,
            Self::eIBM_Hunt => 6i32,
            Self::eIBM_Exposed => 7i32,
            Self::eIBM_LandMineArmed => 8i32,
            Self::eIBM_RadioOn => 9i32,
            Self::eIBM_Trespassing => 10i32,
            Self::eIBM_NUM => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInformationBarMessage {
     const TYPE_ID: &str = "EInformationBarMessage";
}

impl StaticVariant for Vec<EInformationBarMessage> {
     const TYPE_ID: &str = "TArray<EInformationBarMessage>";
}

impl StaticVariant for Vec<Vec<EInformationBarMessage>> {
     const TYPE_ID: &str = "TArray<TArray<EInformationBarMessage>>";
}

impl Variant for EInformationBarMessage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInformationBarMessage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInformationBarMessage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInformationBarMessage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInformationBarMessage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInformationBarMessage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EIntelStage {
    eIT_MAIN,
    eIT_STAGE,
    eIT_HINT,
}

impl Aligned for EIntelStage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EIntelStage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIT_MAIN => 0i32,
            Self::eIT_STAGE => 1i32,
            Self::eIT_HINT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EIntelStage {
     const TYPE_ID: &str = "EIntelStage";
}

impl StaticVariant for Vec<EIntelStage> {
     const TYPE_ID: &str = "TArray<EIntelStage>";
}

impl StaticVariant for Vec<Vec<EIntelStage>> {
     const TYPE_ID: &str = "TArray<TArray<EIntelStage>>";
}

impl Variant for EIntelStage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EIntelStage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EIntelStage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EIntelStage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EIntelStage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EIntelStage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EIntelTensionLevel {
    eITL_Undefined,
    eITL_Ambient,
    eITL_Agitated,
    eITL_Searching,
    eITL_AlertedLow,
    eITL_AlertedHigh,
    eITL_Hunting,
    eITL_Arrest,
    eITL_Combat,
}

impl Aligned for EIntelTensionLevel {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EIntelTensionLevel {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eITL_Undefined => 0i32,
            Self::eITL_Ambient => 1i32,
            Self::eITL_Agitated => 2i32,
            Self::eITL_Searching => 3i32,
            Self::eITL_AlertedLow => 4i32,
            Self::eITL_AlertedHigh => 5i32,
            Self::eITL_Hunting => 6i32,
            Self::eITL_Arrest => 7i32,
            Self::eITL_Combat => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EIntelTensionLevel {
     const TYPE_ID: &str = "EIntelTensionLevel";
}

impl StaticVariant for Vec<EIntelTensionLevel> {
     const TYPE_ID: &str = "TArray<EIntelTensionLevel>";
}

impl StaticVariant for Vec<Vec<EIntelTensionLevel>> {
     const TYPE_ID: &str = "TArray<TArray<EIntelTensionLevel>>";
}

impl Variant for EIntelTensionLevel {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EIntelTensionLevel")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EIntelTensionLevel".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EIntelTensionLevel>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EIntelTensionLevel>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EIntelTensionLevel>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EIntelType {
    eIT_DATA,
    eIT_OPPORTUNITY,
    eIT_BACKGROUND,
    eIT_HANDLER,
    eIT_UNDEFINED,
}

impl Aligned for EIntelType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EIntelType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIT_DATA => 0i32,
            Self::eIT_OPPORTUNITY => 1i32,
            Self::eIT_BACKGROUND => 2i32,
            Self::eIT_HANDLER => 3i32,
            Self::eIT_UNDEFINED => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EIntelType {
     const TYPE_ID: &str = "EIntelType";
}

impl StaticVariant for Vec<EIntelType> {
     const TYPE_ID: &str = "TArray<EIntelType>";
}

impl StaticVariant for Vec<Vec<EIntelType>> {
     const TYPE_ID: &str = "TArray<TArray<EIntelType>>";
}

impl Variant for EIntelType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EIntelType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EIntelType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EIntelType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EIntelType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EIntelType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInteractionIndicatorState {
    EIIS_AVAILABLE,
    EIIS_COLLAPSED,
    EIIS_ACTIVATING,
    EIIS_NOTAVAILABLE,
}

impl Aligned for EInteractionIndicatorState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInteractionIndicatorState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIIS_AVAILABLE => 0i32,
            Self::EIIS_COLLAPSED => 1i32,
            Self::EIIS_ACTIVATING => 2i32,
            Self::EIIS_NOTAVAILABLE => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInteractionIndicatorState {
     const TYPE_ID: &str = "EInteractionIndicatorState";
}

impl StaticVariant for Vec<EInteractionIndicatorState> {
     const TYPE_ID: &str = "TArray<EInteractionIndicatorState>";
}

impl StaticVariant for Vec<Vec<EInteractionIndicatorState>> {
     const TYPE_ID: &str = "TArray<TArray<EInteractionIndicatorState>>";
}

impl Variant for EInteractionIndicatorState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInteractionIndicatorState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInteractionIndicatorState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInteractionIndicatorState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInteractionIndicatorState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInteractionIndicatorState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInteractionInputType {
    EIIT_UNKNOWN,
    EIIT_PRESS,
    EIIT_HOLD,
    EIIT_HOLD_DOWN,
    EIIT_REPEAT,
    EIIT_GUIDE,
}

impl Aligned for EInteractionInputType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInteractionInputType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIIT_UNKNOWN => 0i32,
            Self::EIIT_PRESS => 1i32,
            Self::EIIT_HOLD => 2i32,
            Self::EIIT_HOLD_DOWN => 3i32,
            Self::EIIT_REPEAT => 4i32,
            Self::EIIT_GUIDE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInteractionInputType {
     const TYPE_ID: &str = "EInteractionInputType";
}

impl StaticVariant for Vec<EInteractionInputType> {
     const TYPE_ID: &str = "TArray<EInteractionInputType>";
}

impl StaticVariant for Vec<Vec<EInteractionInputType>> {
     const TYPE_ID: &str = "TArray<TArray<EInteractionInputType>>";
}

impl Variant for EInteractionInputType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInteractionInputType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInteractionInputType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInteractionInputType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInteractionInputType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInteractionInputType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInventoryConfigCustomRule {
    EICCR_None,
    EICCR_Surrender,
    EICCR_TempDropLeftHandItem,
}

impl Aligned for EInventoryConfigCustomRule {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInventoryConfigCustomRule {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EICCR_None => 0i32,
            Self::EICCR_Surrender => 1i32,
            Self::EICCR_TempDropLeftHandItem => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInventoryConfigCustomRule {
     const TYPE_ID: &str = "EInventoryConfigCustomRule";
}

impl StaticVariant for Vec<EInventoryConfigCustomRule> {
     const TYPE_ID: &str = "TArray<EInventoryConfigCustomRule>";
}

impl StaticVariant for Vec<Vec<EInventoryConfigCustomRule>> {
     const TYPE_ID: &str = "TArray<TArray<EInventoryConfigCustomRule>>";
}

impl Variant for EInventoryConfigCustomRule {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInventoryConfigCustomRule")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInventoryConfigCustomRule".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInventoryConfigCustomRule>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInventoryConfigCustomRule>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInventoryConfigCustomRule>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInventoryConfigFormerEquippedItems {
    EICFEI_Equip,
    EICFEI_EquipOrPickup,
    EICFEI_Forget,
}

impl Aligned for EInventoryConfigFormerEquippedItems {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInventoryConfigFormerEquippedItems {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EICFEI_Equip => 0i32,
            Self::EICFEI_EquipOrPickup => 1i32,
            Self::EICFEI_Forget => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInventoryConfigFormerEquippedItems {
     const TYPE_ID: &str = "EInventoryConfigFormerEquippedItems";
}

impl StaticVariant for Vec<EInventoryConfigFormerEquippedItems> {
     const TYPE_ID: &str = "TArray<EInventoryConfigFormerEquippedItems>";
}

impl StaticVariant for Vec<Vec<EInventoryConfigFormerEquippedItems>> {
     const TYPE_ID: &str = "TArray<TArray<EInventoryConfigFormerEquippedItems>>";
}

impl Variant for EInventoryConfigFormerEquippedItems {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInventoryConfigFormerEquippedItems")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInventoryConfigFormerEquippedItems".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInventoryConfigFormerEquippedItems>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInventoryConfigFormerEquippedItems>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInventoryConfigFormerEquippedItems>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInventoryConfigItemHandling {
    EICIH_Allow,
    EICIH_Store,
    EICIH_InstaStore,
    EICIH_Drop,
    EICIH_DropOrStore,
    EICIH_DropAndPickup,
    EICIH_DoNothing,
}

impl Aligned for EInventoryConfigItemHandling {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInventoryConfigItemHandling {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EICIH_Allow => 0i32,
            Self::EICIH_Store => 1i32,
            Self::EICIH_InstaStore => 2i32,
            Self::EICIH_Drop => 3i32,
            Self::EICIH_DropOrStore => 4i32,
            Self::EICIH_DropAndPickup => 5i32,
            Self::EICIH_DoNothing => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInventoryConfigItemHandling {
     const TYPE_ID: &str = "EInventoryConfigItemHandling";
}

impl StaticVariant for Vec<EInventoryConfigItemHandling> {
     const TYPE_ID: &str = "TArray<EInventoryConfigItemHandling>";
}

impl StaticVariant for Vec<Vec<EInventoryConfigItemHandling>> {
     const TYPE_ID: &str = "TArray<TArray<EInventoryConfigItemHandling>>";
}

impl Variant for EInventoryConfigItemHandling {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInventoryConfigItemHandling")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInventoryConfigItemHandling".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInventoryConfigItemHandling>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInventoryConfigItemHandling>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInventoryConfigItemHandling>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EInventoryStorageType {
    EIST_None,
    EIST_Bag,
    EIST_RightHand,
    EIST_LeftHand,
    EIST_Back,
    EIST_Support,
    EIST_Quest,
    EIST_Temporary,
    EIST_Debug,
}

impl Aligned for EInventoryStorageType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EInventoryStorageType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIST_None => 0i32,
            Self::EIST_Bag => 1i32,
            Self::EIST_RightHand => 2i32,
            Self::EIST_LeftHand => 3i32,
            Self::EIST_Back => 4i32,
            Self::EIST_Support => 5i32,
            Self::EIST_Quest => 6i32,
            Self::EIST_Temporary => 7i32,
            Self::EIST_Debug => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EInventoryStorageType {
     const TYPE_ID: &str = "EInventoryStorageType";
}

impl StaticVariant for Vec<EInventoryStorageType> {
     const TYPE_ID: &str = "TArray<EInventoryStorageType>";
}

impl StaticVariant for Vec<Vec<EInventoryStorageType>> {
     const TYPE_ID: &str = "TArray<TArray<EInventoryStorageType>>";
}

impl Variant for EInventoryStorageType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EInventoryStorageType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EInventoryStorageType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EInventoryStorageType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EInventoryStorageType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EInventoryStorageType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemGripType {
    IGT_Empty,
    IGT_Suitcase,
    IGT_Suitcase_Big,
    IGT_Firearm_Pistol,
    IGT_Firearm_Pistol_Stealth,
    IGT_Firearm_AssaultRifle_Bullpup,
    IGT_Firearm_AssaultRifle_Carbine,
    IGT_Firearm_Shotgun,
    IGT_Firearm_SMG,
    IGT_Firearm_SMG02,
    IGT_Firearm_SniperRifle,
    IGT_Firearm_SniperRifle02,
    IGT_Firearm_Dartgun,
    IGT_Melee_1H_Baton,
    IGT_Melee_1H_Cleaver,
    IGT_Melee_1H_Hammer,
    IGT_Melee_1H_Knife,
    IGT_Melee_1H_Rock,
    IGT_Melee_1H_Screwdriver,
    IGT_Melee_1H_Stick,
    IGT_Melee_1H_Sword,
    IGT_Melee_1H_FireExtinguisher,
    IGT_Melee_1H_Bust,
    IGT_Melee_1H_Crowbar,
    IGT_Melee_1H_Syringe,
    IGT_Melee_2H_Axe,
    IGT_Melee_2H_Stick,
    IGT_Melee_2H_Sword,
    IGT_Gadget_Fiberwire,
    IGT_Gadget_Coin,
    IGT_Gadget_Vial,
    IGT_Gadget_C4,
    IGT_Gadget_Detonator,
    IGT_Gadget_Grenade_ThickGrip,
    IGT_Gadget_Grenade_ThinGrip,
    IGT_Gadget_Mine,
    IGT_Gadget_Remote,
    IGT_Prop_1H,
    IGT_Prop_1H_Duck,
    IGT_Prop_1h_Phone,
    IGT_None,
}

impl Aligned for EItemGripType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemGripType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGT_Empty => 0i32,
            Self::IGT_Suitcase => 1i32,
            Self::IGT_Suitcase_Big => 2i32,
            Self::IGT_Firearm_Pistol => 3i32,
            Self::IGT_Firearm_Pistol_Stealth => 4i32,
            Self::IGT_Firearm_AssaultRifle_Bullpup => 5i32,
            Self::IGT_Firearm_AssaultRifle_Carbine => 6i32,
            Self::IGT_Firearm_Shotgun => 7i32,
            Self::IGT_Firearm_SMG => 8i32,
            Self::IGT_Firearm_SMG02 => 9i32,
            Self::IGT_Firearm_SniperRifle => 10i32,
            Self::IGT_Firearm_SniperRifle02 => 11i32,
            Self::IGT_Firearm_Dartgun => 12i32,
            Self::IGT_Melee_1H_Baton => 13i32,
            Self::IGT_Melee_1H_Cleaver => 14i32,
            Self::IGT_Melee_1H_Hammer => 15i32,
            Self::IGT_Melee_1H_Knife => 16i32,
            Self::IGT_Melee_1H_Rock => 17i32,
            Self::IGT_Melee_1H_Screwdriver => 18i32,
            Self::IGT_Melee_1H_Stick => 19i32,
            Self::IGT_Melee_1H_Sword => 20i32,
            Self::IGT_Melee_1H_FireExtinguisher => 21i32,
            Self::IGT_Melee_1H_Bust => 22i32,
            Self::IGT_Melee_1H_Crowbar => 23i32,
            Self::IGT_Melee_1H_Syringe => 24i32,
            Self::IGT_Melee_2H_Axe => 25i32,
            Self::IGT_Melee_2H_Stick => 26i32,
            Self::IGT_Melee_2H_Sword => 27i32,
            Self::IGT_Gadget_Fiberwire => 28i32,
            Self::IGT_Gadget_Coin => 29i32,
            Self::IGT_Gadget_Vial => 30i32,
            Self::IGT_Gadget_C4 => 31i32,
            Self::IGT_Gadget_Detonator => 32i32,
            Self::IGT_Gadget_Grenade_ThickGrip => 33i32,
            Self::IGT_Gadget_Grenade_ThinGrip => 34i32,
            Self::IGT_Gadget_Mine => 35i32,
            Self::IGT_Gadget_Remote => 36i32,
            Self::IGT_Prop_1H => 37i32,
            Self::IGT_Prop_1H_Duck => 38i32,
            Self::IGT_Prop_1h_Phone => 39i32,
            Self::IGT_None => 40i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemGripType {
     const TYPE_ID: &str = "EItemGripType";
}

impl StaticVariant for Vec<EItemGripType> {
     const TYPE_ID: &str = "TArray<EItemGripType>";
}

impl StaticVariant for Vec<Vec<EItemGripType>> {
     const TYPE_ID: &str = "TArray<TArray<EItemGripType>>";
}

impl Variant for EItemGripType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemGripType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemGripType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemGripType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemGripType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemGripType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemHUDType {
    EIHT_None,
    EIHT_GhostItem,
    EIHT_OutbreakHealingItem,
}

impl Aligned for EItemHUDType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemHUDType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIHT_None => 0i32,
            Self::EIHT_GhostItem => 1i32,
            Self::EIHT_OutbreakHealingItem => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemHUDType {
     const TYPE_ID: &str = "EItemHUDType";
}

impl StaticVariant for Vec<EItemHUDType> {
     const TYPE_ID: &str = "TArray<EItemHUDType>";
}

impl StaticVariant for Vec<Vec<EItemHUDType>> {
     const TYPE_ID: &str = "TArray<TArray<EItemHUDType>>";
}

impl Variant for EItemHUDType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemHUDType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemHUDType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemHUDType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemHUDType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemHUDType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemLocation {
    eIL_Anywhere,
    eIL_Inventory,
    eIL_RightHand,
    eIL_LeftHand,
    eIL_FreeBone,
    eIL_Count,
}

impl Aligned for EItemLocation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemLocation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIL_Anywhere => 0i32,
            Self::eIL_Inventory => 1i32,
            Self::eIL_RightHand => 2i32,
            Self::eIL_LeftHand => 3i32,
            Self::eIL_FreeBone => 4i32,
            Self::eIL_Count => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemLocation {
     const TYPE_ID: &str = "EItemLocation";
}

impl StaticVariant for Vec<EItemLocation> {
     const TYPE_ID: &str = "TArray<EItemLocation>";
}

impl StaticVariant for Vec<Vec<EItemLocation>> {
     const TYPE_ID: &str = "TArray<TArray<EItemLocation>>";
}

impl Variant for EItemLocation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemLocation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemLocation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemLocation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemLocation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemLocation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemMeleeDamageBehavior {
    EIMDB_Undefined,
    EIMDB_Bouncing,
    EIMDB_Slashing,
    EIMDB_Sticking,
}

impl Aligned for EItemMeleeDamageBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemMeleeDamageBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIMDB_Undefined => 0i32,
            Self::EIMDB_Bouncing => 1i32,
            Self::EIMDB_Slashing => 2i32,
            Self::EIMDB_Sticking => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemMeleeDamageBehavior {
     const TYPE_ID: &str = "EItemMeleeDamageBehavior";
}

impl StaticVariant for Vec<EItemMeleeDamageBehavior> {
     const TYPE_ID: &str = "TArray<EItemMeleeDamageBehavior>";
}

impl StaticVariant for Vec<Vec<EItemMeleeDamageBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<EItemMeleeDamageBehavior>>";
}

impl Variant for EItemMeleeDamageBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemMeleeDamageBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemMeleeDamageBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemMeleeDamageBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemMeleeDamageBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemMeleeDamageBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemModifierType {
    MODIFIER_NONE,
    MODIFIER_THROW,
    MODIFIER_CARRY,
    MODIFIER_AMMO,
    MODIFIER_PRECISION,
    MODIFIER_DAMAGE,
    MODIFIER_IMPACT,
    MODIFIER_EXPLOSIVE,
    MODIFIER_RANGE,
    MODIFIER_ZOOM,
    MODIFIER_SUPPRESSOR,
    MODIFIER_RECOIL,
    MODIFIER_RATEOFFIRE,
    MODIFIER_SCOPEBOBBING,
    MODIFIER_MUZZLEVELOCITY,
    MODIFIER_KNOCKDOWN,
    MODIFIER_FULLAUTO,
    MODIFIER_PRECISIONSHOT,
    MODIFIER_SCOPETIMESLOWDOWN,
    MODIFIER_STYLE,
    MODIFIER_RELOAD,
    MODIFIER_THRESHOLD,
    MODIFIER_PERK,
    MODIFIER_MAGAZINE,
    MODIFIER_BURST,
}

impl Aligned for EItemModifierType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemModifierType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MODIFIER_NONE => 0i32,
            Self::MODIFIER_THROW => 1i32,
            Self::MODIFIER_CARRY => 2i32,
            Self::MODIFIER_AMMO => 3i32,
            Self::MODIFIER_PRECISION => 4i32,
            Self::MODIFIER_DAMAGE => 5i32,
            Self::MODIFIER_IMPACT => 6i32,
            Self::MODIFIER_EXPLOSIVE => 7i32,
            Self::MODIFIER_RANGE => 8i32,
            Self::MODIFIER_ZOOM => 9i32,
            Self::MODIFIER_SUPPRESSOR => 10i32,
            Self::MODIFIER_RECOIL => 11i32,
            Self::MODIFIER_RATEOFFIRE => 12i32,
            Self::MODIFIER_SCOPEBOBBING => 13i32,
            Self::MODIFIER_MUZZLEVELOCITY => 14i32,
            Self::MODIFIER_KNOCKDOWN => 15i32,
            Self::MODIFIER_FULLAUTO => 16i32,
            Self::MODIFIER_PRECISIONSHOT => 17i32,
            Self::MODIFIER_SCOPETIMESLOWDOWN => 18i32,
            Self::MODIFIER_STYLE => 19i32,
            Self::MODIFIER_RELOAD => 20i32,
            Self::MODIFIER_THRESHOLD => 21i32,
            Self::MODIFIER_PERK => 22i32,
            Self::MODIFIER_MAGAZINE => 23i32,
            Self::MODIFIER_BURST => 24i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemModifierType {
     const TYPE_ID: &str = "EItemModifierType";
}

impl StaticVariant for Vec<EItemModifierType> {
     const TYPE_ID: &str = "TArray<EItemModifierType>";
}

impl StaticVariant for Vec<Vec<EItemModifierType>> {
     const TYPE_ID: &str = "TArray<TArray<EItemModifierType>>";
}

impl Variant for EItemModifierType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemModifierType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemModifierType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemModifierType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemModifierType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemModifierType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemPoisonType {
    POISONTYPE_NONE,
    POISONTYPE_LETHAL,
    POISONTYPE_SEDATIVE,
    POISONTYPE_EMETIC,
}

impl Aligned for EItemPoisonType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemPoisonType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::POISONTYPE_NONE => 0i32,
            Self::POISONTYPE_LETHAL => 1i32,
            Self::POISONTYPE_SEDATIVE => 2i32,
            Self::POISONTYPE_EMETIC => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemPoisonType {
     const TYPE_ID: &str = "EItemPoisonType";
}

impl StaticVariant for Vec<EItemPoisonType> {
     const TYPE_ID: &str = "TArray<EItemPoisonType>";
}

impl StaticVariant for Vec<Vec<EItemPoisonType>> {
     const TYPE_ID: &str = "TArray<TArray<EItemPoisonType>>";
}

impl Variant for EItemPoisonType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemPoisonType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemPoisonType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemPoisonType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemPoisonType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemPoisonType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EItemRequirement {
    eIR_NoRequirement,
    eIR_RequireEmpty,
    eIR_RequireItem,
    eIR_RequireNoBigItem,
}

impl Aligned for EItemRequirement {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EItemRequirement {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIR_NoRequirement => 0i32,
            Self::eIR_RequireEmpty => 1i32,
            Self::eIR_RequireItem => 2i32,
            Self::eIR_RequireNoBigItem => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EItemRequirement {
     const TYPE_ID: &str = "EItemRequirement";
}

impl StaticVariant for Vec<EItemRequirement> {
     const TYPE_ID: &str = "TArray<EItemRequirement>";
}

impl StaticVariant for Vec<Vec<EItemRequirement>> {
     const TYPE_ID: &str = "TArray<TArray<EItemRequirement>>";
}

impl Variant for EItemRequirement {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EItemRequirement")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EItemRequirement".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EItemRequirement>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EItemRequirement>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EItemRequirement>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EKeywordSetBehavior {
    EKWSB_All,
    EKWSB_None,
    EKWSB_Any,
    EKWSB_No,
}

impl Aligned for EKeywordSetBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EKeywordSetBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EKWSB_All => 0i32,
            Self::EKWSB_None => 1i32,
            Self::EKWSB_Any => 2i32,
            Self::EKWSB_No => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EKeywordSetBehavior {
     const TYPE_ID: &str = "EKeywordSetBehavior";
}

impl StaticVariant for Vec<EKeywordSetBehavior> {
     const TYPE_ID: &str = "TArray<EKeywordSetBehavior>";
}

impl StaticVariant for Vec<Vec<EKeywordSetBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<EKeywordSetBehavior>>";
}

impl Variant for EKeywordSetBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EKeywordSetBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EKeywordSetBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EKeywordSetBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EKeywordSetBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EKeywordSetBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EKillType {
    EKillType_Undefined,
    EKillType_Throw,
    EKillType_Fiberwire,
    EKillType_PistolExecute,
    EKillType_ItemTakeOutFront,
    EKillType_ItemTakeOutBack,
    EKillType_ChokeOut,
    EKillType_SnapNeck,
    EKillType_KnockOut,
    EKillType_Push,
    EKillType_Pull,
}

impl Aligned for EKillType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EKillType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EKillType_Undefined => 0i32,
            Self::EKillType_Throw => 1i32,
            Self::EKillType_Fiberwire => 2i32,
            Self::EKillType_PistolExecute => 3i32,
            Self::EKillType_ItemTakeOutFront => 4i32,
            Self::EKillType_ItemTakeOutBack => 5i32,
            Self::EKillType_ChokeOut => 6i32,
            Self::EKillType_SnapNeck => 7i32,
            Self::EKillType_KnockOut => 8i32,
            Self::EKillType_Push => 9i32,
            Self::EKillType_Pull => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EKillType {
     const TYPE_ID: &str = "EKillType";
}

impl StaticVariant for Vec<EKillType> {
     const TYPE_ID: &str = "TArray<EKillType>";
}

impl StaticVariant for Vec<Vec<EKillType>> {
     const TYPE_ID: &str = "TArray<TArray<EKillType>>";
}

impl Variant for EKillType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EKillType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EKillType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EKillType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EKillType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EKillType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EKnownEntityType {
    KET_UNKNOWN,
    KET_HITMAN,
    KET_ACTOR,
    KET_ITEM,
    KET_LOCATION,
    KET_OBJECT,
    KET_COVER,
    KET_PERCEPTIBLE,
    KET_TEMPCROWDBODY,
}

impl Aligned for EKnownEntityType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EKnownEntityType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::KET_UNKNOWN => 0i32,
            Self::KET_HITMAN => 1i32,
            Self::KET_ACTOR => 2i32,
            Self::KET_ITEM => 3i32,
            Self::KET_LOCATION => 4i32,
            Self::KET_OBJECT => 5i32,
            Self::KET_COVER => 6i32,
            Self::KET_PERCEPTIBLE => 7i32,
            Self::KET_TEMPCROWDBODY => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EKnownEntityType {
     const TYPE_ID: &str = "EKnownEntityType";
}

impl StaticVariant for Vec<EKnownEntityType> {
     const TYPE_ID: &str = "TArray<EKnownEntityType>";
}

impl StaticVariant for Vec<Vec<EKnownEntityType>> {
     const TYPE_ID: &str = "TArray<TArray<EKnownEntityType>>";
}

impl Variant for EKnownEntityType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EKnownEntityType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EKnownEntityType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EKnownEntityType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EKnownEntityType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EKnownEntityType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ELastSoundTension {
    EST_Unknown,
    EST_Ambient,
    EST_Yellow,
    EST_Orange,
    EST_Red,
}

impl Aligned for ELastSoundTension {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ELastSoundTension {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EST_Unknown => 0i32,
            Self::EST_Ambient => 1i32,
            Self::EST_Yellow => 2i32,
            Self::EST_Orange => 3i32,
            Self::EST_Red => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ELastSoundTension {
     const TYPE_ID: &str = "ELastSoundTension";
}

impl StaticVariant for Vec<ELastSoundTension> {
     const TYPE_ID: &str = "TArray<ELastSoundTension>";
}

impl StaticVariant for Vec<Vec<ELastSoundTension>> {
     const TYPE_ID: &str = "TArray<TArray<ELastSoundTension>>";
}

impl Variant for ELastSoundTension {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ELastSoundTension")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ELastSoundTension".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ELastSoundTension>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ELastSoundTension>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ELastSoundTension>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ELedgeDismountBehavior {
    eLDB_DontCare,
    eLDB_Stand,
    eLDB_Crouch,
}

impl Aligned for ELedgeDismountBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ELedgeDismountBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLDB_DontCare => 0i32,
            Self::eLDB_Stand => 1i32,
            Self::eLDB_Crouch => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ELedgeDismountBehavior {
     const TYPE_ID: &str = "ELedgeDismountBehavior";
}

impl StaticVariant for Vec<ELedgeDismountBehavior> {
     const TYPE_ID: &str = "TArray<ELedgeDismountBehavior>";
}

impl StaticVariant for Vec<Vec<ELedgeDismountBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<ELedgeDismountBehavior>>";
}

impl Variant for ELedgeDismountBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ELedgeDismountBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ELedgeDismountBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ELedgeDismountBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ELedgeDismountBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ELedgeDismountBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ELedgeDismountDirection {
    eLDD_DontCare,
    eLDD_FaceLedge,
    eLDD_FaceLeft,
    eLDD_FaceRight,
    eLDD_Turn180,
}

impl Aligned for ELedgeDismountDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ELedgeDismountDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLDD_DontCare => 0i32,
            Self::eLDD_FaceLedge => 1i32,
            Self::eLDD_FaceLeft => 2i32,
            Self::eLDD_FaceRight => 3i32,
            Self::eLDD_Turn180 => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ELedgeDismountDirection {
     const TYPE_ID: &str = "ELedgeDismountDirection";
}

impl StaticVariant for Vec<ELedgeDismountDirection> {
     const TYPE_ID: &str = "TArray<ELedgeDismountDirection>";
}

impl StaticVariant for Vec<Vec<ELedgeDismountDirection>> {
     const TYPE_ID: &str = "TArray<TArray<ELedgeDismountDirection>>";
}

impl Variant for ELedgeDismountDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ELedgeDismountDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ELedgeDismountDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ELedgeDismountDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ELedgeDismountDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ELedgeDismountDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ELocale {
    Locale_En,
    Locale_Fr,
    Locale_It,
    Locale_De,
    Locale_Es,
    Locale_Ru,
    Locale_Mx,
    Locale_Br,
    Locale_Pl,
    Locale_Cn,
    Locale_Jp,
    Locale_Tc,
}

impl Aligned for ELocale {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ELocale {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Locale_En => 0i32,
            Self::Locale_Fr => 1i32,
            Self::Locale_It => 2i32,
            Self::Locale_De => 3i32,
            Self::Locale_Es => 4i32,
            Self::Locale_Ru => 5i32,
            Self::Locale_Mx => 6i32,
            Self::Locale_Br => 7i32,
            Self::Locale_Pl => 8i32,
            Self::Locale_Cn => 9i32,
            Self::Locale_Jp => 10i32,
            Self::Locale_Tc => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ELocale {
     const TYPE_ID: &str = "ELocale";
}

impl StaticVariant for Vec<ELocale> {
     const TYPE_ID: &str = "TArray<ELocale>";
}

impl StaticVariant for Vec<Vec<ELocale>> {
     const TYPE_ID: &str = "TArray<TArray<ELocale>>";
}

impl Variant for ELocale {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ELocale")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ELocale".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ELocale>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ELocale>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ELocale>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMapType {
    E_MAPTYPE_Minimap,
    E_MAPTYPE_MainMap,
    E_MAPTYPE_MenuMap,
}

impl Aligned for EMapType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMapType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_MAPTYPE_Minimap => 0i32,
            Self::E_MAPTYPE_MainMap => 1i32,
            Self::E_MAPTYPE_MenuMap => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMapType {
     const TYPE_ID: &str = "EMapType";
}

impl StaticVariant for Vec<EMapType> {
     const TYPE_ID: &str = "TArray<EMapType>";
}

impl StaticVariant for Vec<Vec<EMapType>> {
     const TYPE_ID: &str = "TArray<TArray<EMapType>>";
}

impl Variant for EMapType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMapType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMapType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMapType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMapType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMapType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMarkerClipAlgorithm {
    MCA_NONE,
    MCA_SIMPLE,
    MCA_ADVANCED,
}

impl Aligned for EMarkerClipAlgorithm {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMarkerClipAlgorithm {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MCA_NONE => 0i32,
            Self::MCA_SIMPLE => 1i32,
            Self::MCA_ADVANCED => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMarkerClipAlgorithm {
     const TYPE_ID: &str = "EMarkerClipAlgorithm";
}

impl StaticVariant for Vec<EMarkerClipAlgorithm> {
     const TYPE_ID: &str = "TArray<EMarkerClipAlgorithm>";
}

impl StaticVariant for Vec<Vec<EMarkerClipAlgorithm>> {
     const TYPE_ID: &str = "TArray<TArray<EMarkerClipAlgorithm>>";
}

impl Variant for EMarkerClipAlgorithm {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMarkerClipAlgorithm")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMarkerClipAlgorithm".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMarkerClipAlgorithm>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMarkerClipAlgorithm>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMarkerClipAlgorithm>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMarkerInclusionMode {
    MIM_DEFAULT,
    MIM_IF_FORCE_INCLUDED_ONLY,
}

impl Aligned for EMarkerInclusionMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMarkerInclusionMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MIM_DEFAULT => 0i32,
            Self::MIM_IF_FORCE_INCLUDED_ONLY => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMarkerInclusionMode {
     const TYPE_ID: &str = "EMarkerInclusionMode";
}

impl StaticVariant for Vec<EMarkerInclusionMode> {
     const TYPE_ID: &str = "TArray<EMarkerInclusionMode>";
}

impl StaticVariant for Vec<Vec<EMarkerInclusionMode>> {
     const TYPE_ID: &str = "TArray<TArray<EMarkerInclusionMode>>";
}

impl Variant for EMarkerInclusionMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMarkerInclusionMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMarkerInclusionMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMarkerInclusionMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMarkerInclusionMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMarkerInclusionMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMassImpulseType {
    eMIT_None,
    eMIT_Explosion,
    eMIT_ShockWave,
    eMIT_ShockWaveNoExplosion,
}

impl Aligned for EMassImpulseType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMassImpulseType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eMIT_None => 0i32,
            Self::eMIT_Explosion => 1i32,
            Self::eMIT_ShockWave => 2i32,
            Self::eMIT_ShockWaveNoExplosion => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMassImpulseType {
     const TYPE_ID: &str = "EMassImpulseType";
}

impl StaticVariant for Vec<EMassImpulseType> {
     const TYPE_ID: &str = "TArray<EMassImpulseType>";
}

impl StaticVariant for Vec<Vec<EMassImpulseType>> {
     const TYPE_ID: &str = "TArray<TArray<EMassImpulseType>>";
}

impl Variant for EMassImpulseType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMassImpulseType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMassImpulseType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMassImpulseType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMassImpulseType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMassImpulseType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMatchOverCondition {
    CompletedNormally,
    OpponentsDisconnected,
    OpponentsAbandoned,
}

impl Aligned for EMatchOverCondition {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMatchOverCondition {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CompletedNormally => 0i32,
            Self::OpponentsDisconnected => 1i32,
            Self::OpponentsAbandoned => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMatchOverCondition {
     const TYPE_ID: &str = "EMatchOverCondition";
}

impl StaticVariant for Vec<EMatchOverCondition> {
     const TYPE_ID: &str = "TArray<EMatchOverCondition>";
}

impl StaticVariant for Vec<Vec<EMatchOverCondition>> {
     const TYPE_ID: &str = "TArray<TArray<EMatchOverCondition>>";
}

impl Variant for EMatchOverCondition {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMatchOverCondition")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMatchOverCondition".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMatchOverCondition>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMatchOverCondition>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMatchOverCondition>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EMaterialRegistrationState {
    eMRS_None,
    eMRS_Pending,
    eMRS_Success,
    eMRS_Failed,
}

impl Aligned for EMaterialRegistrationState {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EMaterialRegistrationState {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eMRS_None => 0i8,
            Self::eMRS_Pending => 1i8,
            Self::eMRS_Success => 2i8,
            Self::eMRS_Failed => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMaterialRegistrationState {
     const TYPE_ID: &str = "EMaterialRegistrationState";
}

impl StaticVariant for Vec<EMaterialRegistrationState> {
     const TYPE_ID: &str = "TArray<EMaterialRegistrationState>";
}

impl StaticVariant for Vec<Vec<EMaterialRegistrationState>> {
     const TYPE_ID: &str = "TArray<TArray<EMaterialRegistrationState>>";
}

impl Variant for EMaterialRegistrationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMaterialRegistrationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMaterialRegistrationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMaterialRegistrationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMaterialRegistrationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMaterialRegistrationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMeBarState {
    ME_BAR_NONE,
    ME_BAR_TRESPASSING,
    ME_BAR_DEEPTRESPASSING,
    ME_BAR_VISIBLY_ARMED,
    ME_BAR_CHANGING_DISGUISE,
    ME_BAR_DISGUISE_BLOWN,
    ME_BAR_DISGUISE_SUSPICIOUS,
    ME_BAR_NEAR_BODY,
}

impl Aligned for EMeBarState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMeBarState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ME_BAR_NONE => 0i32,
            Self::ME_BAR_TRESPASSING => 1i32,
            Self::ME_BAR_DEEPTRESPASSING => 2i32,
            Self::ME_BAR_VISIBLY_ARMED => 3i32,
            Self::ME_BAR_CHANGING_DISGUISE => 4i32,
            Self::ME_BAR_DISGUISE_BLOWN => 5i32,
            Self::ME_BAR_DISGUISE_SUSPICIOUS => 6i32,
            Self::ME_BAR_NEAR_BODY => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMeBarState {
     const TYPE_ID: &str = "EMeBarState";
}

impl StaticVariant for Vec<EMeBarState> {
     const TYPE_ID: &str = "TArray<EMeBarState>";
}

impl StaticVariant for Vec<Vec<EMeBarState>> {
     const TYPE_ID: &str = "TArray<TArray<EMeBarState>>";
}

impl Variant for EMeBarState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMeBarState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMeBarState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMeBarState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMeBarState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMeBarState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMorphemeEventId {
    eDE_None,
    eDE_UnholsterWeapon,
    eDE_HolsterWeapon,
    eDE_FireWeapon,
    eDE_AttachWeapon,
    eDE_DetachWeapon,
    eDE_LegR,
    eDE_LegL,
    eDE_TransitionEnd_LegR,
    eDE_TransitionEnd_LegL,
    eDE_Finish,
    eDE_InterpolationStart,
    eDE_InterpolationEnd,
    eDE_TransitionSignal,
    eDE_TransitionEnd,
    eDE_DisableNPCHitmanCollision,
    eDE_EnableNPCHitmanCollision,
    eDE_EnableRagdollRangeStart,
    eDE_EnableRagdollRangeEnd,
    eDE_StartBlendingOut,
    eDE_FinishBlendingOut,
    eDE_StartOrientationBlend,
    eDE_FinishOrientationBlend,
    eDE_RecoveryPowerRagdollEnd,
    eDE_RecoveryBlendEnd,
    eDE_ImpactFinished,
    eDE_ActFinished,
    eDE_ActFinishedWhenMoving,
    eDE_ActReached,
    eDE_ActLoop,
    eDE_ActFullbodyStartMarker,
    eDE_ActFullbodyEndMarker,
    eDE_ReactionFinished,
    eDE_StandToCrouch,
    eDE_CrouchToStand,
    eDE_OffHandIKEnable,
    eDE_OffHandIKDisable,
    eDE_StandToMoveRotationToTranslation,
    eDE_MoveToStandTranslationToRotation,
    eDE_HeadIKEnable,
    eDE_HeadIKDisable,
    eDE_WindowLeaningEnable,
    eDE_WindowLeaningDisable,
    eDE_PreventDeathAnimations,
    eDE_AllowDeathAnimations,
    eDE_HeadControlEnable,
    eDE_HeadControlDisable,
    eDE_CombatActEndMarker,
    eDE_CombatAim,
    eDE_CombatEnableRightHandIK,
    eDE_CombatEnableLeftHandIK,
    eDE_CombatEndEnableIK,
    eDE_CombatStartDisableIK,
    eDE_CombatEndDisableIK,
    eDE_CombatEnableShoot,
    eDE_CombatDisableShoot,
    eDE_CombatEnableBlindShoot,
    eDE_CombatDisableBlindShoot,
    eDE_CombatUnholsterGrenade,
    eDE_CombatThrowGrenade,
    eDE_ActBehaviorEventStart,
    eDE_ActItemPickup,
    eDE_ActItemDrop,
    eDE_AmbientItemUseMarker,
    eDE_ActBehaviorEventEnd,
    eDE_Act_LeadIn_Marker,
    eDE_Act_UB_BlendIn_End,
    eDE_Act_FB_BlendIn_Start,
    eDE_Act_FB_BlendIn_End,
    eDE_Act_FB_BlendOut_End,
}

impl Aligned for EMorphemeEventId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMorphemeEventId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDE_None => 0i32,
            Self::eDE_UnholsterWeapon => 18i32,
            Self::eDE_HolsterWeapon => 19i32,
            Self::eDE_FireWeapon => 20i32,
            Self::eDE_AttachWeapon => 21i32,
            Self::eDE_DetachWeapon => 22i32,
            Self::eDE_LegR => 100i32,
            Self::eDE_LegL => 101i32,
            Self::eDE_TransitionEnd_LegR => 200i32,
            Self::eDE_TransitionEnd_LegL => 201i32,
            Self::eDE_Finish => 255i32,
            Self::eDE_InterpolationStart => 300i32,
            Self::eDE_InterpolationEnd => 301i32,
            Self::eDE_TransitionSignal => 400i32,
            Self::eDE_TransitionEnd => 500i32,
            Self::eDE_DisableNPCHitmanCollision => 700i32,
            Self::eDE_EnableNPCHitmanCollision => 701i32,
            Self::eDE_EnableRagdollRangeStart => 800i32,
            Self::eDE_EnableRagdollRangeEnd => 801i32,
            Self::eDE_StartBlendingOut => 850i32,
            Self::eDE_FinishBlendingOut => 851i32,
            Self::eDE_StartOrientationBlend => 860i32,
            Self::eDE_FinishOrientationBlend => 861i32,
            Self::eDE_RecoveryPowerRagdollEnd => 862i32,
            Self::eDE_RecoveryBlendEnd => 863i32,
            Self::eDE_ImpactFinished => 900i32,
            Self::eDE_ActFinished => 1000i32,
            Self::eDE_ActFinishedWhenMoving => 1001i32,
            Self::eDE_ActReached => 1005i32,
            Self::eDE_ActLoop => 1050i32,
            Self::eDE_ActFullbodyStartMarker => 1090i32,
            Self::eDE_ActFullbodyEndMarker => 1091i32,
            Self::eDE_ReactionFinished => 1100i32,
            Self::eDE_StandToCrouch => 1500i32,
            Self::eDE_CrouchToStand => 1501i32,
            Self::eDE_OffHandIKEnable => 1600i32,
            Self::eDE_OffHandIKDisable => 1601i32,
            Self::eDE_StandToMoveRotationToTranslation => 1700i32,
            Self::eDE_MoveToStandTranslationToRotation => 1701i32,
            Self::eDE_HeadIKEnable => 1800i32,
            Self::eDE_HeadIKDisable => 1801i32,
            Self::eDE_WindowLeaningEnable => 2000i32,
            Self::eDE_WindowLeaningDisable => 2001i32,
            Self::eDE_PreventDeathAnimations => 2002i32,
            Self::eDE_AllowDeathAnimations => 2003i32,
            Self::eDE_HeadControlEnable => 2010i32,
            Self::eDE_HeadControlDisable => 2011i32,
            Self::eDE_CombatActEndMarker => 3000i32,
            Self::eDE_CombatAim => 3100i32,
            Self::eDE_CombatEnableRightHandIK => 3010i32,
            Self::eDE_CombatEnableLeftHandIK => 3011i32,
            Self::eDE_CombatEndEnableIK => 3015i32,
            Self::eDE_CombatStartDisableIK => 3020i32,
            Self::eDE_CombatEndDisableIK => 3025i32,
            Self::eDE_CombatEnableShoot => 3030i32,
            Self::eDE_CombatDisableShoot => 3040i32,
            Self::eDE_CombatEnableBlindShoot => 3050i32,
            Self::eDE_CombatDisableBlindShoot => 3060i32,
            Self::eDE_CombatUnholsterGrenade => 3070i32,
            Self::eDE_CombatThrowGrenade => 3080i32,
            Self::eDE_ActBehaviorEventStart => 4000i32,
            Self::eDE_ActItemPickup => 4001i32,
            Self::eDE_ActItemDrop => 4002i32,
            Self::eDE_AmbientItemUseMarker => 4010i32,
            Self::eDE_ActBehaviorEventEnd => 4999i32,
            Self::eDE_Act_LeadIn_Marker => 10301i32,
            Self::eDE_Act_UB_BlendIn_End => 10050i32,
            Self::eDE_Act_FB_BlendIn_Start => 10051i32,
            Self::eDE_Act_FB_BlendIn_End => 10052i32,
            Self::eDE_Act_FB_BlendOut_End => 10053i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMorphemeEventId {
     const TYPE_ID: &str = "EMorphemeEventId";
}

impl StaticVariant for Vec<EMorphemeEventId> {
     const TYPE_ID: &str = "TArray<EMorphemeEventId>";
}

impl StaticVariant for Vec<Vec<EMorphemeEventId>> {
     const TYPE_ID: &str = "TArray<TArray<EMorphemeEventId>>";
}

impl Variant for EMorphemeEventId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMorphemeEventId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMorphemeEventId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMorphemeEventId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMorphemeEventId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMorphemeEventId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMotionType {
    MOTION_LOCKED,
    MOTION_LIMITED,
    MOTION_FREE,
}

impl Aligned for EMotionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMotionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MOTION_LOCKED => 0i32,
            Self::MOTION_LIMITED => 1i32,
            Self::MOTION_FREE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMotionType {
     const TYPE_ID: &str = "EMotionType";
}

impl StaticVariant for Vec<EMotionType> {
     const TYPE_ID: &str = "TArray<EMotionType>";
}

impl StaticVariant for Vec<Vec<EMotionType>> {
     const TYPE_ID: &str = "TArray<TArray<EMotionType>>";
}

impl Variant for EMotionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMotionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMotionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMotionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMotionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMotionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMoveEndState {
    MES_Moving,
    MES_Stopping,
    MES_Standing,
}

impl Aligned for EMoveEndState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMoveEndState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MES_Moving => 0i32,
            Self::MES_Stopping => 1i32,
            Self::MES_Standing => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMoveEndState {
     const TYPE_ID: &str = "EMoveEndState";
}

impl StaticVariant for Vec<EMoveEndState> {
     const TYPE_ID: &str = "TArray<EMoveEndState>";
}

impl StaticVariant for Vec<Vec<EMoveEndState>> {
     const TYPE_ID: &str = "TArray<TArray<EMoveEndState>>";
}

impl Variant for EMoveEndState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMoveEndState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMoveEndState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMoveEndState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMoveEndState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMoveEndState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMoveRecenterMode {
    VR_MOVE_TRIGGER_INDEPENDENT,
    VR_MOVE_TRIGGER_AVERAGE,
}

impl Aligned for EMoveRecenterMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMoveRecenterMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::VR_MOVE_TRIGGER_INDEPENDENT => 0i32,
            Self::VR_MOVE_TRIGGER_AVERAGE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMoveRecenterMode {
     const TYPE_ID: &str = "EMoveRecenterMode";
}

impl StaticVariant for Vec<EMoveRecenterMode> {
     const TYPE_ID: &str = "TArray<EMoveRecenterMode>";
}

impl StaticVariant for Vec<Vec<EMoveRecenterMode>> {
     const TYPE_ID: &str = "TArray<TArray<EMoveRecenterMode>>";
}

impl Variant for EMoveRecenterMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMoveRecenterMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMoveRecenterMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMoveRecenterMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMoveRecenterMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMoveRecenterMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMoveSpeed {
    MS_Sneaking,
    MS_Walking,
    MS_Jogging,
    MS_Sprinting,
    MS_Flash,
}

impl Aligned for EMoveSpeed {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMoveSpeed {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MS_Sneaking => 0i32,
            Self::MS_Walking => 1i32,
            Self::MS_Jogging => 2i32,
            Self::MS_Sprinting => 3i32,
            Self::MS_Flash => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMoveSpeed {
     const TYPE_ID: &str = "EMoveSpeed";
}

impl StaticVariant for Vec<EMoveSpeed> {
     const TYPE_ID: &str = "TArray<EMoveSpeed>";
}

impl StaticVariant for Vec<Vec<EMoveSpeed>> {
     const TYPE_ID: &str = "TArray<TArray<EMoveSpeed>>";
}

impl Variant for EMoveSpeed {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMoveSpeed")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMoveSpeed".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMoveSpeed>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMoveSpeed>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMoveSpeed>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMultiplayerLobbyRequestType {
    LOBBY_REQUEST_VOID,
    LOBBY_REQUEST_IDLE,
    LOBBY_REQUEST_CREATE,
    LOBBY_REQUEST_CREATE_LOCALHOST,
    LOBBY_REQUEST_JOIN,
}

impl Aligned for EMultiplayerLobbyRequestType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMultiplayerLobbyRequestType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LOBBY_REQUEST_VOID => 0i32,
            Self::LOBBY_REQUEST_IDLE => 1i32,
            Self::LOBBY_REQUEST_CREATE => 2i32,
            Self::LOBBY_REQUEST_CREATE_LOCALHOST => 3i32,
            Self::LOBBY_REQUEST_JOIN => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMultiplayerLobbyRequestType {
     const TYPE_ID: &str = "EMultiplayerLobbyRequestType";
}

impl StaticVariant for Vec<EMultiplayerLobbyRequestType> {
     const TYPE_ID: &str = "TArray<EMultiplayerLobbyRequestType>";
}

impl StaticVariant for Vec<Vec<EMultiplayerLobbyRequestType>> {
     const TYPE_ID: &str = "TArray<TArray<EMultiplayerLobbyRequestType>>";
}

impl Variant for EMultiplayerLobbyRequestType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMultiplayerLobbyRequestType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMultiplayerLobbyRequestType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMultiplayerLobbyRequestType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMultiplayerLobbyRequestType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMultiplayerLobbyRequestType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EMultiplayerNetworkState {
    Base,
    Idle,
    Searching,
    Connecting,
    Joining,
    Creating,
    Connected,
    Disconnecting,
    Count,
}

impl Aligned for EMultiplayerNetworkState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EMultiplayerNetworkState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Base => 0i32,
            Self::Idle => 1i32,
            Self::Searching => 2i32,
            Self::Connecting => 3i32,
            Self::Joining => 4i32,
            Self::Creating => 5i32,
            Self::Connected => 6i32,
            Self::Disconnecting => 7i32,
            Self::Count => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EMultiplayerNetworkState {
     const TYPE_ID: &str = "EMultiplayerNetworkState";
}

impl StaticVariant for Vec<EMultiplayerNetworkState> {
     const TYPE_ID: &str = "TArray<EMultiplayerNetworkState>";
}

impl StaticVariant for Vec<Vec<EMultiplayerNetworkState>> {
     const TYPE_ID: &str = "TArray<TArray<EMultiplayerNetworkState>>";
}

impl Variant for EMultiplayerNetworkState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EMultiplayerNetworkState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EMultiplayerNetworkState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EMultiplayerNetworkState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EMultiplayerNetworkState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EMultiplayerNetworkState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ENamedGameEvents {
    eEvent_IntroCutStart,
    eEvent_PlayingAfterLoad,
    eEvent_SetModePlaying,
    eNumNamedGameEvents,
}

impl Aligned for ENamedGameEvents {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ENamedGameEvents {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eEvent_IntroCutStart => 0i32,
            Self::eEvent_PlayingAfterLoad => 1i32,
            Self::eEvent_SetModePlaying => 2i32,
            Self::eNumNamedGameEvents => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ENamedGameEvents {
     const TYPE_ID: &str = "ENamedGameEvents";
}

impl StaticVariant for Vec<ENamedGameEvents> {
     const TYPE_ID: &str = "TArray<ENamedGameEvents>";
}

impl StaticVariant for Vec<Vec<ENamedGameEvents>> {
     const TYPE_ID: &str = "TArray<TArray<ENamedGameEvents>>";
}

impl Variant for ENamedGameEvents {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ENamedGameEvents")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ENamedGameEvents".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ENamedGameEvents>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ENamedGameEvents>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ENamedGameEvents>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ENetPlayerEvent {
    Login,
    Logout,
    NewHost,
}

impl Aligned for ENetPlayerEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ENetPlayerEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Login => 0i32,
            Self::Logout => 1i32,
            Self::NewHost => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ENetPlayerEvent {
     const TYPE_ID: &str = "ENetPlayerEvent";
}

impl StaticVariant for Vec<ENetPlayerEvent> {
     const TYPE_ID: &str = "TArray<ENetPlayerEvent>";
}

impl StaticVariant for Vec<Vec<ENetPlayerEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ENetPlayerEvent>>";
}

impl Variant for ENetPlayerEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ENetPlayerEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ENetPlayerEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ENetPlayerEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ENetPlayerEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ENetPlayerEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ENetRole {
    None,
    Master,
    Client,
}

impl Aligned for ENetRole {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ENetRole {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::None => 0i8,
            Self::Master => 1i8,
            Self::Client => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ENetRole {
     const TYPE_ID: &str = "ENetRole";
}

impl StaticVariant for Vec<ENetRole> {
     const TYPE_ID: &str = "TArray<ENetRole>";
}

impl StaticVariant for Vec<Vec<ENetRole>> {
     const TYPE_ID: &str = "TArray<TArray<ENetRole>>";
}

impl Variant for ENetRole {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ENetRole")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ENetRole".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ENetRole>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ENetRole>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ENetRole>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ENetworkSystemID {
    NSID_UNDEFINED,
    NSID_NETWORK_CORE_SYSTEMS_BEGIN,
    NSID_DEBUG_SWAP_PLAYER_RPC,
    NSID_ROUNTTRIPTEST_REQUEST_RPC,
    NSID_ROUNTTRIPTEST_RESOLVE_RPC,
    NSID_CONNECTION_LOCALLY_DEREFERENCE_UPDATE_RPC,
    NSID_CONNECTION_READY_FOR_REPLICATION_RPC,
    NSID_NETPLAYER_LOGIN_RPC,
    NSID_NETPLAYER_LOGIN_COLOR_SELECTION_RPC,
    NSID_NETPLAYER_REPLICA,
    NSID_NETGAME_REPLICA,
    NSID_PLAYERREGISTRY_REPLICA,
    NSID_NETPLAYER_CONTROLLER_REPLICA,
    NSID_SYNCH_POINT_PLAYER_REPLICA,
    NSID_SYNCH_POINT_REPLICA,
    NSID_GAME_CHAT_RPC,
    NSID_NETWORK_CORE_SYSTEMS_END,
    NSID_NETWORK_SYNCHRONOUS_MULTIPLAYER_BEGIN,
    NSID_PLAYER_INPUT_RPC,
    NSID_PLAYER_INPUT_REPLICA,
    NSID_GENERAL_ENTITY_PROPERTY_REPLICA,
    NSID_ANIMATED_ACTOR_RPC,
    NSID_CAMERA_REPLICA,
    NSID_GENERAL_PIN_SIGNAL_RPC,
    NSID_PIN_SIGNAL_RPC,
    NSID_NPC_DIALOGUE_RPC,
    NSID_GAME_STATE_REPLICA,
    NSID_HERO_STATE_REPLICA,
    NSID_NPC_STATE_REPLICA,
    NSID_ANIMATION_REPLICA,
    NSID_DESTRUCTIBLE_INTERACTIONS_RPC,
    NSID_ACT_REQUEST_RPC,
    NSID_CHARACTERSPEAK_REPLICA,
    NSID_ITEM_WEAPON_RPC,
    NSID_ITEM_REPLICA,
    NSID_ACCESSORY_ITEM_REPLICA,
    NSID_BULLET_IMPACT_RPC,
    NSID_NETWORKED_TIME_CONTROL_RPC,
    NSID_REQUEST_ACTION_SYCHRONIZATION_RPC,
    NSID_PHYSICS_SYSTEM_REPLICA,
    NSID_PHYSICS_OBJECT_REPLICA,
    NSID_WATER_SPLASH_GENERATOR_RPC,
    NSID_PROJECTILE_HIT_INFO_RPC,
    NSID_PROJECTILE_HIT_EVENT_RPC,
    NSID_INTERACTION_SUBACTION_EXECUTE_REQUEST,
    NSID_INTERACTION_SUBACTION_EXECUTE_RESOLVE,
    NSID_INTERACTION_SUBACTION_EXECUTE_SIGNAL_RESOLVE,
    NSID_INTERACTION_INPUT_REQUEST_RESOLVE,
    NSID_SUBCONTROLLER_REPLICA,
    NSID_CONTRACT_EVENT_REPLICA,
    NSID_NETWORK_SYNCHRONOUS_MULTIPLAYER_END,
    NSID_SNIPERS_CHALLENGE_SCORING_EVENT_REPLICA,
    NSID_CHARACTER_GHOST_REPLICA,
    NSID_PIP_GHOST_REPLICA,
    NSID_SPATIAL_GHOST_REPLICA,
    NSID_VS_TARGET_PICKER_REPLICA,
    NSID_VS_KILL_RPC,
    NSID_VS_KILL_CONFIRM_RPC,
    NSID_VS_CLIENT_DEAD_RPC,
    NSID_VS_SETUP_SYNC_REPLICA,
    NSID_VS_PIN_SIGNAL_RPC,
    NSID_VS_ENTITY_PROPERTY_REPLICA,
    NSID_VS_GENERIC_EVENT_RPC,
    NSID_VS_PENALTY_KILL_RPC,
    NSID_VS_ITEM_PICKUP_REQUEST_RPC,
    NSID_VS_ITEM_PICKUP_RESPONSE_RPC,
    NSID_VS_OUTFIT_PICK_REQUEST_RPC,
    NSID_VS_OUTFIT_PICK_RESPONSE_RPC,
    NSID_VS_PICKUP_SPAWNER_REPLICA,
    NSID_VS_KILL_EVENT_RPC,
    NSID_VS_PRE_SCORE_TIMER_RPC,
    NSID_VS_TARGET_PACIFY_RPC,
    NSID_VS_CONFIRM_TARGET_PACIFY_RPC,
    NSID_VS_TARGET_PACIFIED_CONFIRMED_RPC,
    NSID_MAX,
}

impl Aligned for ENetworkSystemID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ENetworkSystemID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NSID_UNDEFINED => 0i32,
            Self::NSID_NETWORK_CORE_SYSTEMS_BEGIN => 1i32,
            Self::NSID_DEBUG_SWAP_PLAYER_RPC => 1i32,
            Self::NSID_ROUNTTRIPTEST_REQUEST_RPC => 2i32,
            Self::NSID_ROUNTTRIPTEST_RESOLVE_RPC => 3i32,
            Self::NSID_CONNECTION_LOCALLY_DEREFERENCE_UPDATE_RPC => 4i32,
            Self::NSID_CONNECTION_READY_FOR_REPLICATION_RPC => 5i32,
            Self::NSID_NETPLAYER_LOGIN_RPC => 6i32,
            Self::NSID_NETPLAYER_LOGIN_COLOR_SELECTION_RPC => 7i32,
            Self::NSID_NETPLAYER_REPLICA => 8i32,
            Self::NSID_NETGAME_REPLICA => 9i32,
            Self::NSID_PLAYERREGISTRY_REPLICA => 10i32,
            Self::NSID_NETPLAYER_CONTROLLER_REPLICA => 11i32,
            Self::NSID_SYNCH_POINT_PLAYER_REPLICA => 12i32,
            Self::NSID_SYNCH_POINT_REPLICA => 13i32,
            Self::NSID_GAME_CHAT_RPC => 14i32,
            Self::NSID_NETWORK_CORE_SYSTEMS_END => 15i32,
            Self::NSID_NETWORK_SYNCHRONOUS_MULTIPLAYER_BEGIN => 16i32,
            Self::NSID_PLAYER_INPUT_RPC => 16i32,
            Self::NSID_PLAYER_INPUT_REPLICA => 17i32,
            Self::NSID_GENERAL_ENTITY_PROPERTY_REPLICA => 18i32,
            Self::NSID_ANIMATED_ACTOR_RPC => 19i32,
            Self::NSID_CAMERA_REPLICA => 20i32,
            Self::NSID_GENERAL_PIN_SIGNAL_RPC => 21i32,
            Self::NSID_PIN_SIGNAL_RPC => 22i32,
            Self::NSID_NPC_DIALOGUE_RPC => 23i32,
            Self::NSID_GAME_STATE_REPLICA => 24i32,
            Self::NSID_HERO_STATE_REPLICA => 25i32,
            Self::NSID_NPC_STATE_REPLICA => 26i32,
            Self::NSID_ANIMATION_REPLICA => 27i32,
            Self::NSID_DESTRUCTIBLE_INTERACTIONS_RPC => 28i32,
            Self::NSID_ACT_REQUEST_RPC => 29i32,
            Self::NSID_CHARACTERSPEAK_REPLICA => 30i32,
            Self::NSID_ITEM_WEAPON_RPC => 31i32,
            Self::NSID_ITEM_REPLICA => 32i32,
            Self::NSID_ACCESSORY_ITEM_REPLICA => 33i32,
            Self::NSID_BULLET_IMPACT_RPC => 34i32,
            Self::NSID_NETWORKED_TIME_CONTROL_RPC => 35i32,
            Self::NSID_REQUEST_ACTION_SYCHRONIZATION_RPC => 36i32,
            Self::NSID_PHYSICS_SYSTEM_REPLICA => 37i32,
            Self::NSID_PHYSICS_OBJECT_REPLICA => 38i32,
            Self::NSID_WATER_SPLASH_GENERATOR_RPC => 39i32,
            Self::NSID_PROJECTILE_HIT_INFO_RPC => 40i32,
            Self::NSID_PROJECTILE_HIT_EVENT_RPC => 41i32,
            Self::NSID_INTERACTION_SUBACTION_EXECUTE_REQUEST => 42i32,
            Self::NSID_INTERACTION_SUBACTION_EXECUTE_RESOLVE => 43i32,
            Self::NSID_INTERACTION_SUBACTION_EXECUTE_SIGNAL_RESOLVE => 44i32,
            Self::NSID_INTERACTION_INPUT_REQUEST_RESOLVE => 45i32,
            Self::NSID_SUBCONTROLLER_REPLICA => 46i32,
            Self::NSID_CONTRACT_EVENT_REPLICA => 47i32,
            Self::NSID_NETWORK_SYNCHRONOUS_MULTIPLAYER_END => 48i32,
            Self::NSID_SNIPERS_CHALLENGE_SCORING_EVENT_REPLICA => 49i32,
            Self::NSID_CHARACTER_GHOST_REPLICA => 50i32,
            Self::NSID_PIP_GHOST_REPLICA => 51i32,
            Self::NSID_SPATIAL_GHOST_REPLICA => 52i32,
            Self::NSID_VS_TARGET_PICKER_REPLICA => 53i32,
            Self::NSID_VS_KILL_RPC => 54i32,
            Self::NSID_VS_KILL_CONFIRM_RPC => 55i32,
            Self::NSID_VS_CLIENT_DEAD_RPC => 56i32,
            Self::NSID_VS_SETUP_SYNC_REPLICA => 57i32,
            Self::NSID_VS_PIN_SIGNAL_RPC => 58i32,
            Self::NSID_VS_ENTITY_PROPERTY_REPLICA => 59i32,
            Self::NSID_VS_GENERIC_EVENT_RPC => 60i32,
            Self::NSID_VS_PENALTY_KILL_RPC => 61i32,
            Self::NSID_VS_ITEM_PICKUP_REQUEST_RPC => 62i32,
            Self::NSID_VS_ITEM_PICKUP_RESPONSE_RPC => 63i32,
            Self::NSID_VS_OUTFIT_PICK_REQUEST_RPC => 64i32,
            Self::NSID_VS_OUTFIT_PICK_RESPONSE_RPC => 65i32,
            Self::NSID_VS_PICKUP_SPAWNER_REPLICA => 66i32,
            Self::NSID_VS_KILL_EVENT_RPC => 67i32,
            Self::NSID_VS_PRE_SCORE_TIMER_RPC => 68i32,
            Self::NSID_VS_TARGET_PACIFY_RPC => 69i32,
            Self::NSID_VS_CONFIRM_TARGET_PACIFY_RPC => 70i32,
            Self::NSID_VS_TARGET_PACIFIED_CONFIRMED_RPC => 71i32,
            Self::NSID_MAX => 72i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ENetworkSystemID {
     const TYPE_ID: &str = "ENetworkSystemID";
}

impl StaticVariant for Vec<ENetworkSystemID> {
     const TYPE_ID: &str = "TArray<ENetworkSystemID>";
}

impl StaticVariant for Vec<Vec<ENetworkSystemID>> {
     const TYPE_ID: &str = "TArray<TArray<ENetworkSystemID>>";
}

impl Variant for ENetworkSystemID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ENetworkSystemID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ENetworkSystemID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ENetworkSystemID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ENetworkSystemID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ENetworkSystemID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EObjectiveType {
    OBJECTIVE_PRIMARY,
    OBJECTIVE_SECONDARY,
    OBJECTIVE_TERTIARY,
}

impl Aligned for EObjectiveType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EObjectiveType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OBJECTIVE_PRIMARY => 0i32,
            Self::OBJECTIVE_SECONDARY => 1i32,
            Self::OBJECTIVE_TERTIARY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EObjectiveType {
     const TYPE_ID: &str = "EObjectiveType";
}

impl StaticVariant for Vec<EObjectiveType> {
     const TYPE_ID: &str = "TArray<EObjectiveType>";
}

impl StaticVariant for Vec<Vec<EObjectiveType>> {
     const TYPE_ID: &str = "TArray<TArray<EObjectiveType>>";
}

impl Variant for EObjectiveType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EObjectiveType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EObjectiveType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EObjectiveType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EObjectiveType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EObjectiveType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOnlinTest {
    eHELLO,
    eWORLD,
}

impl Aligned for EOnlinTest {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOnlinTest {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHELLO => 0i32,
            Self::eWORLD => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOnlinTest {
     const TYPE_ID: &str = "EOnlinTest";
}

impl StaticVariant for Vec<EOnlinTest> {
     const TYPE_ID: &str = "TArray<EOnlinTest>";
}

impl StaticVariant for Vec<Vec<EOnlinTest>> {
     const TYPE_ID: &str = "TArray<TArray<EOnlinTest>>";
}

impl Variant for EOnlinTest {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOnlinTest")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOnlinTest".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOnlinTest>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOnlinTest>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOnlinTest>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOnlineEventInvestigationType {
    OEIT_Generic,
    OEIT_HearBulletImpact,
    OEIT_HearFootsteps,
    OEIT_CarAlarm,
    OEIT_HearBark,
    OEIT_HearPain,
    OEIT_HearRadio,
    OEIT_HearItemToss,
    OEIT_SeeItemToss,
    OEIT_HearAccident,
    OEIT_CuriousSound,
    OEIT_CuriousItemSound,
    OEIT_SeeWeapon,
    OEIT_SeeItem,
    OEIT_Perceptible,
    OEIT_Toss,
    OEIT_CrowdCurious,
    OEIT_CameraDefect,
}

impl Aligned for EOnlineEventInvestigationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOnlineEventInvestigationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OEIT_Generic => 0i32,
            Self::OEIT_HearBulletImpact => 1i32,
            Self::OEIT_HearFootsteps => 2i32,
            Self::OEIT_CarAlarm => 3i32,
            Self::OEIT_HearBark => 4i32,
            Self::OEIT_HearPain => 5i32,
            Self::OEIT_HearRadio => 6i32,
            Self::OEIT_HearItemToss => 7i32,
            Self::OEIT_SeeItemToss => 8i32,
            Self::OEIT_HearAccident => 9i32,
            Self::OEIT_CuriousSound => 10i32,
            Self::OEIT_CuriousItemSound => 11i32,
            Self::OEIT_SeeWeapon => 12i32,
            Self::OEIT_SeeItem => 13i32,
            Self::OEIT_Perceptible => 14i32,
            Self::OEIT_Toss => 15i32,
            Self::OEIT_CrowdCurious => 16i32,
            Self::OEIT_CameraDefect => 17i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOnlineEventInvestigationType {
     const TYPE_ID: &str = "EOnlineEventInvestigationType";
}

impl StaticVariant for Vec<EOnlineEventInvestigationType> {
     const TYPE_ID: &str = "TArray<EOnlineEventInvestigationType>";
}

impl StaticVariant for Vec<Vec<EOnlineEventInvestigationType>> {
     const TYPE_ID: &str = "TArray<TArray<EOnlineEventInvestigationType>>";
}

impl Variant for EOnlineEventInvestigationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOnlineEventInvestigationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOnlineEventInvestigationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOnlineEventInvestigationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOnlineEventInvestigationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOnlineEventInvestigationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOpportunityRevealState {
    ORS_REVEALING,
    ORS_HINT,
    ORS_DISTANCE,
    ORS_RANGE_FLAGS,
    ORS_REVEALED,
    ORS_REVEAL_FLAGS,
    ORS_BYPASS_MENU,
}

impl Aligned for EOpportunityRevealState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOpportunityRevealState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ORS_REVEALING => 1i32,
            Self::ORS_HINT => 2i32,
            Self::ORS_DISTANCE => 4i32,
            Self::ORS_RANGE_FLAGS => 6i32,
            Self::ORS_REVEALED => 8i32,
            Self::ORS_REVEAL_FLAGS => 9i32,
            Self::ORS_BYPASS_MENU => 16i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOpportunityRevealState {
     const TYPE_ID: &str = "EOpportunityRevealState";
}

impl StaticVariant for Vec<EOpportunityRevealState> {
     const TYPE_ID: &str = "TArray<EOpportunityRevealState>";
}

impl StaticVariant for Vec<Vec<EOpportunityRevealState>> {
     const TYPE_ID: &str = "TArray<TArray<EOpportunityRevealState>>";
}

impl Variant for EOpportunityRevealState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOpportunityRevealState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOpportunityRevealState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOpportunityRevealState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOpportunityRevealState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOpportunityRevealState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EOpportunityState {
    OS_TRACKED,
    OS_ENABLED,
    OS_UNLOCKED,
    OS_REVEAL_PENDING,
}

impl Aligned for EOpportunityState {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EOpportunityState {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OS_TRACKED => 1i8,
            Self::OS_ENABLED => 2i8,
            Self::OS_UNLOCKED => 4i8,
            Self::OS_REVEAL_PENDING => 8i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOpportunityState {
     const TYPE_ID: &str = "EOpportunityState";
}

impl StaticVariant for Vec<EOpportunityState> {
     const TYPE_ID: &str = "TArray<EOpportunityState>";
}

impl StaticVariant for Vec<Vec<EOpportunityState>> {
     const TYPE_ID: &str = "TArray<TArray<EOpportunityState>>";
}

impl Variant for EOpportunityState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOpportunityState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOpportunityState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOpportunityState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOpportunityState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOpportunityState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EOrderCompletionStatus {
    OCS_Undetermined,
    OCS_Succeeded,
    OCS_Interrupted,
    OCS_Blocked,
    OCS_Failed,
}

impl Aligned for EOrderCompletionStatus {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EOrderCompletionStatus {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OCS_Undetermined => 0i8,
            Self::OCS_Succeeded => 1i8,
            Self::OCS_Interrupted => 2i8,
            Self::OCS_Blocked => 3i8,
            Self::OCS_Failed => 4i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOrderCompletionStatus {
     const TYPE_ID: &str = "EOrderCompletionStatus";
}

impl StaticVariant for Vec<EOrderCompletionStatus> {
     const TYPE_ID: &str = "TArray<EOrderCompletionStatus>";
}

impl StaticVariant for Vec<Vec<EOrderCompletionStatus>> {
     const TYPE_ID: &str = "TArray<TArray<EOrderCompletionStatus>>";
}

impl Variant for EOrderCompletionStatus {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOrderCompletionStatus")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOrderCompletionStatus".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOrderCompletionStatus>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOrderCompletionStatus>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOrderCompletionStatus>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOutbreakInfectionStage {
    eOIS_Stage1,
    eOIS_Stage2,
    eOIS_Stage3,
}

impl Aligned for EOutbreakInfectionStage {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOutbreakInfectionStage {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eOIS_Stage1 => 0i32,
            Self::eOIS_Stage2 => 1i32,
            Self::eOIS_Stage3 => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOutbreakInfectionStage {
     const TYPE_ID: &str = "EOutbreakInfectionStage";
}

impl StaticVariant for Vec<EOutbreakInfectionStage> {
     const TYPE_ID: &str = "TArray<EOutbreakInfectionStage>";
}

impl StaticVariant for Vec<Vec<EOutbreakInfectionStage>> {
     const TYPE_ID: &str = "TArray<TArray<EOutbreakInfectionStage>>";
}

impl Variant for EOutbreakInfectionStage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOutbreakInfectionStage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOutbreakInfectionStage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOutbreakInfectionStage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOutbreakInfectionStage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOutbreakInfectionStage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOutfitAICategory {
    OAC_Undefined,
    OAC_Fallback,
    OAC_47Suit,
    OAC_47TRAINING,
    OAC_47MARRAKESH,
    OAC_47SAPIENZA,
    OAC_47BANGKOK,
    OAC_47COLORADO,
    OAC_47HOKKAIDO,
    OAC_47PREORDER,
    OAC_47COLUMBIA,
    OAC_47ISLAND,
    OAC_47MUMBAI,
    OAC_47NEWZEALAND,
    OAC_47STARTCLASSY,
    OAC_47STARTOUTFIT,
    OAC_47SUBURBIA,
    OAC_Bodyguard,
    OAC_CameraMan,
    OAC_Chef,
    OAC_Cleaner,
    OAC_Cop,
    OAC_Crew,
    OAC_DaSilva,
    OAC_Gardner,
    OAC_Hazmat,
    OAC_HouseStaff,
    OAC_Maintenance,
    OAC_Officer,
    OAC_Priest,
    OAC_Printer,
    OAC_Scientist,
    OAC_Security,
    OAC_Sheik,
    OAC_Stylist,
    OAC_Waiter,
    OAC_Busker,
    OAC_Caddie,
    OAC_ChurchStaff,
    OAC_Cyclist,
    OAC_Filmcrew,
    OAC_Fortune,
    OAC_Hippie,
    OAC_Investor,
    OAC_KGB,
    OAC_Lawyer,
    OAC_Kruger,
    OAC_Masseur,
    OAC_Mechanic,
    OAC_Norfolk,
    OAC_Plague,
    OAC_Psych,
    OAC_Shopkeep,
    OAC_Soldier,
    OAC_Tux,
    OAC_Vampire,
    OAC_YachtCrew,
    OAC_Exterminator,
    OAC_SoundCrew,
    OAC_Intern,
    OAC_Stalker,
    OAC_Scarecrow,
    OAC_Hacker,
    OAC_SpecOps,
    OAC_Berg,
    OAC_Morgue,
    OAC_Surgeon,
    OAC_Doctor,
    OAC_Director,
    OAC_Ninja,
    OAC_Baseball,
    OAC_KillBill,
    OAC_Pilot,
    OAC_Yoga,
    OAC_Mummy,
    OAC_Cowboy,
    OAC_Staff,
    OAC_Santa,
    OAC_MambaCrew,
    OAC_Delivery,
    OAC_GOTY_Clown,
    OAC_GOTY_Cowboy,
    OAC_GOTY_DarkSniper,
    OAC_Driver,
    OAC_Driverpale,
    OAC_Eventstff,
    OAC_Flrdaman,
    OAC_Food,
    OAC_Journal,
    OAC_Krnstdtengnr,
    OAC_Krnstdtsec,
    OAC_Ktchstff,
    OAC_Lee,
    OAC_Mascot,
    OAC_Medic,
    OAC_Mendez,
    OAC_Musician,
    OAC_Racecoord,
    OAC_Racemarsh,
    OAC_Thug,
    OAC_Worker,
    OAC_Research,
    OAC_Tatoo,
    OAC_Shaman,
    OAC_Artist,
    OAC_Barber,
    OAC_DJ,
    OAC_Kshmrn,
    OAC_Master,
    OAC_Burial,
    OAC_Ravenmaster,
    OAC_Sentinel,
    OAC_Blake,
    OAC_Actor,
    OAC_Architect,
    OAC_Arkian,
    OAC_Arkptrn,
    OAC_Bbq,
    OAC_Bollycrew,
    OAC_Cavegd,
    OAC_Civilian,
    OAC_Cavewkr,
    OAC_Clothsale,
    OAC_Counsellor,
    OAC_Cowboyhat,
    OAC_Custdn,
    OAC_Dancer,
    OAC_Dbbwll,
    OAC_Deadjanus,
    OAC_Driverch,
    OAC_Driversa,
    OAC_Driveruk,
    OAC_Driverus,
    OAC_Druglabwkr,
    OAC_Elite,
    OAC_Fakemlstrm,
    OAC_Farm,
    OAC_Fieldgrd,
    OAC_Headmaster,
    OAC_Knight,
    OAC_Laundrywkr,
    OAC_Lndrygrd,
    OAC_Mailman,
    OAC_Mansiongd,
    OAC_Mech_Miami,
    OAC_Mechch,
    OAC_Mechit,
    OAC_Mechkrnstdt,
    OAC_Mechsa,
    OAC_Mechuk,
    OAC_Mechus,
    OAC_Metalwkr,
    OAC_Militiasec,
    OAC_Mime,
    OAC_Moviemnstr,
    OAC_Mumbaiserv,
    OAC_Mumbsec,
    OAC_Nitiate,
    OAC_Nurse,
    OAC_Orson,
    OAC_Parka,
    OAC_Politicasst,
    OAC_Politician,
    OAC_Priest_VP,
    OAC_Queensgrd,
    OAC_Queenthug,
    OAC_Rangangrd,
    OAC_Rangansec,
    OAC_Realstbroke,
    OAC_Resident,
    OAC_Resortstaff,
    OAC_Sitewkr,
    OAC_Snowtrek,
    OAC_Subwkr,
    OAC_Suit,
    OAC_Tailor,
    OAC_Teaserv,
    OAC_Terminus,
    OAC_Trainserv,
    OAC_Villagegd,
    OAC_Winter,
    OAC_Wiseman,
    OAC_Investbanker,
    OAC_Bankteller,
    OAC_Robber,
    OAC_TechCrew,
    OAC_Attendant,
    OAC_Critic,
    OAC_FamilyGrd,
    OAC_PrivateEye,
    OAC_Undertaker,
    OAC_Photographer,
    OAC_LawyerBd,
    OAC_Biker,
    OAC_DeliveryFox,
    OAC_Dealer,
    OAC_ClubOwner,
    OAC_Bartender,
    OAC_ClubStaff,
    OAC_ClubTech,
    OAC_Herald,
    OAC_Gaucho,
    OAC_WineMkr,
    OAC_Fixer,
    OAC_Sommelier,
    OAC_Cook,
    OAC_EngineerDug,
    OAC_HavPirate,
    OAC_Pirate,
}

impl Aligned for EOutfitAICategory {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOutfitAICategory {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OAC_Undefined => 0i32,
            Self::OAC_Fallback => 1i32,
            Self::OAC_47Suit => 2i32,
            Self::OAC_47TRAINING => 3i32,
            Self::OAC_47MARRAKESH => 4i32,
            Self::OAC_47SAPIENZA => 5i32,
            Self::OAC_47BANGKOK => 6i32,
            Self::OAC_47COLORADO => 7i32,
            Self::OAC_47HOKKAIDO => 8i32,
            Self::OAC_47PREORDER => 9i32,
            Self::OAC_47COLUMBIA => 10i32,
            Self::OAC_47ISLAND => 11i32,
            Self::OAC_47MUMBAI => 12i32,
            Self::OAC_47NEWZEALAND => 13i32,
            Self::OAC_47STARTCLASSY => 14i32,
            Self::OAC_47STARTOUTFIT => 15i32,
            Self::OAC_47SUBURBIA => 16i32,
            Self::OAC_Bodyguard => 17i32,
            Self::OAC_CameraMan => 18i32,
            Self::OAC_Chef => 19i32,
            Self::OAC_Cleaner => 20i32,
            Self::OAC_Cop => 21i32,
            Self::OAC_Crew => 22i32,
            Self::OAC_DaSilva => 23i32,
            Self::OAC_Gardner => 24i32,
            Self::OAC_Hazmat => 25i32,
            Self::OAC_HouseStaff => 26i32,
            Self::OAC_Maintenance => 27i32,
            Self::OAC_Officer => 28i32,
            Self::OAC_Priest => 29i32,
            Self::OAC_Printer => 30i32,
            Self::OAC_Scientist => 31i32,
            Self::OAC_Security => 32i32,
            Self::OAC_Sheik => 33i32,
            Self::OAC_Stylist => 34i32,
            Self::OAC_Waiter => 35i32,
            Self::OAC_Busker => 36i32,
            Self::OAC_Caddie => 37i32,
            Self::OAC_ChurchStaff => 38i32,
            Self::OAC_Cyclist => 39i32,
            Self::OAC_Filmcrew => 40i32,
            Self::OAC_Fortune => 41i32,
            Self::OAC_Hippie => 42i32,
            Self::OAC_Investor => 43i32,
            Self::OAC_KGB => 44i32,
            Self::OAC_Lawyer => 45i32,
            Self::OAC_Kruger => 46i32,
            Self::OAC_Masseur => 47i32,
            Self::OAC_Mechanic => 48i32,
            Self::OAC_Norfolk => 49i32,
            Self::OAC_Plague => 50i32,
            Self::OAC_Psych => 51i32,
            Self::OAC_Shopkeep => 52i32,
            Self::OAC_Soldier => 53i32,
            Self::OAC_Tux => 54i32,
            Self::OAC_Vampire => 55i32,
            Self::OAC_YachtCrew => 56i32,
            Self::OAC_Exterminator => 57i32,
            Self::OAC_SoundCrew => 58i32,
            Self::OAC_Intern => 59i32,
            Self::OAC_Stalker => 60i32,
            Self::OAC_Scarecrow => 61i32,
            Self::OAC_Hacker => 62i32,
            Self::OAC_SpecOps => 63i32,
            Self::OAC_Berg => 64i32,
            Self::OAC_Morgue => 65i32,
            Self::OAC_Surgeon => 66i32,
            Self::OAC_Doctor => 67i32,
            Self::OAC_Director => 68i32,
            Self::OAC_Ninja => 69i32,
            Self::OAC_Baseball => 70i32,
            Self::OAC_KillBill => 71i32,
            Self::OAC_Pilot => 72i32,
            Self::OAC_Yoga => 73i32,
            Self::OAC_Mummy => 74i32,
            Self::OAC_Cowboy => 75i32,
            Self::OAC_Staff => 76i32,
            Self::OAC_Santa => 77i32,
            Self::OAC_MambaCrew => 78i32,
            Self::OAC_Delivery => 79i32,
            Self::OAC_GOTY_Clown => 80i32,
            Self::OAC_GOTY_Cowboy => 81i32,
            Self::OAC_GOTY_DarkSniper => 82i32,
            Self::OAC_Driver => 83i32,
            Self::OAC_Driverpale => 84i32,
            Self::OAC_Eventstff => 85i32,
            Self::OAC_Flrdaman => 86i32,
            Self::OAC_Food => 87i32,
            Self::OAC_Journal => 88i32,
            Self::OAC_Krnstdtengnr => 89i32,
            Self::OAC_Krnstdtsec => 90i32,
            Self::OAC_Ktchstff => 91i32,
            Self::OAC_Lee => 92i32,
            Self::OAC_Mascot => 93i32,
            Self::OAC_Medic => 94i32,
            Self::OAC_Mendez => 95i32,
            Self::OAC_Musician => 96i32,
            Self::OAC_Racecoord => 97i32,
            Self::OAC_Racemarsh => 98i32,
            Self::OAC_Thug => 99i32,
            Self::OAC_Worker => 100i32,
            Self::OAC_Research => 101i32,
            Self::OAC_Tatoo => 102i32,
            Self::OAC_Shaman => 103i32,
            Self::OAC_Artist => 104i32,
            Self::OAC_Barber => 105i32,
            Self::OAC_DJ => 106i32,
            Self::OAC_Kshmrn => 107i32,
            Self::OAC_Master => 108i32,
            Self::OAC_Burial => 109i32,
            Self::OAC_Ravenmaster => 110i32,
            Self::OAC_Sentinel => 111i32,
            Self::OAC_Blake => 112i32,
            Self::OAC_Actor => 113i32,
            Self::OAC_Architect => 114i32,
            Self::OAC_Arkian => 115i32,
            Self::OAC_Arkptrn => 116i32,
            Self::OAC_Bbq => 117i32,
            Self::OAC_Bollycrew => 118i32,
            Self::OAC_Cavegd => 119i32,
            Self::OAC_Civilian => 120i32,
            Self::OAC_Cavewkr => 121i32,
            Self::OAC_Clothsale => 122i32,
            Self::OAC_Counsellor => 123i32,
            Self::OAC_Cowboyhat => 124i32,
            Self::OAC_Custdn => 125i32,
            Self::OAC_Dancer => 126i32,
            Self::OAC_Dbbwll => 127i32,
            Self::OAC_Deadjanus => 128i32,
            Self::OAC_Driverch => 129i32,
            Self::OAC_Driversa => 130i32,
            Self::OAC_Driveruk => 131i32,
            Self::OAC_Driverus => 132i32,
            Self::OAC_Druglabwkr => 133i32,
            Self::OAC_Elite => 134i32,
            Self::OAC_Fakemlstrm => 135i32,
            Self::OAC_Farm => 136i32,
            Self::OAC_Fieldgrd => 137i32,
            Self::OAC_Headmaster => 138i32,
            Self::OAC_Knight => 139i32,
            Self::OAC_Laundrywkr => 140i32,
            Self::OAC_Lndrygrd => 141i32,
            Self::OAC_Mailman => 142i32,
            Self::OAC_Mansiongd => 143i32,
            Self::OAC_Mech_Miami => 144i32,
            Self::OAC_Mechch => 145i32,
            Self::OAC_Mechit => 146i32,
            Self::OAC_Mechkrnstdt => 147i32,
            Self::OAC_Mechsa => 148i32,
            Self::OAC_Mechuk => 149i32,
            Self::OAC_Mechus => 150i32,
            Self::OAC_Metalwkr => 151i32,
            Self::OAC_Militiasec => 152i32,
            Self::OAC_Mime => 153i32,
            Self::OAC_Moviemnstr => 154i32,
            Self::OAC_Mumbaiserv => 155i32,
            Self::OAC_Mumbsec => 156i32,
            Self::OAC_Nitiate => 157i32,
            Self::OAC_Nurse => 158i32,
            Self::OAC_Orson => 159i32,
            Self::OAC_Parka => 160i32,
            Self::OAC_Politicasst => 161i32,
            Self::OAC_Politician => 162i32,
            Self::OAC_Priest_VP => 163i32,
            Self::OAC_Queensgrd => 164i32,
            Self::OAC_Queenthug => 165i32,
            Self::OAC_Rangangrd => 166i32,
            Self::OAC_Rangansec => 167i32,
            Self::OAC_Realstbroke => 168i32,
            Self::OAC_Resident => 169i32,
            Self::OAC_Resortstaff => 170i32,
            Self::OAC_Sitewkr => 171i32,
            Self::OAC_Snowtrek => 172i32,
            Self::OAC_Subwkr => 173i32,
            Self::OAC_Suit => 174i32,
            Self::OAC_Tailor => 175i32,
            Self::OAC_Teaserv => 176i32,
            Self::OAC_Terminus => 177i32,
            Self::OAC_Trainserv => 178i32,
            Self::OAC_Villagegd => 179i32,
            Self::OAC_Winter => 180i32,
            Self::OAC_Wiseman => 181i32,
            Self::OAC_Investbanker => 182i32,
            Self::OAC_Bankteller => 183i32,
            Self::OAC_Robber => 184i32,
            Self::OAC_TechCrew => 185i32,
            Self::OAC_Attendant => 186i32,
            Self::OAC_Critic => 187i32,
            Self::OAC_FamilyGrd => 188i32,
            Self::OAC_PrivateEye => 189i32,
            Self::OAC_Undertaker => 190i32,
            Self::OAC_Photographer => 191i32,
            Self::OAC_LawyerBd => 192i32,
            Self::OAC_Biker => 193i32,
            Self::OAC_DeliveryFox => 194i32,
            Self::OAC_Dealer => 195i32,
            Self::OAC_ClubOwner => 196i32,
            Self::OAC_Bartender => 197i32,
            Self::OAC_ClubStaff => 198i32,
            Self::OAC_ClubTech => 199i32,
            Self::OAC_Herald => 200i32,
            Self::OAC_Gaucho => 201i32,
            Self::OAC_WineMkr => 202i32,
            Self::OAC_Fixer => 203i32,
            Self::OAC_Sommelier => 204i32,
            Self::OAC_Cook => 205i32,
            Self::OAC_EngineerDug => 206i32,
            Self::OAC_HavPirate => 207i32,
            Self::OAC_Pirate => 208i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOutfitAICategory {
     const TYPE_ID: &str = "EOutfitAICategory";
}

impl StaticVariant for Vec<EOutfitAICategory> {
     const TYPE_ID: &str = "TArray<EOutfitAICategory>";
}

impl StaticVariant for Vec<Vec<EOutfitAICategory>> {
     const TYPE_ID: &str = "TArray<TArray<EOutfitAICategory>>";
}

impl Variant for EOutfitAICategory {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOutfitAICategory")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOutfitAICategory".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOutfitAICategory>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOutfitAICategory>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOutfitAICategory>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EOutfitType {
    eOT_None,
    eOT_Suit,
    eOT_Guard,
    eOT_Worker,
    eOT_Waiter,
    eOT_LucasGrey,
}

impl Aligned for EOutfitType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EOutfitType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eOT_None => 0i32,
            Self::eOT_Suit => 1i32,
            Self::eOT_Guard => 2i32,
            Self::eOT_Worker => 3i32,
            Self::eOT_Waiter => 4i32,
            Self::eOT_LucasGrey => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EOutfitType {
     const TYPE_ID: &str = "EOutfitType";
}

impl StaticVariant for Vec<EOutfitType> {
     const TYPE_ID: &str = "TArray<EOutfitType>";
}

impl StaticVariant for Vec<Vec<EOutfitType>> {
     const TYPE_ID: &str = "TArray<TArray<EOutfitType>>";
}

impl Variant for EOutfitType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EOutfitType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EOutfitType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EOutfitType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EOutfitType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EOutfitType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EParticleColorUsage {
    REPLACE_PARTICLE_COLOR,
    LEAVE_PARTICLE_COLOR,
}

impl Aligned for EParticleColorUsage {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EParticleColorUsage {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::REPLACE_PARTICLE_COLOR => 0i8,
            Self::LEAVE_PARTICLE_COLOR => 1i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EParticleColorUsage {
     const TYPE_ID: &str = "EParticleColorUsage";
}

impl StaticVariant for Vec<EParticleColorUsage> {
     const TYPE_ID: &str = "TArray<EParticleColorUsage>";
}

impl StaticVariant for Vec<Vec<EParticleColorUsage>> {
     const TYPE_ID: &str = "TArray<TArray<EParticleColorUsage>>";
}

impl Variant for EParticleColorUsage {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EParticleColorUsage")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EParticleColorUsage".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EParticleColorUsage>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EParticleColorUsage>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EParticleColorUsage>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EParticleDecalSpawnEntity_Constraints {
    FACTOR_AND_RANDOMIZE,
    SIZE_RANGE,
}

impl Aligned for EParticleDecalSpawnEntity_Constraints {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EParticleDecalSpawnEntity_Constraints {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FACTOR_AND_RANDOMIZE => 0i32,
            Self::SIZE_RANGE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EParticleDecalSpawnEntity_Constraints {
     const TYPE_ID: &str = "EParticleDecalSpawnEntity_Constraints";
}

impl StaticVariant for Vec<EParticleDecalSpawnEntity_Constraints> {
     const TYPE_ID: &str = "TArray<EParticleDecalSpawnEntity_Constraints>";
}

impl StaticVariant for Vec<Vec<EParticleDecalSpawnEntity_Constraints>> {
     const TYPE_ID: &str = "TArray<TArray<EParticleDecalSpawnEntity_Constraints>>";
}

impl Variant for EParticleDecalSpawnEntity_Constraints {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EParticleDecalSpawnEntity_Constraints")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EParticleDecalSpawnEntity_Constraints".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EParticleDecalSpawnEntity_Constraints>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EParticleDecalSpawnEntity_Constraints>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EParticleDecalSpawnEntity_Constraints>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EParticleModifierImpulseDirections {
    TARGET_ZAXIS_DIRECTION,
    TOWARDS_TARGET_PIVOT,
    AWAY_FROM_TARGET_PIVOT,
}

impl Aligned for EParticleModifierImpulseDirections {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EParticleModifierImpulseDirections {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TARGET_ZAXIS_DIRECTION => 0i32,
            Self::TOWARDS_TARGET_PIVOT => 1i32,
            Self::AWAY_FROM_TARGET_PIVOT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EParticleModifierImpulseDirections {
     const TYPE_ID: &str = "EParticleModifierImpulseDirections";
}

impl StaticVariant for Vec<EParticleModifierImpulseDirections> {
     const TYPE_ID: &str = "TArray<EParticleModifierImpulseDirections>";
}

impl StaticVariant for Vec<Vec<EParticleModifierImpulseDirections>> {
     const TYPE_ID: &str = "TArray<TArray<EParticleModifierImpulseDirections>>";
}

impl Variant for EParticleModifierImpulseDirections {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EParticleModifierImpulseDirections")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EParticleModifierImpulseDirections".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EParticleModifierImpulseDirections>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EParticleModifierImpulseDirections>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EParticleModifierImpulseDirections>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EParticleSpritePivotLocation {
    CENTER_PIVOT,
    BOTTOM_PIVOT,
    TOP_PIVOT,
}

impl Aligned for EParticleSpritePivotLocation {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EParticleSpritePivotLocation {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CENTER_PIVOT => 0i8,
            Self::BOTTOM_PIVOT => 1i8,
            Self::TOP_PIVOT => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EParticleSpritePivotLocation {
     const TYPE_ID: &str = "EParticleSpritePivotLocation";
}

impl StaticVariant for Vec<EParticleSpritePivotLocation> {
     const TYPE_ID: &str = "TArray<EParticleSpritePivotLocation>";
}

impl StaticVariant for Vec<Vec<EParticleSpritePivotLocation>> {
     const TYPE_ID: &str = "TArray<TArray<EParticleSpritePivotLocation>>";
}

impl Variant for EParticleSpritePivotLocation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EParticleSpritePivotLocation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EParticleSpritePivotLocation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EParticleSpritePivotLocation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EParticleSpritePivotLocation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EParticleSpritePivotLocation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPathFinderBoxType {
    PFBT_INCLUDE_MESH_COLLISION,
    PFBT_EXCLUDE_MESH_COLLISION,
    PFBT_CREATE_MESH_COLLISION,
    PFBT_REGION,
    PFBT_INCLUDE_PORTALS,
    PFBT_EXCLUDE_PORTALS,
    PFBT_IGNORE,
}

impl Aligned for EPathFinderBoxType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPathFinderBoxType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PFBT_INCLUDE_MESH_COLLISION => 0i32,
            Self::PFBT_EXCLUDE_MESH_COLLISION => 1i32,
            Self::PFBT_CREATE_MESH_COLLISION => 2i32,
            Self::PFBT_REGION => 3i32,
            Self::PFBT_INCLUDE_PORTALS => 4i32,
            Self::PFBT_EXCLUDE_PORTALS => 5i32,
            Self::PFBT_IGNORE => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPathFinderBoxType {
     const TYPE_ID: &str = "EPathFinderBoxType";
}

impl StaticVariant for Vec<EPathFinderBoxType> {
     const TYPE_ID: &str = "TArray<EPathFinderBoxType>";
}

impl StaticVariant for Vec<Vec<EPathFinderBoxType>> {
     const TYPE_ID: &str = "TArray<TArray<EPathFinderBoxType>>";
}

impl Variant for EPathFinderBoxType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPathFinderBoxType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPathFinderBoxType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPathFinderBoxType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPathFinderBoxType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPathFinderBoxType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPersistentBoolDataSyncType {
    ePBDST_None,
    ePBDST_ServerAuthoritative,
    ePBDST_Full,
}

impl Aligned for EPersistentBoolDataSyncType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPersistentBoolDataSyncType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ePBDST_None => 0i32,
            Self::ePBDST_ServerAuthoritative => 1i32,
            Self::ePBDST_Full => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPersistentBoolDataSyncType {
     const TYPE_ID: &str = "EPersistentBoolDataSyncType";
}

impl StaticVariant for Vec<EPersistentBoolDataSyncType> {
     const TYPE_ID: &str = "TArray<EPersistentBoolDataSyncType>";
}

impl StaticVariant for Vec<Vec<EPersistentBoolDataSyncType>> {
     const TYPE_ID: &str = "TArray<TArray<EPersistentBoolDataSyncType>>";
}

impl Variant for EPersistentBoolDataSyncType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPersistentBoolDataSyncType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPersistentBoolDataSyncType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPersistentBoolDataSyncType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPersistentBoolDataSyncType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPersistentBoolDataSyncType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPhysicsObjectType {
    EPHYSICSOBJECTTYPE_UNKNOWN,
    EPHYSICSOBJECTTYPE_DYNAMIC,
    EPHYSICSOBJECTTYPE_KINEMATIC,
    EPHYSICSOBJECTTYPE_STATIC,
}

impl Aligned for EPhysicsObjectType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPhysicsObjectType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EPHYSICSOBJECTTYPE_UNKNOWN => 0i32,
            Self::EPHYSICSOBJECTTYPE_DYNAMIC => 1i32,
            Self::EPHYSICSOBJECTTYPE_KINEMATIC => 2i32,
            Self::EPHYSICSOBJECTTYPE_STATIC => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPhysicsObjectType {
     const TYPE_ID: &str = "EPhysicsObjectType";
}

impl StaticVariant for Vec<EPhysicsObjectType> {
     const TYPE_ID: &str = "TArray<EPhysicsObjectType>";
}

impl StaticVariant for Vec<Vec<EPhysicsObjectType>> {
     const TYPE_ID: &str = "TArray<TArray<EPhysicsObjectType>>";
}

impl Variant for EPhysicsObjectType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPhysicsObjectType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPhysicsObjectType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPhysicsObjectType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPhysicsObjectType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPhysicsObjectType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPlaceableType {
    PLACEABLE_NOT,
    PLACEABLE_FULL_PHYSICS,
    PLACEABLE_SLEEP_PHYSICS,
    PLACEABLE_NO_PHYSICS,
    PLACEABLE_ATTACH,
}

impl Aligned for EPlaceableType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPlaceableType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PLACEABLE_NOT => 0i32,
            Self::PLACEABLE_FULL_PHYSICS => 1i32,
            Self::PLACEABLE_SLEEP_PHYSICS => 2i32,
            Self::PLACEABLE_NO_PHYSICS => 3i32,
            Self::PLACEABLE_ATTACH => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPlaceableType {
     const TYPE_ID: &str = "EPlaceableType";
}

impl StaticVariant for Vec<EPlaceableType> {
     const TYPE_ID: &str = "TArray<EPlaceableType>";
}

impl StaticVariant for Vec<Vec<EPlaceableType>> {
     const TYPE_ID: &str = "TArray<TArray<EPlaceableType>>";
}

impl Variant for EPlaceableType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPlaceableType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPlaceableType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPlaceableType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPlaceableType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPlaceableType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPlayMode {
    PLAYMODE_STOPPED,
    PLAYMODE_PAUSED,
    PLAYMODE_PLAYING,
}

impl Aligned for EPlayMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPlayMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PLAYMODE_STOPPED => 1i32,
            Self::PLAYMODE_PAUSED => 2i32,
            Self::PLAYMODE_PLAYING => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPlayMode {
     const TYPE_ID: &str = "EPlayMode";
}

impl StaticVariant for Vec<EPlayMode> {
     const TYPE_ID: &str = "TArray<EPlayMode>";
}

impl StaticVariant for Vec<Vec<EPlayMode>> {
     const TYPE_ID: &str = "TArray<TArray<EPlayMode>>";
}

impl Variant for EPlayMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPlayMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPlayMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPlayMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPlayMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPlayMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPostProcessorComponentType {
    MRP_LOOKAT,
    MRP_AIM,
    MRP_LEDGEFEETLOCK,
    MRP_LEDGEHANG,
    MRP_IMPACT,
    MRP_BLINDFIRE,
}

impl Aligned for EPostProcessorComponentType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPostProcessorComponentType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MRP_LOOKAT => 1i32,
            Self::MRP_AIM => 2i32,
            Self::MRP_LEDGEFEETLOCK => 16i32,
            Self::MRP_LEDGEHANG => 32i32,
            Self::MRP_IMPACT => 1024i32,
            Self::MRP_BLINDFIRE => 2048i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPostProcessorComponentType {
     const TYPE_ID: &str = "EPostProcessorComponentType";
}

impl StaticVariant for Vec<EPostProcessorComponentType> {
     const TYPE_ID: &str = "TArray<EPostProcessorComponentType>";
}

impl StaticVariant for Vec<Vec<EPostProcessorComponentType>> {
     const TYPE_ID: &str = "TArray<TArray<EPostProcessorComponentType>>";
}

impl Variant for EPostProcessorComponentType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPostProcessorComponentType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPostProcessorComponentType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPostProcessorComponentType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPostProcessorComponentType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPostProcessorComponentType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EPushNotificationType {
    PUSH_NOTIFICATION_OBJECTIVE,
    PUSH_NOTIFICATION_DISGUISE,
    PUSH_NOTIFICATION_CONTRACT,
    PUSH_NOTIFICATION_CHALLENGE,
    PUSH_NOTIFICATION_RATING,
    PUSH_NOTIFICATION_SPECIAL_RATING_UNLOCKED,
    PUSH_NOTIFICATION_CONTRACT_PICKED_UP,
    PUSH_NOTIFICATION_TECHNIQUE_UNLOCKED,
    PUSH_NOTIFICATION_SCORE_COMPARISON,
}

impl Aligned for EPushNotificationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EPushNotificationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PUSH_NOTIFICATION_OBJECTIVE => 0i32,
            Self::PUSH_NOTIFICATION_DISGUISE => 1i32,
            Self::PUSH_NOTIFICATION_CONTRACT => 2i32,
            Self::PUSH_NOTIFICATION_CHALLENGE => 3i32,
            Self::PUSH_NOTIFICATION_RATING => 4i32,
            Self::PUSH_NOTIFICATION_SPECIAL_RATING_UNLOCKED => 5i32,
            Self::PUSH_NOTIFICATION_CONTRACT_PICKED_UP => 6i32,
            Self::PUSH_NOTIFICATION_TECHNIQUE_UNLOCKED => 7i32,
            Self::PUSH_NOTIFICATION_SCORE_COMPARISON => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EPushNotificationType {
     const TYPE_ID: &str = "EPushNotificationType";
}

impl StaticVariant for Vec<EPushNotificationType> {
     const TYPE_ID: &str = "TArray<EPushNotificationType>";
}

impl StaticVariant for Vec<Vec<EPushNotificationType>> {
     const TYPE_ID: &str = "TArray<TArray<EPushNotificationType>>";
}

impl Variant for EPushNotificationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EPushNotificationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EPushNotificationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EPushNotificationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EPushNotificationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EPushNotificationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EQueryMaskType {
    eQueryMaskType_CameraCollision,
    eQueryMaskType_CameraObstacle,
    eQueryMaskType_ExplosionRelevant,
}

impl Aligned for EQueryMaskType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EQueryMaskType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eQueryMaskType_CameraCollision => 1i32,
            Self::eQueryMaskType_CameraObstacle => 2i32,
            Self::eQueryMaskType_ExplosionRelevant => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EQueryMaskType {
     const TYPE_ID: &str = "EQueryMaskType";
}

impl StaticVariant for Vec<EQueryMaskType> {
     const TYPE_ID: &str = "TArray<EQueryMaskType>";
}

impl StaticVariant for Vec<Vec<EQueryMaskType>> {
     const TYPE_ID: &str = "TArray<TArray<EQueryMaskType>>";
}

impl Variant for EQueryMaskType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EQueryMaskType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EQueryMaskType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EQueryMaskType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EQueryMaskType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EQueryMaskType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERANDOM_DISTRIBUTION {
    RND_UNIFORM,
    RND_SAWTOOTH,
}

impl Aligned for ERANDOM_DISTRIBUTION {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERANDOM_DISTRIBUTION {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RND_UNIFORM => 0i32,
            Self::RND_SAWTOOTH => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERANDOM_DISTRIBUTION {
     const TYPE_ID: &str = "ERANDOM_DISTRIBUTION";
}

impl StaticVariant for Vec<ERANDOM_DISTRIBUTION> {
     const TYPE_ID: &str = "TArray<ERANDOM_DISTRIBUTION>";
}

impl StaticVariant for Vec<Vec<ERANDOM_DISTRIBUTION>> {
     const TYPE_ID: &str = "TArray<TArray<ERANDOM_DISTRIBUTION>>";
}

impl Variant for ERANDOM_DISTRIBUTION {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERANDOM_DISTRIBUTION")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERANDOM_DISTRIBUTION".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERANDOM_DISTRIBUTION>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERANDOM_DISTRIBUTION>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERANDOM_DISTRIBUTION>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ERagdollPart {
    ERAGDOLLPART_NONE,
    ERAGDOLLPART_BODY,
    ERAGDOLLPART_HEAD,
    ERAGDOLLPART_HAND,
    ERAGDOLLPART_FOOT,
}

impl Aligned for ERagdollPart {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ERagdollPart {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERAGDOLLPART_NONE => 0i8,
            Self::ERAGDOLLPART_BODY => 1i8,
            Self::ERAGDOLLPART_HEAD => 2i8,
            Self::ERAGDOLLPART_HAND => 3i8,
            Self::ERAGDOLLPART_FOOT => 4i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERagdollPart {
     const TYPE_ID: &str = "ERagdollPart";
}

impl StaticVariant for Vec<ERagdollPart> {
     const TYPE_ID: &str = "TArray<ERagdollPart>";
}

impl StaticVariant for Vec<Vec<ERagdollPart>> {
     const TYPE_ID: &str = "TArray<TArray<ERagdollPart>>";
}

impl Variant for ERagdollPart {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERagdollPart")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERagdollPart".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERagdollPart>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERagdollPart>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERagdollPart>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERatingCategory {
    ERatingCategory_Invalid,
    ERatingCategory_Flawless,
    ERatingCategory_Violence,
    ERatingCategory_Cunning,
    ERatingCategory_Noise,
    ERatingCategory_COUNT,
}

impl Aligned for ERatingCategory {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERatingCategory {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERatingCategory_Invalid => 0i32,
            Self::ERatingCategory_Flawless => 1i32,
            Self::ERatingCategory_Violence => 2i32,
            Self::ERatingCategory_Cunning => 3i32,
            Self::ERatingCategory_Noise => 4i32,
            Self::ERatingCategory_COUNT => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERatingCategory {
     const TYPE_ID: &str = "ERatingCategory";
}

impl StaticVariant for Vec<ERatingCategory> {
     const TYPE_ID: &str = "TArray<ERatingCategory>";
}

impl StaticVariant for Vec<Vec<ERatingCategory>> {
     const TYPE_ID: &str = "TArray<TArray<ERatingCategory>>";
}

impl Variant for ERatingCategory {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERatingCategory")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERatingCategory".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERatingCategory>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERatingCategory>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERatingCategory>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERatingTitle {
    ERatingTitle_SilentAssassin,
    ERatingTitle_PerfectAssassin,
    ERatingTitle_Ninja,
    ERatingTitle_GloryBlazer,
    ERatingTitle_Eraser,
    ERatingTitle_Exhibitionist,
    ERatingTitle_Trickster,
    ERatingTitle_Chameleon,
    ERatingTitle_Spider,
    ERatingTitle_Angel,
    ERatingTitle_COUNT,
}

impl Aligned for ERatingTitle {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERatingTitle {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERatingTitle_SilentAssassin => 0i32,
            Self::ERatingTitle_PerfectAssassin => 1i32,
            Self::ERatingTitle_Ninja => 2i32,
            Self::ERatingTitle_GloryBlazer => 3i32,
            Self::ERatingTitle_Eraser => 4i32,
            Self::ERatingTitle_Exhibitionist => 5i32,
            Self::ERatingTitle_Trickster => 6i32,
            Self::ERatingTitle_Chameleon => 7i32,
            Self::ERatingTitle_Spider => 8i32,
            Self::ERatingTitle_Angel => 9i32,
            Self::ERatingTitle_COUNT => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERatingTitle {
     const TYPE_ID: &str = "ERatingTitle";
}

impl StaticVariant for Vec<ERatingTitle> {
     const TYPE_ID: &str = "TArray<ERatingTitle>";
}

impl StaticVariant for Vec<Vec<ERatingTitle>> {
     const TYPE_ID: &str = "TArray<TArray<ERatingTitle>>";
}

impl Variant for ERatingTitle {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERatingTitle")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERatingTitle".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERatingTitle>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERatingTitle>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERatingTitle>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERatingTitleRequirement {
    ERatingTitleRequirement_Optional,
    ERatingTitleRequirement_Required,
    ERatingTitleRequirement_Fails,
}

impl Aligned for ERatingTitleRequirement {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERatingTitleRequirement {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERatingTitleRequirement_Optional => 0i32,
            Self::ERatingTitleRequirement_Required => 1i32,
            Self::ERatingTitleRequirement_Fails => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERatingTitleRequirement {
     const TYPE_ID: &str = "ERatingTitleRequirement";
}

impl StaticVariant for Vec<ERatingTitleRequirement> {
     const TYPE_ID: &str = "TArray<ERatingTitleRequirement>";
}

impl StaticVariant for Vec<Vec<ERatingTitleRequirement>> {
     const TYPE_ID: &str = "TArray<TArray<ERatingTitleRequirement>>";
}

impl Variant for ERatingTitleRequirement {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERatingTitleRequirement")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERatingTitleRequirement".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERatingTitleRequirement>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERatingTitleRequirement>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERatingTitleRequirement>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ERayDetailLevel {
    RAYDETAILS_NONE,
    RAYDETAILS_BONES,
    RAYDETAILS_MESH,
}

impl Aligned for ERayDetailLevel {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ERayDetailLevel {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RAYDETAILS_NONE => 0i8,
            Self::RAYDETAILS_BONES => 1i8,
            Self::RAYDETAILS_MESH => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERayDetailLevel {
     const TYPE_ID: &str = "ERayDetailLevel";
}

impl StaticVariant for Vec<ERayDetailLevel> {
     const TYPE_ID: &str = "TArray<ERayDetailLevel>";
}

impl StaticVariant for Vec<Vec<ERayDetailLevel>> {
     const TYPE_ID: &str = "TArray<TArray<ERayDetailLevel>>";
}

impl Variant for ERayDetailLevel {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERayDetailLevel")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERayDetailLevel".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERayDetailLevel>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERayDetailLevel>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERayDetailLevel>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERayLayer {
    eRayLayer_COLLIDE_WITH_ALL,
    eRayLayer_CAMERA_COLI,
    eRayLayer_CAMERA_COLI_CAMERA_OBSTACE_ONLY,
    eRayLayer_HERO_FIRE,
    eRayLayer_ACTOR_FIRE,
    eRayLayer_ACTOR_LINE_OF_FIRE,
    eRayLayer_FOOTSTEPS_COLI,
    eRayLayer_BLOODSPLATDECAL_COLI,
    eRayLayer_COLLIDE_WITH_STATIC,
    eRayLayer_COLLIDE_WITH_STATIC_EXCL_TRANSPARENT,
    eRayLayer_PARTICLES,
    eRayLayer_COVERSEARCH,
    eRayLayer_ACTOR_VISIBILITY,
    eRayLayer_ACTOR_VISIBILITY_AMBIENT,
    eRayLayer_PICKUP,
    eRayLayer_HERO_PROXY,
    eRayLayer_COLLIDE_WITH_STATIC_AND_SLOPE,
    eRayLayer_COLLIDE_WITH_STATIC_AND_SLOPE_EXCL_TRANSPARENT,
    eRayLayer_HERO_PROXY_NO_VOLUMES,
    eRayLayer_PHYSICS_MANIPULATOR,
    eRayLayer_UNUSED_LAST,
}

impl Aligned for ERayLayer {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERayLayer {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRayLayer_COLLIDE_WITH_ALL => 0i32,
            Self::eRayLayer_CAMERA_COLI => 1i32,
            Self::eRayLayer_CAMERA_COLI_CAMERA_OBSTACE_ONLY => 2i32,
            Self::eRayLayer_HERO_FIRE => 3i32,
            Self::eRayLayer_ACTOR_FIRE => 4i32,
            Self::eRayLayer_ACTOR_LINE_OF_FIRE => 5i32,
            Self::eRayLayer_FOOTSTEPS_COLI => 7i32,
            Self::eRayLayer_BLOODSPLATDECAL_COLI => 8i32,
            Self::eRayLayer_COLLIDE_WITH_STATIC => 9i32,
            Self::eRayLayer_COLLIDE_WITH_STATIC_EXCL_TRANSPARENT => 10i32,
            Self::eRayLayer_PARTICLES => 11i32,
            Self::eRayLayer_COVERSEARCH => 12i32,
            Self::eRayLayer_ACTOR_VISIBILITY => 13i32,
            Self::eRayLayer_ACTOR_VISIBILITY_AMBIENT => 14i32,
            Self::eRayLayer_PICKUP => 16i32,
            Self::eRayLayer_HERO_PROXY => 17i32,
            Self::eRayLayer_COLLIDE_WITH_STATIC_AND_SLOPE => 19i32,
            Self::eRayLayer_COLLIDE_WITH_STATIC_AND_SLOPE_EXCL_TRANSPARENT => 20i32,
            Self::eRayLayer_HERO_PROXY_NO_VOLUMES => 22i32,
            Self::eRayLayer_PHYSICS_MANIPULATOR => 23i32,
            Self::eRayLayer_UNUSED_LAST => 24i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERayLayer {
     const TYPE_ID: &str = "ERayLayer";
}

impl StaticVariant for Vec<ERayLayer> {
     const TYPE_ID: &str = "TArray<ERayLayer>";
}

impl StaticVariant for Vec<Vec<ERayLayer>> {
     const TYPE_ID: &str = "TArray<TArray<ERayLayer>>";
}

impl Variant for ERayLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERayLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERayLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERayLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERayLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERayLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERayType {
    ERAY_CLOSESTHIT_SIMPLE,
    ERAY_CLOSESTHIT_DETAILED,
}

impl Aligned for ERayType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERayType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERAY_CLOSESTHIT_SIMPLE => 0i32,
            Self::ERAY_CLOSESTHIT_DETAILED => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERayType {
     const TYPE_ID: &str = "ERayType";
}

impl StaticVariant for Vec<ERayType> {
     const TYPE_ID: &str = "TArray<ERayType>";
}

impl StaticVariant for Vec<Vec<ERayType>> {
     const TYPE_ID: &str = "TArray<TArray<ERayType>>";
}

impl Variant for ERayType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERayType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERayType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERayType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERayType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERayType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERegionId {
    RegionId_Default,
    RegionId_Japan,
    RegionId_Asia,
}

impl Aligned for ERegionId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERegionId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RegionId_Default => 0i32,
            Self::RegionId_Japan => 1i32,
            Self::RegionId_Asia => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERegionId {
     const TYPE_ID: &str = "ERegionId";
}

impl StaticVariant for Vec<ERegionId> {
     const TYPE_ID: &str = "TArray<ERegionId>";
}

impl StaticVariant for Vec<Vec<ERegionId>> {
     const TYPE_ID: &str = "TArray<TArray<ERegionId>>";
}

impl Variant for ERegionId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERegionId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERegionId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERegionId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERegionId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERegionId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERegionMask {
    eRM_None,
    eRM_LowCover,
    eRM_HighCover,
    eRM_Stairs,
    eRM_Separator,
    eRM_User_1,
    eRM_User_2,
    eRM_User_3,
    eRM_User_4,
    eRM_User_5,
    eRM_User_6,
    eRM_User_7,
    eRM_User_8,
}

impl Aligned for ERegionMask {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERegionMask {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRM_None => 1i32,
            Self::eRM_LowCover => 2i32,
            Self::eRM_HighCover => 4i32,
            Self::eRM_Stairs => 8i32,
            Self::eRM_Separator => 16i32,
            Self::eRM_User_1 => 32i32,
            Self::eRM_User_2 => 64i32,
            Self::eRM_User_3 => 128i32,
            Self::eRM_User_4 => 256i32,
            Self::eRM_User_5 => 512i32,
            Self::eRM_User_6 => 1024i32,
            Self::eRM_User_7 => 2048i32,
            Self::eRM_User_8 => 4096i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERegionMask {
     const TYPE_ID: &str = "ERegionMask";
}

impl StaticVariant for Vec<ERegionMask> {
     const TYPE_ID: &str = "TArray<ERegionMask>";
}

impl StaticVariant for Vec<Vec<ERegionMask>> {
     const TYPE_ID: &str = "TArray<TArray<ERegionMask>>";
}

impl Variant for ERegionMask {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERegionMask")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERegionMask".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERegionMask>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERegionMask>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERegionMask>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERegistrationState {
    eINITIAL,
    eNOP,
    ePENDING,
    eCANCELLED_REMOTELY,
    eCANCELLED_LOCALLY,
    eFOUNDMATCH,
}

impl Aligned for ERegistrationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERegistrationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eINITIAL => 0i32,
            Self::eNOP => 1i32,
            Self::ePENDING => 2i32,
            Self::eCANCELLED_REMOTELY => 3i32,
            Self::eCANCELLED_LOCALLY => 4i32,
            Self::eFOUNDMATCH => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERegistrationState {
     const TYPE_ID: &str = "ERegistrationState";
}

impl StaticVariant for Vec<ERegistrationState> {
     const TYPE_ID: &str = "TArray<ERegistrationState>";
}

impl StaticVariant for Vec<Vec<ERegistrationState>> {
     const TYPE_ID: &str = "TArray<TArray<ERegistrationState>>";
}

impl Variant for ERegistrationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERegistrationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERegistrationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERegistrationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERegistrationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERegistrationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ERenderGlowTypes {
    ERENDERGLOWTYPE_NONE,
    ERENDERGLOWTYPE_ENEMIES,
    ERENDERGLOWTYPE_ALLIES,
    ERENDERGLOWTYPE_CIVILIAN,
    ERENDERGLOWTYPE_ITEMS,
    ERENDERGLOWTYPE_STASHED_ITEMS,
    ERENDERGLOWTYPE_SETPIECE,
    ERENDERGLOWTYPE_BACKGROUND,
    ERENDERGLOWTYPE_CONTRACT_TARGET,
    ERENDERGLOWTYPE_CONTRACT_TARGET_NON_CRITICAL,
    ERENDERGLOWTYPE_CONTRACT_TARGET_SPECIAL,
    ERENDERGLOWTYPE_CONTRACT_SUSPECT,
    ERENDERGLOWTYPE_OBJECTIVES,
    ERENDERGLOWTYPE_ENFORCER,
    ERENDERGLOWTYPE_LTMEMORY,
    ERENDERGLOWTYPE_TAGGED,
    ERENDERGLOWTYPE_TAGFOCUS_UNTAGGED,
    ERENDERGLOWTYPE_TAGFOCUS_TAGGED,
    ERENDERGLOWTYPE_BACKGROUNDUNMASKED,
    ERENDERGLOWTYPE_INTERACTION,
    ERENDERGLOWTYPE_INTERACTION_SELECTED,
    ERENDERGLOWTYPE_INTERACTION_DESELECTED,
    ERENDERGLOWTYPE_PLAYER_LVA,
    ERENDERGLOWTYPE_PLAYER_LVA_SEEN,
    ERENDERGLOWTYPE_VS_OPPONENT,
    ERENDERGLOWTYPE_TRAVERSAL,
    ERENDERGLOWTYPE_EMISSIVE_UI,
    ERENDERGLOWTYPE_EMISSIVE_UI_IGNORE_DEPTH,
    ERENDERGLOWTYPE_OPPONENT,
    ERENDERGLOWTYPE_CAMERA,
}

impl Aligned for ERenderGlowTypes {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ERenderGlowTypes {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERENDERGLOWTYPE_NONE => 0i8,
            Self::ERENDERGLOWTYPE_ENEMIES => 1i8,
            Self::ERENDERGLOWTYPE_ALLIES => 2i8,
            Self::ERENDERGLOWTYPE_CIVILIAN => 3i8,
            Self::ERENDERGLOWTYPE_ITEMS => 4i8,
            Self::ERENDERGLOWTYPE_STASHED_ITEMS => 5i8,
            Self::ERENDERGLOWTYPE_SETPIECE => 6i8,
            Self::ERENDERGLOWTYPE_BACKGROUND => 7i8,
            Self::ERENDERGLOWTYPE_CONTRACT_TARGET => 8i8,
            Self::ERENDERGLOWTYPE_CONTRACT_TARGET_NON_CRITICAL => 9i8,
            Self::ERENDERGLOWTYPE_CONTRACT_TARGET_SPECIAL => 10i8,
            Self::ERENDERGLOWTYPE_CONTRACT_SUSPECT => 11i8,
            Self::ERENDERGLOWTYPE_OBJECTIVES => 12i8,
            Self::ERENDERGLOWTYPE_ENFORCER => 13i8,
            Self::ERENDERGLOWTYPE_LTMEMORY => 14i8,
            Self::ERENDERGLOWTYPE_TAGGED => 15i8,
            Self::ERENDERGLOWTYPE_TAGFOCUS_UNTAGGED => 16i8,
            Self::ERENDERGLOWTYPE_TAGFOCUS_TAGGED => 17i8,
            Self::ERENDERGLOWTYPE_BACKGROUNDUNMASKED => 18i8,
            Self::ERENDERGLOWTYPE_INTERACTION => 19i8,
            Self::ERENDERGLOWTYPE_INTERACTION_SELECTED => 20i8,
            Self::ERENDERGLOWTYPE_INTERACTION_DESELECTED => 21i8,
            Self::ERENDERGLOWTYPE_PLAYER_LVA => 22i8,
            Self::ERENDERGLOWTYPE_PLAYER_LVA_SEEN => 23i8,
            Self::ERENDERGLOWTYPE_VS_OPPONENT => 24i8,
            Self::ERENDERGLOWTYPE_TRAVERSAL => 25i8,
            Self::ERENDERGLOWTYPE_EMISSIVE_UI => 26i8,
            Self::ERENDERGLOWTYPE_EMISSIVE_UI_IGNORE_DEPTH => 27i8,
            Self::ERENDERGLOWTYPE_OPPONENT => 28i8,
            Self::ERENDERGLOWTYPE_CAMERA => 29i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERenderGlowTypes {
     const TYPE_ID: &str = "ERenderGlowTypes";
}

impl StaticVariant for Vec<ERenderGlowTypes> {
     const TYPE_ID: &str = "TArray<ERenderGlowTypes>";
}

impl StaticVariant for Vec<Vec<ERenderGlowTypes>> {
     const TYPE_ID: &str = "TArray<TArray<ERenderGlowTypes>>";
}

impl Variant for ERenderGlowTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERenderGlowTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERenderGlowTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERenderGlowTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERenderGlowTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERenderGlowTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERenderVRTrackingID {
    RENDER_VR_TRACK_HEAD,
    RENDER_VR_TRACK_EYE_LEFT,
    RENDER_VR_TRACK_EYE_RIGHT,
    RENDER_VR_TRACK_HAND_LEFT,
    RENDER_VR_TRACK_HAND_RIGHT,
}

impl Aligned for ERenderVRTrackingID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERenderVRTrackingID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RENDER_VR_TRACK_HEAD => 16i32,
            Self::RENDER_VR_TRACK_EYE_LEFT => 17i32,
            Self::RENDER_VR_TRACK_EYE_RIGHT => 18i32,
            Self::RENDER_VR_TRACK_HAND_LEFT => 19i32,
            Self::RENDER_VR_TRACK_HAND_RIGHT => 20i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERenderVRTrackingID {
     const TYPE_ID: &str = "ERenderVRTrackingID";
}

impl StaticVariant for Vec<ERenderVRTrackingID> {
     const TYPE_ID: &str = "TArray<ERenderVRTrackingID>";
}

impl StaticVariant for Vec<Vec<ERenderVRTrackingID>> {
     const TYPE_ID: &str = "TArray<TArray<ERenderVRTrackingID>>";
}

impl Variant for ERenderVRTrackingID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERenderVRTrackingID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERenderVRTrackingID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERenderVRTrackingID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERenderVRTrackingID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERenderVRTrackingID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EReplicaMode {
    E_RM_STATIC_OBJECT,
    E_RM_DYNAMIC,
}

impl Aligned for EReplicaMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EReplicaMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_RM_STATIC_OBJECT => 0i32,
            Self::E_RM_DYNAMIC => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EReplicaMode {
     const TYPE_ID: &str = "EReplicaMode";
}

impl StaticVariant for Vec<EReplicaMode> {
     const TYPE_ID: &str = "TArray<EReplicaMode>";
}

impl StaticVariant for Vec<Vec<EReplicaMode>> {
     const TYPE_ID: &str = "TArray<TArray<EReplicaMode>>";
}

impl Variant for EReplicaMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EReplicaMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EReplicaMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EReplicaMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EReplicaMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EReplicaMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EReplicaOperation {
    E_Created,
    E_Destroyed,
}

impl Aligned for EReplicaOperation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EReplicaOperation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_Created => 0i32,
            Self::E_Destroyed => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EReplicaOperation {
     const TYPE_ID: &str = "EReplicaOperation";
}

impl StaticVariant for Vec<EReplicaOperation> {
     const TYPE_ID: &str = "TArray<EReplicaOperation>";
}

impl StaticVariant for Vec<Vec<EReplicaOperation>> {
     const TYPE_ID: &str = "TArray<TArray<EReplicaOperation>>";
}

impl Variant for EReplicaOperation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EReplicaOperation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EReplicaOperation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EReplicaOperation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EReplicaOperation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EReplicaOperation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERequirementId {
    EREQUIREMENT_INVALID,
    EREQUIREMENT_TOKEN_OUTFIT_LEGACY_HERO_REQUIEMSUIT,
    EREQUIREMENT_FIREARMS_HERO_PISTOL_TACTICAL_015_SU_SKIN05,
    EREQUIREMENT_PROP_DEVICE_SONYPREORDER_WHITE_RUBBERDUCK_REMOTE_EXPLOSIVE,
    EREQUIREMENT_GOTY_PATIENT_ZERO,
    EREQUIREMENT_GOTY_TOKEN_OUTFIT_PARIS_CLOWN,
    EREQUIREMENT_GOTY_TOKEN_OUTFIT_HOKKAIDO_COWBOY,
    EREQUIREMENT_GOTY_TOKEN_OUTFIT_MARRAKESH_DARK_SNIPER,
    EREQUIREMENT_ANNIVERSARY_OUTFITS,
    EREQUIREMENT_LOCATION_NEWZEALAND,
    EREQUIREMENT_S2_EXECUTIVE_PACK,
    EREQUIREMENT_S2_COLLECTORS_PACK,
    EREQUIREMENT_S2_EXPANSION_VANITY_ITEM1,
    EREQUIREMENT_S2_EXPANSION_VANITY_ITEM2,
    EREQUIREMENT_PROP_CONTAINER_SUITCASE_ICA_STA_STADIA,
    EREQUIREMENT_PROP_DEVICE_ICA_RUBBERDUCK_REMOTE_EXPLOSIVE_STA_STADIA,
    EREQUIREMENT_H1_LEGACY_STANDARD,
    EREQUIREMENT_H1_LEGACY_EXPANSION,
    EREQUIREMENT_H2_LEGACY_STANDARD,
    EREQUIREMENT_H2_LEGACY_EXPANSION,
    EREQUIREMENT_H3_EXPANSION,
    EREQUIREMENT_LOCATION_COASTALTOWN,
    EREQUIREMENT_LOCATION_GOLDEN,
    EREQUIREMENT_LOCATION_ANCESTRAL,
    EREQUIREMENT_LOCATION_EDGY,
    EREQUIREMENT_LOCATION_WET,
    EREQUIREMENT_LOCATION_ELEGANT,
    EREQUIREMENT_LOCATION_TRAPPED,
    EREQUIREMENT_PLATFORM_ORBIS,
    EREQUIREMENT_PLATFORM_PS5,
    EREQUIREMENT_PLATFORM_GDK,
    EREQUIREMENT_PLATFORM_EPIC,
    EREQUIREMENT_PLATFORM_STEAM,
    EREQUIREMENT_PLATFORM_GGP,
    EREQUIREMENT_H3_PREORDER,
    EREQUIREMENT_PLATFORM_IZUMO,
    EREQUIREMENT_H3_DEADLYSINS_GREED,
    EREQUIREMENT_H3_DEADLYSINS_PRIDE,
    EREQUIREMENT_H3_DEADLYSINS_SLOTH,
    EREQUIREMENT_H3_DEADLYSINS_LUST,
    EREQUIREMENT_H3_DEADLYSINS_GLUTTONY,
    EREQUIREMENT_H3_DEADLYSINS_WRATH,
    EREQUIREMENT_H3_DEADLYSINS_ENVY,
    EREQUIREMENT_LOCATION_ROCKY,
    EREQUIREMENT_H3_VANITY_CONCRETEART,
    EREQUIREMENT_H3_VANITY_MAKESHIFTSCRAP,
    EREQUIREMENT_H3_SARAJEVO_SIX,
    EREQUIREMENT_H3_ET_SAMBUCA,
    EREQUIREMENT_H3_ET_PENICILLIN,
    EREQUIREMENT_H3_ET_TOMORROWLAND,
    EREQUIREMENT_H3_ET_LAMBIC,
    EREQUIREMENT_H3_ET_FRENCHMARTINI,
}

impl Aligned for ERequirementId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERequirementId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EREQUIREMENT_INVALID => 0i32,
            Self::EREQUIREMENT_TOKEN_OUTFIT_LEGACY_HERO_REQUIEMSUIT => 1i32,
            Self::EREQUIREMENT_FIREARMS_HERO_PISTOL_TACTICAL_015_SU_SKIN05 => 2i32,
            Self::EREQUIREMENT_PROP_DEVICE_SONYPREORDER_WHITE_RUBBERDUCK_REMOTE_EXPLOSIVE => 3i32,
            Self::EREQUIREMENT_GOTY_PATIENT_ZERO => 4i32,
            Self::EREQUIREMENT_GOTY_TOKEN_OUTFIT_PARIS_CLOWN => 5i32,
            Self::EREQUIREMENT_GOTY_TOKEN_OUTFIT_HOKKAIDO_COWBOY => 6i32,
            Self::EREQUIREMENT_GOTY_TOKEN_OUTFIT_MARRAKESH_DARK_SNIPER => 7i32,
            Self::EREQUIREMENT_ANNIVERSARY_OUTFITS => 8i32,
            Self::EREQUIREMENT_LOCATION_NEWZEALAND => 9i32,
            Self::EREQUIREMENT_S2_EXECUTIVE_PACK => 10i32,
            Self::EREQUIREMENT_S2_COLLECTORS_PACK => 11i32,
            Self::EREQUIREMENT_S2_EXPANSION_VANITY_ITEM1 => 12i32,
            Self::EREQUIREMENT_S2_EXPANSION_VANITY_ITEM2 => 13i32,
            Self::EREQUIREMENT_PROP_CONTAINER_SUITCASE_ICA_STA_STADIA => 14i32,
            Self::EREQUIREMENT_PROP_DEVICE_ICA_RUBBERDUCK_REMOTE_EXPLOSIVE_STA_STADIA => 15i32,
            Self::EREQUIREMENT_H1_LEGACY_STANDARD => 16i32,
            Self::EREQUIREMENT_H1_LEGACY_EXPANSION => 17i32,
            Self::EREQUIREMENT_H2_LEGACY_STANDARD => 18i32,
            Self::EREQUIREMENT_H2_LEGACY_EXPANSION => 19i32,
            Self::EREQUIREMENT_H3_EXPANSION => 20i32,
            Self::EREQUIREMENT_LOCATION_COASTALTOWN => 21i32,
            Self::EREQUIREMENT_LOCATION_GOLDEN => 22i32,
            Self::EREQUIREMENT_LOCATION_ANCESTRAL => 23i32,
            Self::EREQUIREMENT_LOCATION_EDGY => 24i32,
            Self::EREQUIREMENT_LOCATION_WET => 25i32,
            Self::EREQUIREMENT_LOCATION_ELEGANT => 26i32,
            Self::EREQUIREMENT_LOCATION_TRAPPED => 27i32,
            Self::EREQUIREMENT_PLATFORM_ORBIS => 28i32,
            Self::EREQUIREMENT_PLATFORM_PS5 => 29i32,
            Self::EREQUIREMENT_PLATFORM_GDK => 30i32,
            Self::EREQUIREMENT_PLATFORM_EPIC => 31i32,
            Self::EREQUIREMENT_PLATFORM_STEAM => 32i32,
            Self::EREQUIREMENT_PLATFORM_GGP => 33i32,
            Self::EREQUIREMENT_H3_PREORDER => 34i32,
            Self::EREQUIREMENT_PLATFORM_IZUMO => 35i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_GREED => 36i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_PRIDE => 37i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_SLOTH => 38i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_LUST => 39i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_GLUTTONY => 40i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_WRATH => 41i32,
            Self::EREQUIREMENT_H3_DEADLYSINS_ENVY => 42i32,
            Self::EREQUIREMENT_LOCATION_ROCKY => 43i32,
            Self::EREQUIREMENT_H3_VANITY_CONCRETEART => 44i32,
            Self::EREQUIREMENT_H3_VANITY_MAKESHIFTSCRAP => 45i32,
            Self::EREQUIREMENT_H3_SARAJEVO_SIX => 46i32,
            Self::EREQUIREMENT_H3_ET_SAMBUCA => 47i32,
            Self::EREQUIREMENT_H3_ET_PENICILLIN => 48i32,
            Self::EREQUIREMENT_H3_ET_TOMORROWLAND => 49i32,
            Self::EREQUIREMENT_H3_ET_LAMBIC => 50i32,
            Self::EREQUIREMENT_H3_ET_FRENCHMARTINI => 51i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERequirementId {
     const TYPE_ID: &str = "ERequirementId";
}

impl StaticVariant for Vec<ERequirementId> {
     const TYPE_ID: &str = "TArray<ERequirementId>";
}

impl StaticVariant for Vec<Vec<ERequirementId>> {
     const TYPE_ID: &str = "TArray<TArray<ERequirementId>>";
}

impl Variant for ERequirementId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERequirementId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERequirementId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERequirementId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERequirementId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERequirementId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ERestitutionCombineMode {
    ERestitutionCombineMode_AVERAGE,
    ERestitutionCombineMode_MIN,
    ERestitutionCombineMode_MULTIPLY,
    ERestitutionCombineMode_MAX,
}

impl Aligned for ERestitutionCombineMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ERestitutionCombineMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERestitutionCombineMode_AVERAGE => 0i8,
            Self::ERestitutionCombineMode_MIN => 1i8,
            Self::ERestitutionCombineMode_MULTIPLY => 2i8,
            Self::ERestitutionCombineMode_MAX => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERestitutionCombineMode {
     const TYPE_ID: &str = "ERestitutionCombineMode";
}

impl StaticVariant for Vec<ERestitutionCombineMode> {
     const TYPE_ID: &str = "TArray<ERestitutionCombineMode>";
}

impl StaticVariant for Vec<Vec<ERestitutionCombineMode>> {
     const TYPE_ID: &str = "TArray<TArray<ERestitutionCombineMode>>";
}

impl Variant for ERestitutionCombineMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERestitutionCombineMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERestitutionCombineMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERestitutionCombineMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERestitutionCombineMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERestitutionCombineMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERoleEvent {
    eRE_NONE,
    eRE_CAST,
    eRE_CLEAR,
    eRE_ENTER_DRAMA,
    eRE_REENTER_DRAMA,
    eRE_LEAVE_DRAMA,
    eRE_NEW_DRAMA,
    eRE_PAUSED,
    eRE_RESUMING,
    eRE_RUNNING,
}

impl Aligned for ERoleEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERoleEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRE_NONE => 0i32,
            Self::eRE_CAST => 1i32,
            Self::eRE_CLEAR => 2i32,
            Self::eRE_ENTER_DRAMA => 3i32,
            Self::eRE_REENTER_DRAMA => 4i32,
            Self::eRE_LEAVE_DRAMA => 5i32,
            Self::eRE_NEW_DRAMA => 6i32,
            Self::eRE_PAUSED => 7i32,
            Self::eRE_RESUMING => 8i32,
            Self::eRE_RUNNING => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERoleEvent {
     const TYPE_ID: &str = "ERoleEvent";
}

impl StaticVariant for Vec<ERoleEvent> {
     const TYPE_ID: &str = "TArray<ERoleEvent>";
}

impl StaticVariant for Vec<Vec<ERoleEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ERoleEvent>>";
}

impl Variant for ERoleEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERoleEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERoleEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERoleEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERoleEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERoleEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ERuntimeMemoryAllocationState {
    eRMAS_NeverAllocated,
    eRMAS_Allocated,
    eRMAS_Released,
}

impl Aligned for ERuntimeMemoryAllocationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ERuntimeMemoryAllocationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRMAS_NeverAllocated => 0i32,
            Self::eRMAS_Allocated => 1i32,
            Self::eRMAS_Released => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ERuntimeMemoryAllocationState {
     const TYPE_ID: &str = "ERuntimeMemoryAllocationState";
}

impl StaticVariant for Vec<ERuntimeMemoryAllocationState> {
     const TYPE_ID: &str = "TArray<ERuntimeMemoryAllocationState>";
}

impl StaticVariant for Vec<Vec<ERuntimeMemoryAllocationState>> {
     const TYPE_ID: &str = "TArray<TArray<ERuntimeMemoryAllocationState>>";
}

impl Variant for ERuntimeMemoryAllocationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ERuntimeMemoryAllocationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ERuntimeMemoryAllocationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ERuntimeMemoryAllocationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ERuntimeMemoryAllocationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ERuntimeMemoryAllocationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESaveLoadStatus {
    ESaveLoadStatus_OK,
    ESaveLoadStatus_PROCESSING,
    ESaveLoadStatus_MISSING,
    ESaveLoadStatus_ERROR_NODISKSPACE,
    ESaveLoadStatus_ERROR_DEVICEREMOVED,
    ESaveLoadStatus_ERROR_CORRUPT,
    ESaveLoadStatus_ERROR_VERSION,
    ESaveLoadStatus_ERROR_TAMPERED,
    ESaveLoadStatus_ERROR_SAVING,
    ESaveLoadStatus_ERROR_FATAL,
    ESaveLoadStatus_ERROR_ONLINE,
    ESaveLoadStatus_ERROR_REQUIREMENTCHECK,
    ESaveLoadStatus_ERROR_VRMODE,
    ESaveLoadStatus_ERROR_INVALIDATED,
}

impl Aligned for ESaveLoadStatus {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESaveLoadStatus {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESaveLoadStatus_OK => 0i32,
            Self::ESaveLoadStatus_PROCESSING => 1i32,
            Self::ESaveLoadStatus_MISSING => 2i32,
            Self::ESaveLoadStatus_ERROR_NODISKSPACE => 3i32,
            Self::ESaveLoadStatus_ERROR_DEVICEREMOVED => 4i32,
            Self::ESaveLoadStatus_ERROR_CORRUPT => 5i32,
            Self::ESaveLoadStatus_ERROR_VERSION => 6i32,
            Self::ESaveLoadStatus_ERROR_TAMPERED => 7i32,
            Self::ESaveLoadStatus_ERROR_SAVING => 8i32,
            Self::ESaveLoadStatus_ERROR_FATAL => 9i32,
            Self::ESaveLoadStatus_ERROR_ONLINE => 10i32,
            Self::ESaveLoadStatus_ERROR_REQUIREMENTCHECK => 11i32,
            Self::ESaveLoadStatus_ERROR_VRMODE => 12i32,
            Self::ESaveLoadStatus_ERROR_INVALIDATED => 13i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESaveLoadStatus {
     const TYPE_ID: &str = "ESaveLoadStatus";
}

impl StaticVariant for Vec<ESaveLoadStatus> {
     const TYPE_ID: &str = "TArray<ESaveLoadStatus>";
}

impl StaticVariant for Vec<Vec<ESaveLoadStatus>> {
     const TYPE_ID: &str = "TArray<TArray<ESaveLoadStatus>>";
}

impl Variant for ESaveLoadStatus {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESaveLoadStatus")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESaveLoadStatus".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESaveLoadStatus>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESaveLoadStatus>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESaveLoadStatus>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESaveType {
    ESaveType_AutoSave,
    ESaveType_QuickSave,
    ESaveType_SystemData,
    ESaveType_LocalProfile,
}

impl Aligned for ESaveType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESaveType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESaveType_AutoSave => 0i32,
            Self::ESaveType_QuickSave => 1i32,
            Self::ESaveType_SystemData => 2i32,
            Self::ESaveType_LocalProfile => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESaveType {
     const TYPE_ID: &str = "ESaveType";
}

impl StaticVariant for Vec<ESaveType> {
     const TYPE_ID: &str = "TArray<ESaveType>";
}

impl StaticVariant for Vec<Vec<ESaveType>> {
     const TYPE_ID: &str = "TArray<TArray<ESaveType>>";
}

impl Variant for ESaveType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESaveType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESaveType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESaveType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESaveType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESaveType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EScreenAnchor {
    SCREEN_ANCHOR_TOP_LEFT,
    SCREEN_ANCHOR_TOP_CENTER,
    SCREEN_ANCHOR_TOP_RIGHT,
    SCREEN_ANCHOR_MIDDLE_LEFT,
    SCREEN_ANCHOR_MIDDLE_CENTER,
    SCREEN_ANCHOR_MIDDLE_RIGHT,
    SCREEN_ANCHOR_BOTTOM_LEFT,
    SCREEN_ANCHOR_BOTTOM_CENTER,
    SCREEN_ANCHOR_BOTTOM_RIGHT,
}

impl Aligned for EScreenAnchor {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EScreenAnchor {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SCREEN_ANCHOR_TOP_LEFT => 0i32,
            Self::SCREEN_ANCHOR_TOP_CENTER => 1i32,
            Self::SCREEN_ANCHOR_TOP_RIGHT => 2i32,
            Self::SCREEN_ANCHOR_MIDDLE_LEFT => 3i32,
            Self::SCREEN_ANCHOR_MIDDLE_CENTER => 4i32,
            Self::SCREEN_ANCHOR_MIDDLE_RIGHT => 5i32,
            Self::SCREEN_ANCHOR_BOTTOM_LEFT => 6i32,
            Self::SCREEN_ANCHOR_BOTTOM_CENTER => 7i32,
            Self::SCREEN_ANCHOR_BOTTOM_RIGHT => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EScreenAnchor {
     const TYPE_ID: &str = "EScreenAnchor";
}

impl StaticVariant for Vec<EScreenAnchor> {
     const TYPE_ID: &str = "TArray<EScreenAnchor>";
}

impl StaticVariant for Vec<Vec<EScreenAnchor>> {
     const TYPE_ID: &str = "TArray<TArray<EScreenAnchor>>";
}

impl Variant for EScreenAnchor {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EScreenAnchor")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EScreenAnchor".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EScreenAnchor>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EScreenAnchor>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EScreenAnchor>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EScreenPlayState {
    State_Stopped,
    State_Running,
    State_Resuming,
    State_Pausing,
    State_Paused,
    State_Done,
    State_Terminated,
}

impl Aligned for EScreenPlayState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EScreenPlayState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::State_Stopped => 0i32,
            Self::State_Running => 1i32,
            Self::State_Resuming => 2i32,
            Self::State_Pausing => 3i32,
            Self::State_Paused => 4i32,
            Self::State_Done => 5i32,
            Self::State_Terminated => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EScreenPlayState {
     const TYPE_ID: &str = "EScreenPlayState";
}

impl StaticVariant for Vec<EScreenPlayState> {
     const TYPE_ID: &str = "TArray<EScreenPlayState>";
}

impl StaticVariant for Vec<Vec<EScreenPlayState>> {
     const TYPE_ID: &str = "TArray<TArray<EScreenPlayState>>";
}

impl Variant for EScreenPlayState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EScreenPlayState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EScreenPlayState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EScreenPlayState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EScreenPlayState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EScreenPlayState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EScreenplayStateFlag {
    eSSF_DEFAULT,
    eSSF_ENABLED,
    eSSF_CAST,
    eSSF_RESUMING,
    eSSF_RUNNING,
    eSSF_DONE,
    eSSF_TERMINATED,
}

impl Aligned for EScreenplayStateFlag {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EScreenplayStateFlag {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSSF_DEFAULT => 0i32,
            Self::eSSF_ENABLED => 1i32,
            Self::eSSF_CAST => 2i32,
            Self::eSSF_RESUMING => 4i32,
            Self::eSSF_RUNNING => 8i32,
            Self::eSSF_DONE => 16i32,
            Self::eSSF_TERMINATED => 32i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EScreenplayStateFlag {
     const TYPE_ID: &str = "EScreenplayStateFlag";
}

impl StaticVariant for Vec<EScreenplayStateFlag> {
     const TYPE_ID: &str = "TArray<EScreenplayStateFlag>";
}

impl StaticVariant for Vec<Vec<EScreenplayStateFlag>> {
     const TYPE_ID: &str = "TArray<TArray<EScreenplayStateFlag>>";
}

impl Variant for EScreenplayStateFlag {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EScreenplayStateFlag")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EScreenplayStateFlag".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EScreenplayStateFlag>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EScreenplayStateFlag>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EScreenplayStateFlag>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EScreenplayTriggerEvent {
    STT_ReportCrime,
    STT_ReportCrimeToHitman,
    STT_ReportCrimeMoveBack,
}

impl Aligned for EScreenplayTriggerEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EScreenplayTriggerEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::STT_ReportCrime => 0i32,
            Self::STT_ReportCrimeToHitman => 1i32,
            Self::STT_ReportCrimeMoveBack => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EScreenplayTriggerEvent {
     const TYPE_ID: &str = "EScreenplayTriggerEvent";
}

impl StaticVariant for Vec<EScreenplayTriggerEvent> {
     const TYPE_ID: &str = "TArray<EScreenplayTriggerEvent>";
}

impl StaticVariant for Vec<Vec<EScreenplayTriggerEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EScreenplayTriggerEvent>>";
}

impl Variant for EScreenplayTriggerEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EScreenplayTriggerEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EScreenplayTriggerEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EScreenplayTriggerEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EScreenplayTriggerEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EScreenplayTriggerEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ESeamFixMode {
    SEAMFIX_NONE,
    SEAMFIX_X,
    SEAMFIX_Y,
    SEAMFIX_Z,
    SEAMFIX_XZ,
    SEAMFIX_XY,
    SEAMFIX_XYZ,
    SEAMFIX_YZ,
}

impl Aligned for ESeamFixMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ESeamFixMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SEAMFIX_NONE => 0i8,
            Self::SEAMFIX_X => 1i8,
            Self::SEAMFIX_Y => 2i8,
            Self::SEAMFIX_Z => 4i8,
            Self::SEAMFIX_XZ => 5i8,
            Self::SEAMFIX_XY => 3i8,
            Self::SEAMFIX_XYZ => 7i8,
            Self::SEAMFIX_YZ => 6i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESeamFixMode {
     const TYPE_ID: &str = "ESeamFixMode";
}

impl StaticVariant for Vec<ESeamFixMode> {
     const TYPE_ID: &str = "TArray<ESeamFixMode>";
}

impl StaticVariant for Vec<Vec<ESeamFixMode>> {
     const TYPE_ID: &str = "TArray<TArray<ESeamFixMode>>";
}

impl Variant for ESeamFixMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESeamFixMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESeamFixMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESeamFixMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESeamFixMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESeamFixMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESentryActionPrompt {
    eSAP_None,
    eSAP_Frisk,
    eSAP_ShowItem,
    eSAP_Max,
}

impl Aligned for ESentryActionPrompt {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESentryActionPrompt {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSAP_None => 0i32,
            Self::eSAP_Frisk => 1i32,
            Self::eSAP_ShowItem => 2i32,
            Self::eSAP_Max => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESentryActionPrompt {
     const TYPE_ID: &str = "ESentryActionPrompt";
}

impl StaticVariant for Vec<ESentryActionPrompt> {
     const TYPE_ID: &str = "TArray<ESentryActionPrompt>";
}

impl StaticVariant for Vec<Vec<ESentryActionPrompt>> {
     const TYPE_ID: &str = "TArray<TArray<ESentryActionPrompt>>";
}

impl Variant for ESentryActionPrompt {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESentryActionPrompt")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESentryActionPrompt".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESentryActionPrompt>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESentryActionPrompt>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESentryActionPrompt>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESequencePreviewState {
    PREVIEW_STOPPED,
    PREVIEW_PLAYING,
    PREVIEW_PAUSED,
}

impl Aligned for ESequencePreviewState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESequencePreviewState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PREVIEW_STOPPED => 0i32,
            Self::PREVIEW_PLAYING => 1i32,
            Self::PREVIEW_PAUSED => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESequencePreviewState {
     const TYPE_ID: &str = "ESequencePreviewState";
}

impl StaticVariant for Vec<ESequencePreviewState> {
     const TYPE_ID: &str = "TArray<ESequencePreviewState>";
}

impl StaticVariant for Vec<Vec<ESequencePreviewState>> {
     const TYPE_ID: &str = "TArray<TArray<ESequencePreviewState>>";
}

impl Variant for ESequencePreviewState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESequencePreviewState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESequencePreviewState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESequencePreviewState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESequencePreviewState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESequencePreviewState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ESignInState {
    eSignInState_NotSignedIn,
    eSignInState_Local,
    eSignInState_Online,
    eSignInState_ENUM_END,
}

impl Aligned for ESignInState {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ESignInState {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSignInState_NotSignedIn => 0i8,
            Self::eSignInState_Local => 1i8,
            Self::eSignInState_Online => 2i8,
            Self::eSignInState_ENUM_END => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESignInState {
     const TYPE_ID: &str = "ESignInState";
}

impl StaticVariant for Vec<ESignInState> {
     const TYPE_ID: &str = "TArray<ESignInState>";
}

impl StaticVariant for Vec<Vec<ESignInState>> {
     const TYPE_ID: &str = "TArray<TArray<ESignInState>>";
}

impl Variant for ESignInState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESignInState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESignInState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESignInState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESignInState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESignInState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESilenceRating {
    eSR_NotSilenced,
    eSR_Silenced,
    eSR_SuperSilenced,
    eSR_CompletelySilenced,
}

impl Aligned for ESilenceRating {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESilenceRating {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSR_NotSilenced => 0i32,
            Self::eSR_Silenced => 1i32,
            Self::eSR_SuperSilenced => 2i32,
            Self::eSR_CompletelySilenced => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESilenceRating {
     const TYPE_ID: &str = "ESilenceRating";
}

impl StaticVariant for Vec<ESilenceRating> {
     const TYPE_ID: &str = "TArray<ESilenceRating>";
}

impl StaticVariant for Vec<Vec<ESilenceRating>> {
     const TYPE_ID: &str = "TArray<TArray<ESilenceRating>>";
}

impl Variant for ESilenceRating {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESilenceRating")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESilenceRating".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESilenceRating>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESilenceRating>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESilenceRating>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESituationAvailability {
    ESA_AMBIENCE,
    ESA_AMBIENCE_RESV,
    ESA_OVR_STANDING,
    ESA_OVR_CURIOUS,
    ESA_OVR_SENTRY,
    ESA_OVR_CAUTIOUS,
    ESA_OVR_COMBAT,
    ESA_OVR_ALL,
}

impl Aligned for ESituationAvailability {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESituationAvailability {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESA_AMBIENCE => 0i32,
            Self::ESA_AMBIENCE_RESV => 10000i32,
            Self::ESA_OVR_STANDING => 20000i32,
            Self::ESA_OVR_CURIOUS => 30000i32,
            Self::ESA_OVR_SENTRY => 40000i32,
            Self::ESA_OVR_CAUTIOUS => 50000i32,
            Self::ESA_OVR_COMBAT => 60000i32,
            Self::ESA_OVR_ALL => 70000i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESituationAvailability {
     const TYPE_ID: &str = "ESituationAvailability";
}

impl StaticVariant for Vec<ESituationAvailability> {
     const TYPE_ID: &str = "TArray<ESituationAvailability>";
}

impl StaticVariant for Vec<Vec<ESituationAvailability>> {
     const TYPE_ID: &str = "TArray<TArray<ESituationAvailability>>";
}

impl Variant for ESituationAvailability {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESituationAvailability")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESituationAvailability".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESituationAvailability>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESituationAvailability>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESituationAvailability>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESituationJoinReason {
    AISJR_Default,
    AISJR_HeardSound,
    AISJR_Alarm,
    AISJR_HitmanStrange,
    AISJR_HitmanIllegal,
    AISJR_Assist,
    AISJR_AssistingGuard,
    AISJR_Propagate,
    AISJR_ResumeSituation,
    AISJR_Spawned,
    AISJR_HelpCivilian,
    AISJR_Escalating,
    AISJR_DeadBody,
    AISJR_Accident,
    AISJR_StandDown,
    AISJR_Report,
    AISJR_ForcedToHold,
    AISJR_Wounded,
    AISJR_SC_HeardBulletImpact,
    AISJR_SC_HeardSetPiece,
}

impl Aligned for ESituationJoinReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESituationJoinReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AISJR_Default => 0i32,
            Self::AISJR_HeardSound => 1i32,
            Self::AISJR_Alarm => 2i32,
            Self::AISJR_HitmanStrange => 3i32,
            Self::AISJR_HitmanIllegal => 4i32,
            Self::AISJR_Assist => 5i32,
            Self::AISJR_AssistingGuard => 6i32,
            Self::AISJR_Propagate => 7i32,
            Self::AISJR_ResumeSituation => 8i32,
            Self::AISJR_Spawned => 9i32,
            Self::AISJR_HelpCivilian => 10i32,
            Self::AISJR_Escalating => 11i32,
            Self::AISJR_DeadBody => 12i32,
            Self::AISJR_Accident => 13i32,
            Self::AISJR_StandDown => 14i32,
            Self::AISJR_Report => 15i32,
            Self::AISJR_ForcedToHold => 16i32,
            Self::AISJR_Wounded => 17i32,
            Self::AISJR_SC_HeardBulletImpact => 18i32,
            Self::AISJR_SC_HeardSetPiece => 19i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESituationJoinReason {
     const TYPE_ID: &str = "ESituationJoinReason";
}

impl StaticVariant for Vec<ESituationJoinReason> {
     const TYPE_ID: &str = "TArray<ESituationJoinReason>";
}

impl StaticVariant for Vec<Vec<ESituationJoinReason>> {
     const TYPE_ID: &str = "TArray<TArray<ESituationJoinReason>>";
}

impl Variant for ESituationJoinReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESituationJoinReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESituationJoinReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESituationJoinReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESituationJoinReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESituationJoinReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESituationStateChangeReason {
    eSSCR_NONE,
    eSSCR_C_DIED,
    eSSCR_C_DEACTIVATED,
    eSSCR_C_CONTROLLED,
    eSSCR_C_CLOSE_COMBAT,
    eSSCR_C_HERO_ACTION,
    eSSCR_C_PACIFIED,
    eSSCR_CL_CHILD_DRAMA,
    eSSCR_CL_OTHER_DRAMA,
    eSSCR_CL_SYSTEMIC,
    eSSCR_S_DISABLED,
    eSSCR_S_DONE,
    eSSCR_S_TERMINATED,
    eSSCR_S_STARTED,
    eSSCR_S_RESUMING,
    eSSCR_S_UNPAUSE,
    eSSCR_R_RESOURCE_UNAVAILABLE,
    eSSCR_PAUSED_FROM_PLAYING,
    eSSCR_PAUSED_FROM_RESUMING,
}

impl Aligned for ESituationStateChangeReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESituationStateChangeReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSSCR_NONE => 0i32,
            Self::eSSCR_C_DIED => 16i32,
            Self::eSSCR_C_DEACTIVATED => 32i32,
            Self::eSSCR_C_CONTROLLED => 64i32,
            Self::eSSCR_C_CLOSE_COMBAT => 128i32,
            Self::eSSCR_C_HERO_ACTION => 256i32,
            Self::eSSCR_C_PACIFIED => 512i32,
            Self::eSSCR_CL_CHILD_DRAMA => 1024i32,
            Self::eSSCR_CL_OTHER_DRAMA => 2048i32,
            Self::eSSCR_CL_SYSTEMIC => 4096i32,
            Self::eSSCR_S_DISABLED => 8192i32,
            Self::eSSCR_S_DONE => 16384i32,
            Self::eSSCR_S_TERMINATED => 32768i32,
            Self::eSSCR_S_STARTED => 65536i32,
            Self::eSSCR_S_RESUMING => 131072i32,
            Self::eSSCR_S_UNPAUSE => 262144i32,
            Self::eSSCR_R_RESOURCE_UNAVAILABLE => 524288i32,
            Self::eSSCR_PAUSED_FROM_PLAYING => 1048576i32,
            Self::eSSCR_PAUSED_FROM_RESUMING => 2097152i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESituationStateChangeReason {
     const TYPE_ID: &str = "ESituationStateChangeReason";
}

impl StaticVariant for Vec<ESituationStateChangeReason> {
     const TYPE_ID: &str = "TArray<ESituationStateChangeReason>";
}

impl StaticVariant for Vec<Vec<ESituationStateChangeReason>> {
     const TYPE_ID: &str = "TArray<TArray<ESituationStateChangeReason>>";
}

impl Variant for ESituationStateChangeReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESituationStateChangeReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESituationStateChangeReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESituationStateChangeReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESituationStateChangeReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESituationStateChangeReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESituationType {
    AIST_Any,
    AIST_DetectedInPrivate,
    AIST_HandleDistraction,
    AIST_Spectator,
    AIST_InvestigateWeapon,
    AIST_GuardBody,
    AIST_Entourage,
    AIST_HandleTrespassing,
    AIST_DeadBody,
    AIST_InvestigateCautious,
    AIST_Sentry,
    AIST_HandleDisguise,
    AIST_SC_Curious,
    AIST_SC_Alerted,
    AIST_SC_Combat,
    AIST_SniperCombat,
    AIST_Arrest,
    AIST_StandOff,
    AIST_RecoverUnconscious,
    AIST_AvoidExplosion,
    AIST_Evacuate,
    AIST_ProtoCombat,
    AIST_DangerousArea,
    AIST_CloseCombat,
    AIST_Infected,
    ESituationType_Count,
}

impl Aligned for ESituationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESituationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AIST_Any => 0i32,
            Self::AIST_DetectedInPrivate => 1i32,
            Self::AIST_HandleDistraction => 2i32,
            Self::AIST_Spectator => 3i32,
            Self::AIST_InvestigateWeapon => 4i32,
            Self::AIST_GuardBody => 5i32,
            Self::AIST_Entourage => 6i32,
            Self::AIST_HandleTrespassing => 7i32,
            Self::AIST_DeadBody => 8i32,
            Self::AIST_InvestigateCautious => 9i32,
            Self::AIST_Sentry => 10i32,
            Self::AIST_HandleDisguise => 11i32,
            Self::AIST_SC_Curious => 12i32,
            Self::AIST_SC_Alerted => 13i32,
            Self::AIST_SC_Combat => 14i32,
            Self::AIST_SniperCombat => 15i32,
            Self::AIST_Arrest => 16i32,
            Self::AIST_StandOff => 17i32,
            Self::AIST_RecoverUnconscious => 18i32,
            Self::AIST_AvoidExplosion => 19i32,
            Self::AIST_Evacuate => 20i32,
            Self::AIST_ProtoCombat => 21i32,
            Self::AIST_DangerousArea => 22i32,
            Self::AIST_CloseCombat => 23i32,
            Self::AIST_Infected => 24i32,
            Self::ESituationType_Count => 25i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESituationType {
     const TYPE_ID: &str = "ESituationType";
}

impl StaticVariant for Vec<ESituationType> {
     const TYPE_ID: &str = "TArray<ESituationType>";
}

impl StaticVariant for Vec<Vec<ESituationType>> {
     const TYPE_ID: &str = "TArray<TArray<ESituationType>>";
}

impl Variant for ESituationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESituationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESituationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESituationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESituationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESituationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESmartBehaviorOrder {
    SBO_Stand,
    SBO_Move,
    SBO_React,
    SBO_Act,
    SBO_MoveToAct,
    SBO_MoveToCover,
    SBO_ShootFromCover,
    SBO_Death,
    SBO_Teleport,
}

impl Aligned for ESmartBehaviorOrder {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESmartBehaviorOrder {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SBO_Stand => 0i32,
            Self::SBO_Move => 1i32,
            Self::SBO_React => 2i32,
            Self::SBO_Act => 3i32,
            Self::SBO_MoveToAct => 4i32,
            Self::SBO_MoveToCover => 5i32,
            Self::SBO_ShootFromCover => 6i32,
            Self::SBO_Death => 7i32,
            Self::SBO_Teleport => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESmartBehaviorOrder {
     const TYPE_ID: &str = "ESmartBehaviorOrder";
}

impl StaticVariant for Vec<ESmartBehaviorOrder> {
     const TYPE_ID: &str = "TArray<ESmartBehaviorOrder>";
}

impl StaticVariant for Vec<Vec<ESmartBehaviorOrder>> {
     const TYPE_ID: &str = "TArray<TArray<ESmartBehaviorOrder>>";
}

impl Variant for ESmartBehaviorOrder {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESmartBehaviorOrder")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESmartBehaviorOrder".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESmartBehaviorOrder>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESmartBehaviorOrder>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESmartBehaviorOrder>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESmartWaitCondition {
    SWC_Time,
    SWC_Distance,
    SWC_Executing,
    SWC_Executed,
}

impl Aligned for ESmartWaitCondition {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESmartWaitCondition {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SWC_Time => 0i32,
            Self::SWC_Distance => 1i32,
            Self::SWC_Executing => 2i32,
            Self::SWC_Executed => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESmartWaitCondition {
     const TYPE_ID: &str = "ESmartWaitCondition";
}

impl StaticVariant for Vec<ESmartWaitCondition> {
     const TYPE_ID: &str = "TArray<ESmartWaitCondition>";
}

impl StaticVariant for Vec<Vec<ESmartWaitCondition>> {
     const TYPE_ID: &str = "TArray<TArray<ESmartWaitCondition>>";
}

impl Variant for ESmartWaitCondition {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESmartWaitCondition")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESmartWaitCondition".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESmartWaitCondition>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESmartWaitCondition>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESmartWaitCondition>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESmoothingMode {
    ESM_LINEAR,
    ESM_EXPONENTIAL,
    ESM_EASING_SINEOUT,
    ESM_EASING_SINEINOUT,
}

impl Aligned for ESmoothingMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESmoothingMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESM_LINEAR => 0i32,
            Self::ESM_EXPONENTIAL => 1i32,
            Self::ESM_EASING_SINEOUT => 2i32,
            Self::ESM_EASING_SINEINOUT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESmoothingMode {
     const TYPE_ID: &str = "ESmoothingMode";
}

impl StaticVariant for Vec<ESmoothingMode> {
     const TYPE_ID: &str = "TArray<ESmoothingMode>";
}

impl StaticVariant for Vec<Vec<ESmoothingMode>> {
     const TYPE_ID: &str = "TArray<TArray<ESmoothingMode>>";
}

impl Variant for ESmoothingMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESmoothingMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESmoothingMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESmoothingMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESmoothingMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESmoothingMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESniperScoreMessageType {
    ESSMT_STYLE_DEFAULT,
    ESSMT_STYLE_SCORE,
    ESSMT_STYLE_PENALTY,
    ESSMT_STYLE_STREAK,
    ESSMT_STYLE_CIVKILL,
}

impl Aligned for ESniperScoreMessageType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESniperScoreMessageType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESSMT_STYLE_DEFAULT => 0i32,
            Self::ESSMT_STYLE_SCORE => 1i32,
            Self::ESSMT_STYLE_PENALTY => 2i32,
            Self::ESSMT_STYLE_STREAK => 3i32,
            Self::ESSMT_STYLE_CIVKILL => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESniperScoreMessageType {
     const TYPE_ID: &str = "ESniperScoreMessageType";
}

impl StaticVariant for Vec<ESniperScoreMessageType> {
     const TYPE_ID: &str = "TArray<ESniperScoreMessageType>";
}

impl StaticVariant for Vec<Vec<ESniperScoreMessageType>> {
     const TYPE_ID: &str = "TArray<TArray<ESniperScoreMessageType>>";
}

impl Variant for ESniperScoreMessageType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESniperScoreMessageType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESniperScoreMessageType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESniperScoreMessageType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESniperScoreMessageType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESniperScoreMessageType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundChannelGroup {
    ESCG_NONE,
    SND_Default,
    SND_Phys_Rigidbody,
    SND_Phys_Shatter,
    SND_Wpn_HM,
    SND_Wpn_HM_Shot,
    SND_Wpn_NPC,
    SND_Wpn_Impacts,
    SND_Wpn_Flybys,
    SND_Characters,
    SND_Ambience,
    SND_Props,
    SND_Prop_Item,
    SND_FS_HM,
    SND_FS_NPC,
    SND_VisualFX,
    SND_VisualFX_ShotActivate,
    SND_VisualFX_Explosions,
    SND_Diag_HM,
    SND_Diag_NPC,
    SND_CS_Ingame,
    SND_CS_PreRend,
    SND_Music_Env,
    SND_MusicNonEnv,
    SND_SpecialFX_CC,
    SND_SpecialFX_Jumps,
    SND_SpecialFX_Closet,
    SND_SpecialFX_Vent,
    SND_SpecialFX_Instinct,
    SND_SpecialFX_Disguise,
    SND_SpecialFX_Agility,
    SND_Stingers_SFX,
    SND_GUI,
    SND_Test,
    ANIM_HM_Generic,
    ANIM_HM_Loco,
    ANIM_HM_Agility,
    ANIM_HM_Suit_Flap,
    ANIM_HM_Suit_Release,
    ANIM_HM_Suit_Slide,
    ANIM_HM_Suit_LandImpact,
    ANIM_HM_Suit_Grab,
    ANIM_HM_Suit_Roll,
    ANIM_HM_Suit_Swoosh_Body,
    ANIM_HM_Suit_Swoosh_Fast,
    ANIM_HM_CC_Impacts,
    ANIM_HM_CC_Movement,
    ANIM_NPC_Generic,
    ANIM_NPC_Loco,
    ANIM_NPC_CC_Impacts,
    ANIM_NPC_CC_Movement,
    SND_Wpn_HM_Tail,
    SND_Wpn_NPC_Tail,
    SND_Diag_NPC_Crowd,
    SND_Phys_RigidBody_Ragdoll,
    SND_Diag_VO,
    SND_GUI_Menu,
    SND_Props_Doors,
    SND_Wpn_HM_Handguns,
    SND_Wpn_HM_Revolvers,
    SND_Wpn_HM_Rifles,
    SND_Wpn_HM_Shotguns,
    SND_Wpn_HM_Smgs,
    SND_Wpn_HM_Snipers,
    SND_Wpn_HM_Other,
    SND_Wpn_NPC_Handguns,
    SND_Wpn_NPC_Revolvers,
    SND_Wpn_NPC_Rifles,
    SND_Wpn_NPC_Shotguns,
    SND_Wpn_NPC_Smgs,
    SND_Wpn_NPC_Snipers,
    SND_Wpn_NPC_Other,
    SND_Diag_NPC_Oneliner,
    SND_Moments,
}

impl Aligned for ESoundChannelGroup {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundChannelGroup {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESCG_NONE => 0i32,
            Self::SND_Default => 1i32,
            Self::SND_Phys_Rigidbody => 2i32,
            Self::SND_Phys_Shatter => 3i32,
            Self::SND_Wpn_HM => 4i32,
            Self::SND_Wpn_HM_Shot => 5i32,
            Self::SND_Wpn_NPC => 6i32,
            Self::SND_Wpn_Impacts => 7i32,
            Self::SND_Wpn_Flybys => 8i32,
            Self::SND_Characters => 9i32,
            Self::SND_Ambience => 10i32,
            Self::SND_Props => 11i32,
            Self::SND_Prop_Item => 12i32,
            Self::SND_FS_HM => 13i32,
            Self::SND_FS_NPC => 14i32,
            Self::SND_VisualFX => 15i32,
            Self::SND_VisualFX_ShotActivate => 16i32,
            Self::SND_VisualFX_Explosions => 17i32,
            Self::SND_Diag_HM => 18i32,
            Self::SND_Diag_NPC => 19i32,
            Self::SND_CS_Ingame => 20i32,
            Self::SND_CS_PreRend => 21i32,
            Self::SND_Music_Env => 22i32,
            Self::SND_MusicNonEnv => 23i32,
            Self::SND_SpecialFX_CC => 24i32,
            Self::SND_SpecialFX_Jumps => 25i32,
            Self::SND_SpecialFX_Closet => 26i32,
            Self::SND_SpecialFX_Vent => 27i32,
            Self::SND_SpecialFX_Instinct => 28i32,
            Self::SND_SpecialFX_Disguise => 29i32,
            Self::SND_SpecialFX_Agility => 30i32,
            Self::SND_Stingers_SFX => 31i32,
            Self::SND_GUI => 32i32,
            Self::SND_Test => 33i32,
            Self::ANIM_HM_Generic => 34i32,
            Self::ANIM_HM_Loco => 35i32,
            Self::ANIM_HM_Agility => 36i32,
            Self::ANIM_HM_Suit_Flap => 37i32,
            Self::ANIM_HM_Suit_Release => 38i32,
            Self::ANIM_HM_Suit_Slide => 39i32,
            Self::ANIM_HM_Suit_LandImpact => 40i32,
            Self::ANIM_HM_Suit_Grab => 41i32,
            Self::ANIM_HM_Suit_Roll => 42i32,
            Self::ANIM_HM_Suit_Swoosh_Body => 43i32,
            Self::ANIM_HM_Suit_Swoosh_Fast => 44i32,
            Self::ANIM_HM_CC_Impacts => 45i32,
            Self::ANIM_HM_CC_Movement => 46i32,
            Self::ANIM_NPC_Generic => 47i32,
            Self::ANIM_NPC_Loco => 48i32,
            Self::ANIM_NPC_CC_Impacts => 49i32,
            Self::ANIM_NPC_CC_Movement => 50i32,
            Self::SND_Wpn_HM_Tail => 51i32,
            Self::SND_Wpn_NPC_Tail => 52i32,
            Self::SND_Diag_NPC_Crowd => 53i32,
            Self::SND_Phys_RigidBody_Ragdoll => 54i32,
            Self::SND_Diag_VO => 55i32,
            Self::SND_GUI_Menu => 56i32,
            Self::SND_Props_Doors => 57i32,
            Self::SND_Wpn_HM_Handguns => 58i32,
            Self::SND_Wpn_HM_Revolvers => 59i32,
            Self::SND_Wpn_HM_Rifles => 60i32,
            Self::SND_Wpn_HM_Shotguns => 61i32,
            Self::SND_Wpn_HM_Smgs => 62i32,
            Self::SND_Wpn_HM_Snipers => 63i32,
            Self::SND_Wpn_HM_Other => 64i32,
            Self::SND_Wpn_NPC_Handguns => 65i32,
            Self::SND_Wpn_NPC_Revolvers => 66i32,
            Self::SND_Wpn_NPC_Rifles => 67i32,
            Self::SND_Wpn_NPC_Shotguns => 68i32,
            Self::SND_Wpn_NPC_Smgs => 69i32,
            Self::SND_Wpn_NPC_Snipers => 70i32,
            Self::SND_Wpn_NPC_Other => 71i32,
            Self::SND_Diag_NPC_Oneliner => 72i32,
            Self::SND_Moments => 73i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundChannelGroup {
     const TYPE_ID: &str = "ESoundChannelGroup";
}

impl StaticVariant for Vec<ESoundChannelGroup> {
     const TYPE_ID: &str = "TArray<ESoundChannelGroup>";
}

impl StaticVariant for Vec<Vec<ESoundChannelGroup>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundChannelGroup>>";
}

impl Variant for ESoundChannelGroup {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundChannelGroup")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundChannelGroup".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundChannelGroup>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundChannelGroup>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundChannelGroup>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundCollisionFlags {
    ESoundCollisionFlags_None,
    ESoundCollisionFlags_RagdollInvolved,
    ESoundCollisionFlags_HandInvolved,
}

impl Aligned for ESoundCollisionFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundCollisionFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESoundCollisionFlags_None => 0i32,
            Self::ESoundCollisionFlags_RagdollInvolved => 1i32,
            Self::ESoundCollisionFlags_HandInvolved => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundCollisionFlags {
     const TYPE_ID: &str = "ESoundCollisionFlags";
}

impl StaticVariant for Vec<ESoundCollisionFlags> {
     const TYPE_ID: &str = "TArray<ESoundCollisionFlags>";
}

impl StaticVariant for Vec<Vec<ESoundCollisionFlags>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundCollisionFlags>>";
}

impl Variant for ESoundCollisionFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundCollisionFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundCollisionFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundCollisionFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundCollisionFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundCollisionFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundCollisionObjectType {
    StaticRigidBody,
    DynamicRigidBody,
    Ragdoll,
    HeroHand,
}

impl Aligned for ESoundCollisionObjectType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundCollisionObjectType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::StaticRigidBody => 0i32,
            Self::DynamicRigidBody => 1i32,
            Self::Ragdoll => 2i32,
            Self::HeroHand => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundCollisionObjectType {
     const TYPE_ID: &str = "ESoundCollisionObjectType";
}

impl StaticVariant for Vec<ESoundCollisionObjectType> {
     const TYPE_ID: &str = "TArray<ESoundCollisionObjectType>";
}

impl StaticVariant for Vec<Vec<ESoundCollisionObjectType>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundCollisionObjectType>>";
}

impl Variant for ESoundCollisionObjectType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundCollisionObjectType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundCollisionObjectType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundCollisionObjectType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundCollisionObjectType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundCollisionObjectType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundCollisionType {
    Impact,
    Rolling,
    Sliding,
}

impl Aligned for ESoundCollisionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundCollisionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Impact => 0i32,
            Self::Rolling => 1i32,
            Self::Sliding => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundCollisionType {
     const TYPE_ID: &str = "ESoundCollisionType";
}

impl StaticVariant for Vec<ESoundCollisionType> {
     const TYPE_ID: &str = "TArray<ESoundCollisionType>";
}

impl StaticVariant for Vec<Vec<ESoundCollisionType>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundCollisionType>>";
}

impl Variant for ESoundCollisionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundCollisionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundCollisionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundCollisionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundCollisionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundCollisionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundGateFlags {
    SOUNDGATE_FLAGS_AMBIENCE,
    SOUNDGATE_FLAGS_OCCLUSION,
    SOUNDGATE_FLAGS_ALL,
}

impl Aligned for ESoundGateFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundGateFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SOUNDGATE_FLAGS_AMBIENCE => 1i32,
            Self::SOUNDGATE_FLAGS_OCCLUSION => 2i32,
            Self::SOUNDGATE_FLAGS_ALL => 255i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundGateFlags {
     const TYPE_ID: &str = "ESoundGateFlags";
}

impl StaticVariant for Vec<ESoundGateFlags> {
     const TYPE_ID: &str = "TArray<ESoundGateFlags>";
}

impl StaticVariant for Vec<Vec<ESoundGateFlags>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundGateFlags>>";
}

impl Variant for ESoundGateFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundGateFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundGateFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundGateFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundGateFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundGateFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundGateType {
    SOUNDGATE_TYPE_ROUND,
    SOUNDGATE_TYPE_SHARPCORNERS,
}

impl Aligned for ESoundGateType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundGateType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SOUNDGATE_TYPE_ROUND => 0i32,
            Self::SOUNDGATE_TYPE_SHARPCORNERS => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundGateType {
     const TYPE_ID: &str = "ESoundGateType";
}

impl StaticVariant for Vec<ESoundGateType> {
     const TYPE_ID: &str = "TArray<ESoundGateType>";
}

impl StaticVariant for Vec<Vec<ESoundGateType>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundGateType>>";
}

impl Variant for ESoundGateType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundGateType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundGateType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundGateType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundGateType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundGateType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESoundMaterialType {
    eGeneric,
    eFlesh,
    eSilent,
}

impl Aligned for ESoundMaterialType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESoundMaterialType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGeneric => 0i32,
            Self::eFlesh => 1i32,
            Self::eSilent => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESoundMaterialType {
     const TYPE_ID: &str = "ESoundMaterialType";
}

impl StaticVariant for Vec<ESoundMaterialType> {
     const TYPE_ID: &str = "TArray<ESoundMaterialType>";
}

impl StaticVariant for Vec<Vec<ESoundMaterialType>> {
     const TYPE_ID: &str = "TArray<TArray<ESoundMaterialType>>";
}

impl Variant for ESoundMaterialType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESoundMaterialType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESoundMaterialType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESoundMaterialType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESoundMaterialType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESoundMaterialType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESpeechPriority {
    SP_AMBIENT,
    SP_ALERTED,
    SP_PAIN,
    SP_ALERTED_IMPORTANT,
    SP_COMBAT,
    SP_COMBAT_IMPORTANT,
    SP_DEATH,
    SP_MAX,
    SP_COUNT__,
}

impl Aligned for ESpeechPriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESpeechPriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SP_AMBIENT => 0i32,
            Self::SP_ALERTED => 1i32,
            Self::SP_PAIN => 2i32,
            Self::SP_ALERTED_IMPORTANT => 3i32,
            Self::SP_COMBAT => 4i32,
            Self::SP_COMBAT_IMPORTANT => 5i32,
            Self::SP_DEATH => 6i32,
            Self::SP_MAX => 7i32,
            Self::SP_COUNT__ => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESpeechPriority {
     const TYPE_ID: &str = "ESpeechPriority";
}

impl StaticVariant for Vec<ESpeechPriority> {
     const TYPE_ID: &str = "TArray<ESpeechPriority>";
}

impl StaticVariant for Vec<Vec<ESpeechPriority>> {
     const TYPE_ID: &str = "TArray<TArray<ESpeechPriority>>";
}

impl Variant for ESpeechPriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESpeechPriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESpeechPriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESpeechPriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESpeechPriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESpeechPriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESpeed {
    eSpeed_Idle,
    eSpeed_Slow,
    eSpeed_Normal,
    eSpeed_Fast,
    eSpeed_Sprint,
}

impl Aligned for ESpeed {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESpeed {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSpeed_Idle => 0i32,
            Self::eSpeed_Slow => 1i32,
            Self::eSpeed_Normal => 2i32,
            Self::eSpeed_Fast => 3i32,
            Self::eSpeed_Sprint => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESpeed {
     const TYPE_ID: &str = "ESpeed";
}

impl StaticVariant for Vec<ESpeed> {
     const TYPE_ID: &str = "TArray<ESpeed>";
}

impl StaticVariant for Vec<Vec<ESpeed>> {
     const TYPE_ID: &str = "TArray<TArray<ESpeed>>";
}

impl Variant for ESpeed {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESpeed")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESpeed".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESpeed>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESpeed>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESpeed>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EStandRepositionStrategy {
    SRS_InPlaceRepositioning,
    SRS_NoRepositioning,
}

impl Aligned for EStandRepositionStrategy {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EStandRepositionStrategy {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SRS_InPlaceRepositioning => 0i32,
            Self::SRS_NoRepositioning => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EStandRepositionStrategy {
     const TYPE_ID: &str = "EStandRepositionStrategy";
}

impl StaticVariant for Vec<EStandRepositionStrategy> {
     const TYPE_ID: &str = "TArray<EStandRepositionStrategy>";
}

impl StaticVariant for Vec<Vec<EStandRepositionStrategy>> {
     const TYPE_ID: &str = "TArray<TArray<EStandRepositionStrategy>>";
}

impl Variant for EStandRepositionStrategy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EStandRepositionStrategy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EStandRepositionStrategy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EStandRepositionStrategy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EStandRepositionStrategy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EStandRepositionStrategy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EStashpointContainedEntityType {
    PICKUP_NONE,
    PICKUP_ITEMS,
    PICKUP_OUTFIT,
    PICKUP_PICKEDUP,
}

impl Aligned for EStashpointContainedEntityType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EStashpointContainedEntityType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PICKUP_NONE => 0i32,
            Self::PICKUP_ITEMS => 1i32,
            Self::PICKUP_OUTFIT => 2i32,
            Self::PICKUP_PICKEDUP => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EStashpointContainedEntityType {
     const TYPE_ID: &str = "EStashpointContainedEntityType";
}

impl StaticVariant for Vec<EStashpointContainedEntityType> {
     const TYPE_ID: &str = "TArray<EStashpointContainedEntityType>";
}

impl StaticVariant for Vec<Vec<EStashpointContainedEntityType>> {
     const TYPE_ID: &str = "TArray<TArray<EStashpointContainedEntityType>>";
}

impl Variant for EStashpointContainedEntityType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EStashpointContainedEntityType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EStashpointContainedEntityType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EStashpointContainedEntityType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EStashpointContainedEntityType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EStashpointContainedEntityType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EStealthSituation {
    SS_DISGUISE_TAKEN,
    SS_DISGUISE_TRESPASSING,
    SS_DISGUISE_ILLEGAL_ACTION,
    SS_DISGUISE_REMOVED,
    SS_DISGUISE_INVESTIGATED,
    SS_DISGUISE_BLOWN,
    SS_HIDE_IN_CLOSET_FIRSTTIME,
    SS_HIDE_IN_CLOSET,
    SS_DOOR_START_LOCKPICKING,
    SS_DOOR_CANCEL_LOCKPICKING,
    SS_LANDMINE_ARMED,
    SS_RADIO_ON,
    SS_VENT_ENTER,
    SS_VENT_EXIT,
    SS_BLEND_IN_ACTIVATED,
    SS_BODY_DISCOVERED,
    SS_INVESTIGATE_GUNSHOT,
    SS_INVESTIGATE_NOISE,
    SS_INVESTIGATE_EXPLOSION,
    SS_FUSEBOX_DISABLE_UNIQUE,
    SS_FUSEBOX_DISABLE,
    SS_INVESTIGATING_FUSEBOX,
    SS_FUSEBOX_FIXED,
    SS_KEYCARD_PICKUP,
    SS_KEYCARD_USE,
    SS_BODY_PUT_IN_CONTAINER,
    SS_BODY_DRAGGING_SEEN,
    SS_BODY_OVER_RAIL,
    SS_BODY_OVER_LEDGE,
    SS_USE_HEALTH_STATION,
    SS_HITMAN_SPOTTED,
    SS_HITMAN_HIDDEN,
    SS_HITMAN_ENTERED_COMBAT,
    SS_TRESPASSING,
    SS_SECURITYTAPE_PICKUP,
    SS_NEWOBJECTIVE,
    SS_FOCUSADDED,
    SS_FOCUSFULL,
    SS_FOCUSEMPTY,
    SS_STARTED_SPRINTING,
    SS_STARTED_SNEAKING,
    SS_TOOK_COVER,
    SS_INVESTIGATE_CURIOUS,
    SS_GENERIC_PICKUP,
    SS_ATTENTION_ON,
    SS_ATTENTION_OFF,
    SS_DEADBODY_SEEN,
    SS_TARGET_EVACUATES,
    SS_UNKNOWN_BODY_SPOTTED,
}

impl Aligned for EStealthSituation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EStealthSituation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SS_DISGUISE_TAKEN => 0i32,
            Self::SS_DISGUISE_TRESPASSING => 1i32,
            Self::SS_DISGUISE_ILLEGAL_ACTION => 2i32,
            Self::SS_DISGUISE_REMOVED => 3i32,
            Self::SS_DISGUISE_INVESTIGATED => 4i32,
            Self::SS_DISGUISE_BLOWN => 5i32,
            Self::SS_HIDE_IN_CLOSET_FIRSTTIME => 6i32,
            Self::SS_HIDE_IN_CLOSET => 7i32,
            Self::SS_DOOR_START_LOCKPICKING => 8i32,
            Self::SS_DOOR_CANCEL_LOCKPICKING => 9i32,
            Self::SS_LANDMINE_ARMED => 10i32,
            Self::SS_RADIO_ON => 11i32,
            Self::SS_VENT_ENTER => 12i32,
            Self::SS_VENT_EXIT => 13i32,
            Self::SS_BLEND_IN_ACTIVATED => 14i32,
            Self::SS_BODY_DISCOVERED => 15i32,
            Self::SS_INVESTIGATE_GUNSHOT => 16i32,
            Self::SS_INVESTIGATE_NOISE => 17i32,
            Self::SS_INVESTIGATE_EXPLOSION => 18i32,
            Self::SS_FUSEBOX_DISABLE_UNIQUE => 19i32,
            Self::SS_FUSEBOX_DISABLE => 20i32,
            Self::SS_INVESTIGATING_FUSEBOX => 21i32,
            Self::SS_FUSEBOX_FIXED => 22i32,
            Self::SS_KEYCARD_PICKUP => 23i32,
            Self::SS_KEYCARD_USE => 24i32,
            Self::SS_BODY_PUT_IN_CONTAINER => 25i32,
            Self::SS_BODY_DRAGGING_SEEN => 26i32,
            Self::SS_BODY_OVER_RAIL => 27i32,
            Self::SS_BODY_OVER_LEDGE => 28i32,
            Self::SS_USE_HEALTH_STATION => 29i32,
            Self::SS_HITMAN_SPOTTED => 30i32,
            Self::SS_HITMAN_HIDDEN => 31i32,
            Self::SS_HITMAN_ENTERED_COMBAT => 32i32,
            Self::SS_TRESPASSING => 33i32,
            Self::SS_SECURITYTAPE_PICKUP => 34i32,
            Self::SS_NEWOBJECTIVE => 35i32,
            Self::SS_FOCUSADDED => 36i32,
            Self::SS_FOCUSFULL => 37i32,
            Self::SS_FOCUSEMPTY => 38i32,
            Self::SS_STARTED_SPRINTING => 39i32,
            Self::SS_STARTED_SNEAKING => 40i32,
            Self::SS_TOOK_COVER => 41i32,
            Self::SS_INVESTIGATE_CURIOUS => 42i32,
            Self::SS_GENERIC_PICKUP => 43i32,
            Self::SS_ATTENTION_ON => 44i32,
            Self::SS_ATTENTION_OFF => 45i32,
            Self::SS_DEADBODY_SEEN => 46i32,
            Self::SS_TARGET_EVACUATES => 47i32,
            Self::SS_UNKNOWN_BODY_SPOTTED => 48i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EStealthSituation {
     const TYPE_ID: &str = "EStealthSituation";
}

impl StaticVariant for Vec<EStealthSituation> {
     const TYPE_ID: &str = "TArray<EStealthSituation>";
}

impl StaticVariant for Vec<Vec<EStealthSituation>> {
     const TYPE_ID: &str = "TArray<TArray<EStealthSituation>>";
}

impl Variant for EStealthSituation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EStealthSituation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EStealthSituation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EStealthSituation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EStealthSituation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EStealthSituation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESubcontrollerInventorySlot {
    eSIS_Invalid,
    eSIS_LeftHand,
    eSIS_RightHand,
}

impl Aligned for ESubcontrollerInventorySlot {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESubcontrollerInventorySlot {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSIS_Invalid => 0i32,
            Self::eSIS_LeftHand => 1i32,
            Self::eSIS_RightHand => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESubcontrollerInventorySlot {
     const TYPE_ID: &str = "ESubcontrollerInventorySlot";
}

impl StaticVariant for Vec<ESubcontrollerInventorySlot> {
     const TYPE_ID: &str = "TArray<ESubcontrollerInventorySlot>";
}

impl StaticVariant for Vec<Vec<ESubcontrollerInventorySlot>> {
     const TYPE_ID: &str = "TArray<TArray<ESubcontrollerInventorySlot>>";
}

impl Variant for ESubcontrollerInventorySlot {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESubcontrollerInventorySlot")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESubcontrollerInventorySlot".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESubcontrollerInventorySlot>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESubcontrollerInventorySlot>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESubcontrollerInventorySlot>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ESubtitleSpeakerIndicatorType {
    DEFAULT,
    NO_INDICATOR,
    INWORLD_BUBBLE,
    INWORLD_JAGGED,
    TEXTONLY_HEADSET,
    TEXTONLY_SOUNDSYSTEM,
    TEXTONLY_TELEPHONE,
    TEXTONLY_TELEPHONE2,
    TEXTONLY_WALKIETALKIE,
    TEXTONLY_DIRECTOR,
    TEXTONLY_EYE,
}

impl Aligned for ESubtitleSpeakerIndicatorType {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ESubtitleSpeakerIndicatorType {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DEFAULT => 0i8,
            Self::NO_INDICATOR => 1i8,
            Self::INWORLD_BUBBLE => 2i8,
            Self::INWORLD_JAGGED => 3i8,
            Self::TEXTONLY_HEADSET => 4i8,
            Self::TEXTONLY_SOUNDSYSTEM => 5i8,
            Self::TEXTONLY_TELEPHONE => 6i8,
            Self::TEXTONLY_TELEPHONE2 => 7i8,
            Self::TEXTONLY_WALKIETALKIE => 8i8,
            Self::TEXTONLY_DIRECTOR => 9i8,
            Self::TEXTONLY_EYE => 10i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESubtitleSpeakerIndicatorType {
     const TYPE_ID: &str = "ESubtitleSpeakerIndicatorType";
}

impl StaticVariant for Vec<ESubtitleSpeakerIndicatorType> {
     const TYPE_ID: &str = "TArray<ESubtitleSpeakerIndicatorType>";
}

impl StaticVariant for Vec<Vec<ESubtitleSpeakerIndicatorType>> {
     const TYPE_ID: &str = "TArray<TArray<ESubtitleSpeakerIndicatorType>>";
}

impl Variant for ESubtitleSpeakerIndicatorType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESubtitleSpeakerIndicatorType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESubtitleSpeakerIndicatorType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESubtitleSpeakerIndicatorType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESubtitleSpeakerIndicatorType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESubtitleSpeakerIndicatorType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESyncEvent {
    eSyncEvent_None,
    eSyncEvent_LeftFoot,
    eSyncEvent_RightFoot,
    eSyncEvent_BothFeet,
}

impl Aligned for ESyncEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESyncEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSyncEvent_None => 0i32,
            Self::eSyncEvent_LeftFoot => 100i32,
            Self::eSyncEvent_RightFoot => 200i32,
            Self::eSyncEvent_BothFeet => 300i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESyncEvent {
     const TYPE_ID: &str = "ESyncEvent";
}

impl StaticVariant for Vec<ESyncEvent> {
     const TYPE_ID: &str = "TArray<ESyncEvent>";
}

impl StaticVariant for Vec<Vec<ESyncEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ESyncEvent>>";
}

impl Variant for ESyncEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESyncEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESyncEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESyncEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESyncEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESyncEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ESynchronisedActionState {
    eSAS_INACTIVE,
    eSAS_WAITING_TO_EXECUTE,
    eSAS_COOLINGDOWN,
}

impl Aligned for ESynchronisedActionState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ESynchronisedActionState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSAS_INACTIVE => 0i32,
            Self::eSAS_WAITING_TO_EXECUTE => 1i32,
            Self::eSAS_COOLINGDOWN => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ESynchronisedActionState {
     const TYPE_ID: &str = "ESynchronisedActionState";
}

impl StaticVariant for Vec<ESynchronisedActionState> {
     const TYPE_ID: &str = "TArray<ESynchronisedActionState>";
}

impl StaticVariant for Vec<Vec<ESynchronisedActionState>> {
     const TYPE_ID: &str = "TArray<TArray<ESynchronisedActionState>>";
}

impl Variant for ESynchronisedActionState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ESynchronisedActionState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ESynchronisedActionState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ESynchronisedActionState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ESynchronisedActionState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ESynchronisedActionState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETakeDownAnim {
    eCoverLowOverNarrowCloseFront,
    eCoverLowOverNarrowCloseBack,
    eCoverLowOverNarrowFarFront,
    eCoverLowOverNarrowFarBack,
    eCoverLowOverWideFront,
    eCoverLowOverWideBack,
    eCoverLowCornerFront,
    eCoverLowCornerBack,
    eCoverHighCornerFront,
    eCoverHighCornerBack,
    eLocomotionBack,
    eLocomotionFallback,
    eLocomotionChair,
    eChokeGroundLoop,
    eChokeGroundEndPacify,
    eChokeGroundEndKill,
    eChokeGroundFallBackLoop,
    eChokeGroundFallBackEndPacify,
    eChokeGroundFallBackEndKill,
    eChokeChairLoop,
    eChokeChairEndPacify,
    eChokeChairEndKill,
    eChokeChairEndLeft90,
    eChokeChairEndLeft45,
    eChokeChairEndFront,
    eChokeChairEndRight45,
    eChokeChairEndRight90,
    eTakeDownAnimLast,
}

impl Aligned for ETakeDownAnim {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETakeDownAnim {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCoverLowOverNarrowCloseFront => 0i32,
            Self::eCoverLowOverNarrowCloseBack => 1i32,
            Self::eCoverLowOverNarrowFarFront => 2i32,
            Self::eCoverLowOverNarrowFarBack => 3i32,
            Self::eCoverLowOverWideFront => 4i32,
            Self::eCoverLowOverWideBack => 5i32,
            Self::eCoverLowCornerFront => 6i32,
            Self::eCoverLowCornerBack => 7i32,
            Self::eCoverHighCornerFront => 8i32,
            Self::eCoverHighCornerBack => 9i32,
            Self::eLocomotionBack => 10i32,
            Self::eLocomotionFallback => 11i32,
            Self::eLocomotionChair => 12i32,
            Self::eChokeGroundLoop => 13i32,
            Self::eChokeGroundEndPacify => 14i32,
            Self::eChokeGroundEndKill => 15i32,
            Self::eChokeGroundFallBackLoop => 16i32,
            Self::eChokeGroundFallBackEndPacify => 17i32,
            Self::eChokeGroundFallBackEndKill => 18i32,
            Self::eChokeChairLoop => 19i32,
            Self::eChokeChairEndPacify => 20i32,
            Self::eChokeChairEndKill => 21i32,
            Self::eChokeChairEndLeft90 => 22i32,
            Self::eChokeChairEndLeft45 => 23i32,
            Self::eChokeChairEndFront => 24i32,
            Self::eChokeChairEndRight45 => 25i32,
            Self::eChokeChairEndRight90 => 26i32,
            Self::eTakeDownAnimLast => 27i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETakeDownAnim {
     const TYPE_ID: &str = "ETakeDownAnim";
}

impl StaticVariant for Vec<ETakeDownAnim> {
     const TYPE_ID: &str = "TArray<ETakeDownAnim>";
}

impl StaticVariant for Vec<Vec<ETakeDownAnim>> {
     const TYPE_ID: &str = "TArray<TArray<ETakeDownAnim>>";
}

impl Variant for ETakeDownAnim {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETakeDownAnim")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETakeDownAnim".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETakeDownAnim>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETakeDownAnim>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETakeDownAnim>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETakeDownState {
    eTD_Cover,
    eTD_Locomotion,
    eTD_ChokeLoop,
    eTD_ChokeFinish,
    eTD_Deactivating,
    eTD_Unknown,
}

impl Aligned for ETakeDownState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETakeDownState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTD_Cover => 0i32,
            Self::eTD_Locomotion => 1i32,
            Self::eTD_ChokeLoop => 2i32,
            Self::eTD_ChokeFinish => 3i32,
            Self::eTD_Deactivating => 4i32,
            Self::eTD_Unknown => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETakeDownState {
     const TYPE_ID: &str = "ETakeDownState";
}

impl StaticVariant for Vec<ETakeDownState> {
     const TYPE_ID: &str = "TArray<ETakeDownState>";
}

impl StaticVariant for Vec<Vec<ETakeDownState>> {
     const TYPE_ID: &str = "TArray<TArray<ETakeDownState>>";
}

impl Variant for ETakeDownState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETakeDownState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETakeDownState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETakeDownState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETakeDownState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETakeDownState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETargetPrintDestination {
    eTPD_Screen,
    eTPD_TraceViewer,
}

impl Aligned for ETargetPrintDestination {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETargetPrintDestination {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTPD_Screen => 0i32,
            Self::eTPD_TraceViewer => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETargetPrintDestination {
     const TYPE_ID: &str = "ETargetPrintDestination";
}

impl StaticVariant for Vec<ETargetPrintDestination> {
     const TYPE_ID: &str = "TArray<ETargetPrintDestination>";
}

impl StaticVariant for Vec<Vec<ETargetPrintDestination>> {
     const TYPE_ID: &str = "TArray<TArray<ETargetPrintDestination>>";
}

impl Variant for ETargetPrintDestination {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETargetPrintDestination")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETargetPrintDestination".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETargetPrintDestination>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETargetPrintDestination>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETargetPrintDestination>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETargetType {
    eTDS_None,
    eTDS_LookAtTarget,
    eTDS_Spatial,
    eTDS_Linked,
}

impl Aligned for ETargetType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETargetType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTDS_None => 0i32,
            Self::eTDS_LookAtTarget => 1i32,
            Self::eTDS_Spatial => 2i32,
            Self::eTDS_Linked => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETargetType {
     const TYPE_ID: &str = "ETargetType";
}

impl StaticVariant for Vec<ETargetType> {
     const TYPE_ID: &str = "TArray<ETargetType>";
}

impl StaticVariant for Vec<Vec<ETargetType>> {
     const TYPE_ID: &str = "TArray<TArray<ETargetType>>";
}

impl Variant for ETargetType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETargetType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETargetType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETargetType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETargetType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETargetType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETeamModeId {
    TeamMode_Coop,
    TeamMode_Versus,
}

impl Aligned for ETeamModeId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETeamModeId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TeamMode_Coop => 0i32,
            Self::TeamMode_Versus => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETeamModeId {
     const TYPE_ID: &str = "ETeamModeId";
}

impl StaticVariant for Vec<ETeamModeId> {
     const TYPE_ID: &str = "TArray<ETeamModeId>";
}

impl StaticVariant for Vec<Vec<ETeamModeId>> {
     const TYPE_ID: &str = "TArray<TArray<ETeamModeId>>";
}

impl Variant for ETeamModeId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETeamModeId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETeamModeId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETeamModeId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETeamModeId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETeamModeId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ETessellationFactorMode {
    TESSELLATIONFACTORMODE_FIXED,
    TESSELLATIONFACTORMODE_OBJECT,
    TESSELLATIONFACTORMODE_TRIANGLE,
}

impl Aligned for ETessellationFactorMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ETessellationFactorMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TESSELLATIONFACTORMODE_FIXED => 0i8,
            Self::TESSELLATIONFACTORMODE_OBJECT => 1i8,
            Self::TESSELLATIONFACTORMODE_TRIANGLE => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETessellationFactorMode {
     const TYPE_ID: &str = "ETessellationFactorMode";
}

impl StaticVariant for Vec<ETessellationFactorMode> {
     const TYPE_ID: &str = "TArray<ETessellationFactorMode>";
}

impl StaticVariant for Vec<Vec<ETessellationFactorMode>> {
     const TYPE_ID: &str = "TArray<TArray<ETessellationFactorMode>>";
}

impl Variant for ETessellationFactorMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETessellationFactorMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETessellationFactorMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETessellationFactorMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETessellationFactorMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETessellationFactorMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ETessellationMode {
    TESSELLATIONMODE_FLAT,
    TESSELLATIONMODE_PHONG,
}

impl Aligned for ETessellationMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ETessellationMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TESSELLATIONMODE_FLAT => 0i8,
            Self::TESSELLATIONMODE_PHONG => 1i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETessellationMode {
     const TYPE_ID: &str = "ETessellationMode";
}

impl StaticVariant for Vec<ETessellationMode> {
     const TYPE_ID: &str = "TArray<ETessellationMode>";
}

impl StaticVariant for Vec<Vec<ETessellationMode>> {
     const TYPE_ID: &str = "TArray<TArray<ETessellationMode>>";
}

impl Variant for ETessellationMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETessellationMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETessellationMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETessellationMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETessellationMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETessellationMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETextAlignment {
    TEXT_ALIGN_LEFT,
    TEXT_ALIGN_CENTER,
    TEXT_ALIGN_RIGHT,
}

impl Aligned for ETextAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETextAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TEXT_ALIGN_LEFT => 0i32,
            Self::TEXT_ALIGN_CENTER => 1i32,
            Self::TEXT_ALIGN_RIGHT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETextAlignment {
     const TYPE_ID: &str = "ETextAlignment";
}

impl StaticVariant for Vec<ETextAlignment> {
     const TYPE_ID: &str = "TArray<ETextAlignment>";
}

impl StaticVariant for Vec<Vec<ETextAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ETextAlignment>>";
}

impl Variant for ETextAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETextAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETextAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETextAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETextAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETextAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EThrowType {
    THROW_NONE,
    THROW_COIN,
    THROW_NORMAL,
    THROW_HEAVY,
    THROW_KNOCKDOWN_LIGHT,
    THROW_KNOCKDOWN_HEAVY,
    THROW_PACIFY_LIGHT,
    THROW_PACIFY_HEAVY,
    THROW_DEADLY_LIGHT,
    THROW_DEADLY_HEAVY,
}

impl Aligned for EThrowType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EThrowType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::THROW_NONE => 0i32,
            Self::THROW_COIN => 1i32,
            Self::THROW_NORMAL => 2i32,
            Self::THROW_HEAVY => 3i32,
            Self::THROW_KNOCKDOWN_LIGHT => 4i32,
            Self::THROW_KNOCKDOWN_HEAVY => 5i32,
            Self::THROW_PACIFY_LIGHT => 6i32,
            Self::THROW_PACIFY_HEAVY => 7i32,
            Self::THROW_DEADLY_LIGHT => 8i32,
            Self::THROW_DEADLY_HEAVY => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EThrowType {
     const TYPE_ID: &str = "EThrowType";
}

impl StaticVariant for Vec<EThrowType> {
     const TYPE_ID: &str = "TArray<EThrowType>";
}

impl StaticVariant for Vec<Vec<EThrowType>> {
     const TYPE_ID: &str = "TArray<TArray<EThrowType>>";
}

impl Variant for EThrowType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EThrowType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EThrowType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EThrowType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EThrowType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EThrowType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EThrownCollisionSoundLoudness {
    eLoudness_Default,
    eLoudness_Low,
    eLoudness_Normal,
    eLoudness_Loud,
}

impl Aligned for EThrownCollisionSoundLoudness {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EThrownCollisionSoundLoudness {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLoudness_Default => 0i32,
            Self::eLoudness_Low => 1i32,
            Self::eLoudness_Normal => 2i32,
            Self::eLoudness_Loud => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EThrownCollisionSoundLoudness {
     const TYPE_ID: &str = "EThrownCollisionSoundLoudness";
}

impl StaticVariant for Vec<EThrownCollisionSoundLoudness> {
     const TYPE_ID: &str = "TArray<EThrownCollisionSoundLoudness>";
}

impl StaticVariant for Vec<Vec<EThrownCollisionSoundLoudness>> {
     const TYPE_ID: &str = "TArray<TArray<EThrownCollisionSoundLoudness>>";
}

impl Variant for EThrownCollisionSoundLoudness {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EThrownCollisionSoundLoudness")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EThrownCollisionSoundLoudness".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EThrownCollisionSoundLoudness>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EThrownCollisionSoundLoudness>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EThrownCollisionSoundLoudness>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETimerEntityCommandType {
    ETECT_Add,
    ETECT_Remove,
    ETECT_Reset,
}

impl Aligned for ETimerEntityCommandType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETimerEntityCommandType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETECT_Add => 0i32,
            Self::ETECT_Remove => 1i32,
            Self::ETECT_Reset => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETimerEntityCommandType {
     const TYPE_ID: &str = "ETimerEntityCommandType";
}

impl StaticVariant for Vec<ETimerEntityCommandType> {
     const TYPE_ID: &str = "TArray<ETimerEntityCommandType>";
}

impl StaticVariant for Vec<Vec<ETimerEntityCommandType>> {
     const TYPE_ID: &str = "TArray<TArray<ETimerEntityCommandType>>";
}

impl Variant for ETimerEntityCommandType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETimerEntityCommandType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETimerEntityCommandType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETimerEntityCommandType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETimerEntityCommandType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETimerEntityCommandType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ETraceMessageType {
    Message,
    Warning,
    Error,
}

impl Aligned for ETraceMessageType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ETraceMessageType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Message => 0i32,
            Self::Warning => 1i32,
            Self::Error => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ETraceMessageType {
     const TYPE_ID: &str = "ETraceMessageType";
}

impl StaticVariant for Vec<ETraceMessageType> {
     const TYPE_ID: &str = "TArray<ETraceMessageType>";
}

impl StaticVariant for Vec<Vec<ETraceMessageType>> {
     const TYPE_ID: &str = "TArray<TArray<ETraceMessageType>>";
}

impl Variant for ETraceMessageType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ETraceMessageType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ETraceMessageType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ETraceMessageType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ETraceMessageType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ETraceMessageType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIActionGroupIcon {
    EUIAGI_NoIcon,
    EUIAGI_GenericTool,
    EUIAGI_Crowbar,
    EUIAGI_Wrench,
    EUIAGI_Screwdriver,
    EUIAGI_ExplosiveDevice,
    EUIAGI_Poison,
    EUIAGI_Coin,
    EUIAGI_Lockpick,
    EUIAGI_LockpickElectic,
    EUIAGI_Card,
    EUIAGI_Key,
    EUIAGI_Password,
    EUIAGI_SAPIENZA_GolfBall,
    EUIAGI_SAPIENZA_ChemicalTube,
    EUIAGI_SAPIENZA_FlowBouquet,
    EUIAGI_SAPIENZA_Ammunitions,
    EUIAGI_RatFood,
    EUIAGI_Gunpowder,
    EUIAGI_Cannonball,
    EUIAGI_FuguFish,
    EUIAGI_CakeTopper,
    EUIAGI_Knife,
    EUIAGI_SpaghettiCan,
    EUIAGI_MAX,
}

impl Aligned for EUIActionGroupIcon {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIActionGroupIcon {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EUIAGI_NoIcon => 0i32,
            Self::EUIAGI_GenericTool => 1i32,
            Self::EUIAGI_Crowbar => 2i32,
            Self::EUIAGI_Wrench => 3i32,
            Self::EUIAGI_Screwdriver => 4i32,
            Self::EUIAGI_ExplosiveDevice => 5i32,
            Self::EUIAGI_Poison => 6i32,
            Self::EUIAGI_Coin => 7i32,
            Self::EUIAGI_Lockpick => 8i32,
            Self::EUIAGI_LockpickElectic => 9i32,
            Self::EUIAGI_Card => 10i32,
            Self::EUIAGI_Key => 11i32,
            Self::EUIAGI_Password => 12i32,
            Self::EUIAGI_SAPIENZA_GolfBall => 13i32,
            Self::EUIAGI_SAPIENZA_ChemicalTube => 14i32,
            Self::EUIAGI_SAPIENZA_FlowBouquet => 15i32,
            Self::EUIAGI_SAPIENZA_Ammunitions => 16i32,
            Self::EUIAGI_RatFood => 17i32,
            Self::EUIAGI_Gunpowder => 18i32,
            Self::EUIAGI_Cannonball => 19i32,
            Self::EUIAGI_FuguFish => 20i32,
            Self::EUIAGI_CakeTopper => 21i32,
            Self::EUIAGI_Knife => 22i32,
            Self::EUIAGI_SpaghettiCan => 23i32,
            Self::EUIAGI_MAX => 24i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIActionGroupIcon {
     const TYPE_ID: &str = "EUIActionGroupIcon";
}

impl StaticVariant for Vec<EUIActionGroupIcon> {
     const TYPE_ID: &str = "TArray<EUIActionGroupIcon>";
}

impl StaticVariant for Vec<Vec<EUIActionGroupIcon>> {
     const TYPE_ID: &str = "TArray<TArray<EUIActionGroupIcon>>";
}

impl Variant for EUIActionGroupIcon {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIActionGroupIcon")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIActionGroupIcon".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIActionGroupIcon>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIActionGroupIcon>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIActionGroupIcon>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIBusyOperationId {
    eOperationId_GameSave,
    eOperationId_MenuTransition,
    eOperationId_ManuallyTriggered,
    eOperationId_TriggerBootFlow,
    eOperationId_SaveContract,
    eOperationId_StartContract,
    eOperationId_SessionStart,
    eOperationId_ReportContract,
    eOperationId_ConnectionFlow,
    eOperationId_LoadingTransitionDelayed,
    eOperationId_SaveSuccess,
    eOperationId_SaveFailed,
    eOperationId_SessionReconnect,
    eOperationId_NetSynchedMenuPause,
    eOperationId_NetSynchedMenuRestart,
    eOperationId_NetSynchedMenuReplan,
    eOperationId_StartingMultiplayerSession,
    eOperationId_HandlingMultiplayerRequest,
    eOperationId_PoorConnectivity,
    eOperationId_DefaultLoadout,
    eOperationId_OpeningShop,
    eOperationId_Max,
    eOperationId_Custom_01,
    eOperationId_Custom_Begin,
    eOperationId_Custom_02,
    eOperationId_Custom_03,
    eOperationId_Custom_04,
    eOperationId_Custom_05,
    eOperationId_Custom_06,
    eOperationId_Custom_07,
    eOperationId_Custom_08,
    eOperationId_Custom_09,
    eOperationId_Custom_10,
    eOperationId_Custom_11,
    eOperationId_Custom_12,
    eOperationId_Custom_13,
    eOperationId_Custom_14,
    eOperationId_Custom_15,
    eOperationId_Custom_16,
    eOperationId_Custom_17,
    eOperationId_Custom_18,
    eOperationId_Custom_19,
    eOperationId_Custom_20,
    eOperationId_Custom_21,
    eOperationId_Custom_22,
    eOperationId_Custom_23,
    eOperationId_Custom_24,
    eOperationId_Custom_25,
    eOperationId_Custom_End,
    eOperationId_None,
}

impl Aligned for EUIBusyOperationId {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIBusyOperationId {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eOperationId_GameSave => 0i32,
            Self::eOperationId_MenuTransition => 1i32,
            Self::eOperationId_ManuallyTriggered => 2i32,
            Self::eOperationId_TriggerBootFlow => 3i32,
            Self::eOperationId_SaveContract => 4i32,
            Self::eOperationId_StartContract => 5i32,
            Self::eOperationId_SessionStart => 6i32,
            Self::eOperationId_ReportContract => 7i32,
            Self::eOperationId_ConnectionFlow => 8i32,
            Self::eOperationId_LoadingTransitionDelayed => 9i32,
            Self::eOperationId_SaveSuccess => 10i32,
            Self::eOperationId_SaveFailed => 11i32,
            Self::eOperationId_SessionReconnect => 12i32,
            Self::eOperationId_NetSynchedMenuPause => 13i32,
            Self::eOperationId_NetSynchedMenuRestart => 14i32,
            Self::eOperationId_NetSynchedMenuReplan => 15i32,
            Self::eOperationId_StartingMultiplayerSession => 16i32,
            Self::eOperationId_HandlingMultiplayerRequest => 17i32,
            Self::eOperationId_PoorConnectivity => 18i32,
            Self::eOperationId_DefaultLoadout => 19i32,
            Self::eOperationId_OpeningShop => 20i32,
            Self::eOperationId_Max => 20i32,
            Self::eOperationId_Custom_01 => 21i32,
            Self::eOperationId_Custom_Begin => 21i32,
            Self::eOperationId_Custom_02 => 22i32,
            Self::eOperationId_Custom_03 => 23i32,
            Self::eOperationId_Custom_04 => 24i32,
            Self::eOperationId_Custom_05 => 25i32,
            Self::eOperationId_Custom_06 => 26i32,
            Self::eOperationId_Custom_07 => 27i32,
            Self::eOperationId_Custom_08 => 28i32,
            Self::eOperationId_Custom_09 => 29i32,
            Self::eOperationId_Custom_10 => 30i32,
            Self::eOperationId_Custom_11 => 31i32,
            Self::eOperationId_Custom_12 => 32i32,
            Self::eOperationId_Custom_13 => 33i32,
            Self::eOperationId_Custom_14 => 34i32,
            Self::eOperationId_Custom_15 => 35i32,
            Self::eOperationId_Custom_16 => 36i32,
            Self::eOperationId_Custom_17 => 37i32,
            Self::eOperationId_Custom_18 => 38i32,
            Self::eOperationId_Custom_19 => 39i32,
            Self::eOperationId_Custom_20 => 40i32,
            Self::eOperationId_Custom_21 => 41i32,
            Self::eOperationId_Custom_22 => 42i32,
            Self::eOperationId_Custom_23 => 43i32,
            Self::eOperationId_Custom_24 => 44i32,
            Self::eOperationId_Custom_25 => 45i32,
            Self::eOperationId_Custom_End => 46i32,
            Self::eOperationId_None => 47i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIBusyOperationId {
     const TYPE_ID: &str = "EUIBusyOperationId";
}

impl StaticVariant for Vec<EUIBusyOperationId> {
     const TYPE_ID: &str = "TArray<EUIBusyOperationId>";
}

impl StaticVariant for Vec<Vec<EUIBusyOperationId>> {
     const TYPE_ID: &str = "TArray<TArray<EUIBusyOperationId>>";
}

impl Variant for EUIBusyOperationId {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIBusyOperationId")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIBusyOperationId".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIBusyOperationId>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIBusyOperationId>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIBusyOperationId>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIBusyState {
    eBusyState_Saving,
    eBusyState_Saving_Failed,
    eBusyState_Saving_Success,
    eBusyState_Online_Connecting,
    eBusyState_Loading,
    eBusyState_Fetching,
    eBusyState_None,
}

impl Aligned for EUIBusyState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIBusyState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBusyState_Saving => 0i32,
            Self::eBusyState_Saving_Failed => 1i32,
            Self::eBusyState_Saving_Success => 2i32,
            Self::eBusyState_Online_Connecting => 3i32,
            Self::eBusyState_Loading => 4i32,
            Self::eBusyState_Fetching => 5i32,
            Self::eBusyState_None => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIBusyState {
     const TYPE_ID: &str = "EUIBusyState";
}

impl StaticVariant for Vec<EUIBusyState> {
     const TYPE_ID: &str = "TArray<EUIBusyState>";
}

impl StaticVariant for Vec<Vec<EUIBusyState>> {
     const TYPE_ID: &str = "TArray<TArray<EUIBusyState>>";
}

impl Variant for EUIBusyState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIBusyState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIBusyState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIBusyState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIBusyState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIBusyState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIGamepadButtonID {
    FaceButtonBottom,
    FaceButtonTop,
    FaceButtonLeft,
    FaceButtonRight,
    DpadUp,
    DpadRight,
    DpadDown,
    DpadLeft,
    ShoulderRight,
    TriggerRight,
    StickRight,
    StickRightPress,
    ShoulderLeft,
    TriggerLeft,
    StickLeft,
    StickLeftPress,
    ButtonStart,
    ButtonSelect,
    ButtonSelectAlt,
    ButtonStartAlt,
    DpadAll,
    DpadUpDown,
    DpadLeftRight,
    TriggersLR,
    ButtonCapture,
    ButtonHome,
    ButtonAssistant,
}

impl Aligned for EUIGamepadButtonID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIGamepadButtonID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FaceButtonBottom => 1i32,
            Self::FaceButtonTop => 2i32,
            Self::FaceButtonLeft => 3i32,
            Self::FaceButtonRight => 4i32,
            Self::DpadUp => 5i32,
            Self::DpadRight => 6i32,
            Self::DpadDown => 7i32,
            Self::DpadLeft => 8i32,
            Self::ShoulderRight => 9i32,
            Self::TriggerRight => 10i32,
            Self::StickRight => 11i32,
            Self::StickRightPress => 12i32,
            Self::ShoulderLeft => 13i32,
            Self::TriggerLeft => 14i32,
            Self::StickLeft => 15i32,
            Self::StickLeftPress => 16i32,
            Self::ButtonStart => 17i32,
            Self::ButtonSelect => 18i32,
            Self::ButtonSelectAlt => 19i32,
            Self::ButtonStartAlt => 20i32,
            Self::DpadAll => 21i32,
            Self::DpadUpDown => 22i32,
            Self::DpadLeftRight => 23i32,
            Self::TriggersLR => 24i32,
            Self::ButtonCapture => 25i32,
            Self::ButtonHome => 26i32,
            Self::ButtonAssistant => 27i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIGamepadButtonID {
     const TYPE_ID: &str = "EUIGamepadButtonID";
}

impl StaticVariant for Vec<EUIGamepadButtonID> {
     const TYPE_ID: &str = "TArray<EUIGamepadButtonID>";
}

impl StaticVariant for Vec<Vec<EUIGamepadButtonID>> {
     const TYPE_ID: &str = "TArray<TArray<EUIGamepadButtonID>>";
}

impl Variant for EUIGamepadButtonID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIGamepadButtonID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIGamepadButtonID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIGamepadButtonID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIGamepadButtonID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIGamepadButtonID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIIconLibrary {
    NONE,
    addedtolist,
    addtolist,
    ammo,
    ammunition,
    arcademode,
    arrowdown,
    arrowleft,
    arrowright,
    arrowup,
    assaultrifle,
    audio,
    background,
    benchmarks,
    blank,
    bulletdancer,
    carrieditem,
    carriedweapon,
    challenge,
    challenge_category_assassination,
    challenge_category_discovery,
    challenge_category_feats,
    challenge_category_item,
    challenge_category_targets,
    check,
    civilians,
    closerange,
    completed,
    completion,
    completionlist,
    complication,
    complication_optional,
    concealedweapon,
    container,
    contract,
    controller,
    corrupt,
    creation,
    credits,
    crowdcontrol,
    cutscene,
    damage,
    difficulty,
    difficulty1,
    difficulty2,
    difficulty3,
    difficultyeasy,
    difficultyhard,
    difficultylevel,
    difficultynormal,
    disguise,
    distraction,
    download,
    downloading,
    edit,
    elevation,
    elusive,
    emote,
    escalation,
    evergreen_camera_caught,
    evergreen_camera_destroy,
    evergreen_camera_destroy_recorder,
    evergreen_check,
    evergreen_contracts,
    evergreen_dead_body_disposal,
    evergreen_dead_body_disposal_timed,
    evergreen_destination_not_owned,
    evergreen_do_not_get_spotted,
    evergreen_do_not_initiate_combat,
    evergreen_do_not_take_any_damage,
    evergreen_failed,
    evergreen_gamemode,
    evergreen_gear,
    evergreen_gearcost,
    evergreen_gearcost_1,
    evergreen_gearcost_2,
    evergreen_gearcost_3,
    evergreen_gearcost_4,
    evergreen_gearcost_5,
    evergreen_gearcost_6,
    evergreen_gearcost_7,
    evergreen_gearcost_8,
    evergreen_gearcost_9,
    evergreen_item_removed_from_safehouse_wall,
    evergreen_kill_method_accident,
    evergreen_kill_method_accident_burn,
    evergreen_kill_method_assault_rifle,
    evergreen_kill_method_axe,
    evergreen_kill_method_drown,
    evergreen_kill_method_electric,
    evergreen_kill_method_explosive,
    evergreen_kill_method_fiber_wire,
    evergreen_kill_method_headshots_only,
    evergreen_kill_method_melee,
    evergreen_kill_method_oil_puddle,
    evergreen_kill_method_pistol,
    evergreen_kill_method_pistol_silenced,
    evergreen_kill_method_poison,
    evergreen_kill_method_push,
    evergreen_kill_method_shotgun,
    evergreen_kill_method_smg,
    evergreen_kill_method_sniper,
    evergreen_kill_method_throw,
    evergreen_kill_method_unarmed,
    evergreen_kill_method_wallbang,
    evergreen_kill_method_water_puddle,
    evergreen_merces,
    evergreen_mules,
    evergreen_no_bodies_found,
    evergreen_no_compromised_disguises,
    evergreen_no_disguise_change,
    evergreen_no_lockpick,
    evergreen_no_missed_shots,
    evergreen_only_kill_targets,
    evergreen_optin_killmethod,
    evergreen_optin_showdown,
    evergreen_optin_silentassassin,
    evergreen_optin_speedrun,
    evergreen_pacify_raremelee,
    evergreen_payout,
    evergreen_safe,
    evergreen_safehouse_cosmetic,
    evergreen_safehouse_unlock,
    evergreen_search_locate,
    evergreen_showdown_mission,
    evergreen_suppliers,
    evergreen_tags,
    evergreen_target,
    exit,
    explosive,
    explosives,
    extendedmag,
    extendedmag_1,
    extendedmag_2,
    extendedmag_3,
    extendedmag_4,
    eye_tracking,
    failed,
    fastreload,
    fastreload_1,
    fastreload_2,
    fastreload_3,
    fastreload_4,
    favoritecontracts,
    featured,
    fiberwire,
    firearm,
    fixed,
    flashback,
    frisk,
    fullauto,
    game,
    gamehud,
    gear,
    goonline,
    graphics,
    hailstorm,
    hidden,
    highpressure,
    ica,
    info,
    intel,
    inventory,
    ioiaccount,
    key,
    kill,
    knockdown,
    language,
    leaderboard,
    leaderboardfriends,
    livetilenews,
    load,
    loadout,
    location,
    locked,
    longrange,
    lookup,
    map,
    marksman,
    marksman_1,
    marksman_2,
    marksman_3,
    marksman_4,
    masteryunlocked,
    melee,
    mission,
    mostplayed,
    mousekeyboard,
    mycontracts,
    myhistory,
    nextlevel,
    nodus,
    npc,
    nvidia,
    objective,
    onemanarmy,
    online,
    opportunitycompleted,
    opportunitydisabled,
    opportunitydiscovered,
    opportunityfailed,
    opportunitysearch,
    opportunitytracked,
    opportunityundiscovered,
    outbreak,
    piercing,
    pistol,
    planning,
    play,
    pointshooting,
    poison,
    profile,
    publish,
    questitem,
    quit,
    rateoffire,
    rateoffire_1,
    rateoffire_2,
    rateoffire_3,
    rateoffire_4,
    realtutorial,
    remote,
    replay,
    reset,
    resetback,
    save,
    saveauto,
    savedisabled,
    savemanual,
    search,
    security,
    settings,
    shop,
    shotgun,
    silent,
    smg,
    sniperrifle,
    stable,
    stable_1,
    stable_2,
    stable_3,
    stable_4,
    starting,
    stashpointempty,
    stashpointfull,
    stats,
    steadyaim,
    steadyaim_1,
    steadyaim_2,
    steadyaim_3,
    steadyaim_4,
    story,
    subsonic,
    suitcase,
    suppressor,
    tacticalshock,
    tag,
    target,
    timed,
    titaniumcomposite,
    toggleleft,
    toggleright,
    tool,
    trashbin,
    tutorial,
    unlocked,
    usercreated,
    variable,
    versatilescope,
    versatilescope_1,
    versatilescope_2,
    versatilescope_3,
    versatilescope_4,
    versatilescopeextended,
    versus,
    vr,
    warning,
    weapon,
    witness,
}

impl Aligned for EUIIconLibrary {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIIconLibrary {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NONE => 0i32,
            Self::addedtolist => 1i32,
            Self::addtolist => 2i32,
            Self::ammo => 3i32,
            Self::ammunition => 4i32,
            Self::arcademode => 5i32,
            Self::arrowdown => 6i32,
            Self::arrowleft => 7i32,
            Self::arrowright => 8i32,
            Self::arrowup => 9i32,
            Self::assaultrifle => 10i32,
            Self::audio => 11i32,
            Self::background => 12i32,
            Self::benchmarks => 13i32,
            Self::blank => 14i32,
            Self::bulletdancer => 15i32,
            Self::carrieditem => 16i32,
            Self::carriedweapon => 17i32,
            Self::challenge => 18i32,
            Self::challenge_category_assassination => 19i32,
            Self::challenge_category_discovery => 20i32,
            Self::challenge_category_feats => 21i32,
            Self::challenge_category_item => 22i32,
            Self::challenge_category_targets => 23i32,
            Self::check => 24i32,
            Self::civilians => 25i32,
            Self::closerange => 26i32,
            Self::completed => 27i32,
            Self::completion => 28i32,
            Self::completionlist => 29i32,
            Self::complication => 30i32,
            Self::complication_optional => 31i32,
            Self::concealedweapon => 32i32,
            Self::container => 33i32,
            Self::contract => 34i32,
            Self::controller => 35i32,
            Self::corrupt => 36i32,
            Self::creation => 37i32,
            Self::credits => 38i32,
            Self::crowdcontrol => 39i32,
            Self::cutscene => 40i32,
            Self::damage => 41i32,
            Self::difficulty => 42i32,
            Self::difficulty1 => 43i32,
            Self::difficulty2 => 44i32,
            Self::difficulty3 => 45i32,
            Self::difficultyeasy => 46i32,
            Self::difficultyhard => 47i32,
            Self::difficultylevel => 48i32,
            Self::difficultynormal => 49i32,
            Self::disguise => 50i32,
            Self::distraction => 51i32,
            Self::download => 52i32,
            Self::downloading => 53i32,
            Self::edit => 54i32,
            Self::elevation => 55i32,
            Self::elusive => 56i32,
            Self::emote => 57i32,
            Self::escalation => 58i32,
            Self::evergreen_camera_caught => 59i32,
            Self::evergreen_camera_destroy => 60i32,
            Self::evergreen_camera_destroy_recorder => 61i32,
            Self::evergreen_check => 62i32,
            Self::evergreen_contracts => 63i32,
            Self::evergreen_dead_body_disposal => 64i32,
            Self::evergreen_dead_body_disposal_timed => 65i32,
            Self::evergreen_destination_not_owned => 66i32,
            Self::evergreen_do_not_get_spotted => 67i32,
            Self::evergreen_do_not_initiate_combat => 68i32,
            Self::evergreen_do_not_take_any_damage => 69i32,
            Self::evergreen_failed => 70i32,
            Self::evergreen_gamemode => 71i32,
            Self::evergreen_gear => 72i32,
            Self::evergreen_gearcost => 73i32,
            Self::evergreen_gearcost_1 => 74i32,
            Self::evergreen_gearcost_2 => 75i32,
            Self::evergreen_gearcost_3 => 76i32,
            Self::evergreen_gearcost_4 => 77i32,
            Self::evergreen_gearcost_5 => 78i32,
            Self::evergreen_gearcost_6 => 79i32,
            Self::evergreen_gearcost_7 => 80i32,
            Self::evergreen_gearcost_8 => 81i32,
            Self::evergreen_gearcost_9 => 82i32,
            Self::evergreen_item_removed_from_safehouse_wall => 83i32,
            Self::evergreen_kill_method_accident => 84i32,
            Self::evergreen_kill_method_accident_burn => 85i32,
            Self::evergreen_kill_method_assault_rifle => 86i32,
            Self::evergreen_kill_method_axe => 87i32,
            Self::evergreen_kill_method_drown => 88i32,
            Self::evergreen_kill_method_electric => 89i32,
            Self::evergreen_kill_method_explosive => 90i32,
            Self::evergreen_kill_method_fiber_wire => 91i32,
            Self::evergreen_kill_method_headshots_only => 92i32,
            Self::evergreen_kill_method_melee => 93i32,
            Self::evergreen_kill_method_oil_puddle => 94i32,
            Self::evergreen_kill_method_pistol => 95i32,
            Self::evergreen_kill_method_pistol_silenced => 96i32,
            Self::evergreen_kill_method_poison => 97i32,
            Self::evergreen_kill_method_push => 98i32,
            Self::evergreen_kill_method_shotgun => 99i32,
            Self::evergreen_kill_method_smg => 100i32,
            Self::evergreen_kill_method_sniper => 101i32,
            Self::evergreen_kill_method_throw => 102i32,
            Self::evergreen_kill_method_unarmed => 103i32,
            Self::evergreen_kill_method_wallbang => 104i32,
            Self::evergreen_kill_method_water_puddle => 105i32,
            Self::evergreen_merces => 106i32,
            Self::evergreen_mules => 107i32,
            Self::evergreen_no_bodies_found => 108i32,
            Self::evergreen_no_compromised_disguises => 109i32,
            Self::evergreen_no_disguise_change => 110i32,
            Self::evergreen_no_lockpick => 111i32,
            Self::evergreen_no_missed_shots => 112i32,
            Self::evergreen_only_kill_targets => 113i32,
            Self::evergreen_optin_killmethod => 114i32,
            Self::evergreen_optin_showdown => 115i32,
            Self::evergreen_optin_silentassassin => 116i32,
            Self::evergreen_optin_speedrun => 117i32,
            Self::evergreen_pacify_raremelee => 118i32,
            Self::evergreen_payout => 119i32,
            Self::evergreen_safe => 120i32,
            Self::evergreen_safehouse_cosmetic => 121i32,
            Self::evergreen_safehouse_unlock => 122i32,
            Self::evergreen_search_locate => 123i32,
            Self::evergreen_showdown_mission => 124i32,
            Self::evergreen_suppliers => 125i32,
            Self::evergreen_tags => 126i32,
            Self::evergreen_target => 127i32,
            Self::exit => 128i32,
            Self::explosive => 129i32,
            Self::explosives => 130i32,
            Self::extendedmag => 131i32,
            Self::extendedmag_1 => 132i32,
            Self::extendedmag_2 => 133i32,
            Self::extendedmag_3 => 134i32,
            Self::extendedmag_4 => 135i32,
            Self::eye_tracking => 136i32,
            Self::failed => 137i32,
            Self::fastreload => 138i32,
            Self::fastreload_1 => 139i32,
            Self::fastreload_2 => 140i32,
            Self::fastreload_3 => 141i32,
            Self::fastreload_4 => 142i32,
            Self::favoritecontracts => 143i32,
            Self::featured => 144i32,
            Self::fiberwire => 145i32,
            Self::firearm => 146i32,
            Self::fixed => 147i32,
            Self::flashback => 148i32,
            Self::frisk => 149i32,
            Self::fullauto => 150i32,
            Self::game => 151i32,
            Self::gamehud => 152i32,
            Self::gear => 153i32,
            Self::goonline => 154i32,
            Self::graphics => 155i32,
            Self::hailstorm => 156i32,
            Self::hidden => 157i32,
            Self::highpressure => 158i32,
            Self::ica => 159i32,
            Self::info => 160i32,
            Self::intel => 161i32,
            Self::inventory => 162i32,
            Self::ioiaccount => 163i32,
            Self::key => 164i32,
            Self::kill => 165i32,
            Self::knockdown => 166i32,
            Self::language => 167i32,
            Self::leaderboard => 168i32,
            Self::leaderboardfriends => 169i32,
            Self::livetilenews => 170i32,
            Self::load => 171i32,
            Self::loadout => 172i32,
            Self::location => 173i32,
            Self::locked => 174i32,
            Self::longrange => 175i32,
            Self::lookup => 176i32,
            Self::map => 177i32,
            Self::marksman => 178i32,
            Self::marksman_1 => 179i32,
            Self::marksman_2 => 180i32,
            Self::marksman_3 => 181i32,
            Self::marksman_4 => 182i32,
            Self::masteryunlocked => 183i32,
            Self::melee => 184i32,
            Self::mission => 185i32,
            Self::mostplayed => 186i32,
            Self::mousekeyboard => 187i32,
            Self::mycontracts => 188i32,
            Self::myhistory => 189i32,
            Self::nextlevel => 190i32,
            Self::nodus => 191i32,
            Self::npc => 192i32,
            Self::nvidia => 193i32,
            Self::objective => 194i32,
            Self::onemanarmy => 195i32,
            Self::online => 196i32,
            Self::opportunitycompleted => 197i32,
            Self::opportunitydisabled => 198i32,
            Self::opportunitydiscovered => 199i32,
            Self::opportunityfailed => 200i32,
            Self::opportunitysearch => 201i32,
            Self::opportunitytracked => 202i32,
            Self::opportunityundiscovered => 203i32,
            Self::outbreak => 204i32,
            Self::piercing => 205i32,
            Self::pistol => 206i32,
            Self::planning => 207i32,
            Self::play => 208i32,
            Self::pointshooting => 209i32,
            Self::poison => 210i32,
            Self::profile => 211i32,
            Self::publish => 212i32,
            Self::questitem => 213i32,
            Self::quit => 214i32,
            Self::rateoffire => 215i32,
            Self::rateoffire_1 => 216i32,
            Self::rateoffire_2 => 217i32,
            Self::rateoffire_3 => 218i32,
            Self::rateoffire_4 => 219i32,
            Self::realtutorial => 220i32,
            Self::remote => 221i32,
            Self::replay => 222i32,
            Self::reset => 223i32,
            Self::resetback => 224i32,
            Self::save => 225i32,
            Self::saveauto => 226i32,
            Self::savedisabled => 227i32,
            Self::savemanual => 228i32,
            Self::search => 229i32,
            Self::security => 230i32,
            Self::settings => 231i32,
            Self::shop => 232i32,
            Self::shotgun => 233i32,
            Self::silent => 234i32,
            Self::smg => 235i32,
            Self::sniperrifle => 236i32,
            Self::stable => 237i32,
            Self::stable_1 => 238i32,
            Self::stable_2 => 239i32,
            Self::stable_3 => 240i32,
            Self::stable_4 => 241i32,
            Self::starting => 242i32,
            Self::stashpointempty => 243i32,
            Self::stashpointfull => 244i32,
            Self::stats => 245i32,
            Self::steadyaim => 246i32,
            Self::steadyaim_1 => 247i32,
            Self::steadyaim_2 => 248i32,
            Self::steadyaim_3 => 249i32,
            Self::steadyaim_4 => 250i32,
            Self::story => 251i32,
            Self::subsonic => 252i32,
            Self::suitcase => 253i32,
            Self::suppressor => 254i32,
            Self::tacticalshock => 255i32,
            Self::tag => 256i32,
            Self::target => 257i32,
            Self::timed => 258i32,
            Self::titaniumcomposite => 259i32,
            Self::toggleleft => 260i32,
            Self::toggleright => 261i32,
            Self::tool => 262i32,
            Self::trashbin => 263i32,
            Self::tutorial => 264i32,
            Self::unlocked => 265i32,
            Self::usercreated => 266i32,
            Self::variable => 267i32,
            Self::versatilescope => 268i32,
            Self::versatilescope_1 => 269i32,
            Self::versatilescope_2 => 270i32,
            Self::versatilescope_3 => 271i32,
            Self::versatilescope_4 => 272i32,
            Self::versatilescopeextended => 273i32,
            Self::versus => 274i32,
            Self::vr => 275i32,
            Self::warning => 276i32,
            Self::weapon => 277i32,
            Self::witness => 278i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIIconLibrary {
     const TYPE_ID: &str = "EUIIconLibrary";
}

impl StaticVariant for Vec<EUIIconLibrary> {
     const TYPE_ID: &str = "TArray<EUIIconLibrary>";
}

impl StaticVariant for Vec<Vec<EUIIconLibrary>> {
     const TYPE_ID: &str = "TArray<TArray<EUIIconLibrary>>";
}

impl Variant for EUIIconLibrary {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIIconLibrary")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIIconLibrary".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIIconLibrary>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIIconLibrary>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIIconLibrary>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIOpenVRComponentArchetypeID {
    ButtonL,
    ButtonR,
    Button,
    GripL,
    GripR,
    Joystick,
    JoystickPressCenter,
    JoystickPressDirections,
    TrackpadRound,
    TrackpadRoundPressCenter,
    TrackpadRoundPressDirections,
    TrackpadTall,
    TrackpadTallPressCenter,
    TrackpadTallPressDirections,
    TriggerL,
    TriggerR,
    BumperL,
    BumperR,
}

impl Aligned for EUIOpenVRComponentArchetypeID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIOpenVRComponentArchetypeID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ButtonL => 1i32,
            Self::ButtonR => 2i32,
            Self::Button => 3i32,
            Self::GripL => 4i32,
            Self::GripR => 5i32,
            Self::Joystick => 6i32,
            Self::JoystickPressCenter => 7i32,
            Self::JoystickPressDirections => 8i32,
            Self::TrackpadRound => 9i32,
            Self::TrackpadRoundPressCenter => 10i32,
            Self::TrackpadRoundPressDirections => 11i32,
            Self::TrackpadTall => 12i32,
            Self::TrackpadTallPressCenter => 13i32,
            Self::TrackpadTallPressDirections => 14i32,
            Self::TriggerL => 15i32,
            Self::TriggerR => 16i32,
            Self::BumperL => 17i32,
            Self::BumperR => 18i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIOpenVRComponentArchetypeID {
     const TYPE_ID: &str = "EUIOpenVRComponentArchetypeID";
}

impl StaticVariant for Vec<EUIOpenVRComponentArchetypeID> {
     const TYPE_ID: &str = "TArray<EUIOpenVRComponentArchetypeID>";
}

impl StaticVariant for Vec<Vec<EUIOpenVRComponentArchetypeID>> {
     const TYPE_ID: &str = "TArray<TArray<EUIOpenVRComponentArchetypeID>>";
}

impl Variant for EUIOpenVRComponentArchetypeID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIOpenVRComponentArchetypeID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIOpenVRComponentArchetypeID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIOpenVRComponentArchetypeID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIOpenVRComponentArchetypeID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIOpenVRComponentArchetypeID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUIOpenVRPressDirection {
    North,
    South,
    East,
    West,
}

impl Aligned for EUIOpenVRPressDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUIOpenVRPressDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::North => 1i32,
            Self::South => 2i32,
            Self::East => 4i32,
            Self::West => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUIOpenVRPressDirection {
     const TYPE_ID: &str = "EUIOpenVRPressDirection";
}

impl StaticVariant for Vec<EUIOpenVRPressDirection> {
     const TYPE_ID: &str = "TArray<EUIOpenVRPressDirection>";
}

impl StaticVariant for Vec<Vec<EUIOpenVRPressDirection>> {
     const TYPE_ID: &str = "TArray<TArray<EUIOpenVRPressDirection>>";
}

impl Variant for EUIOpenVRPressDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUIOpenVRPressDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUIOpenVRPressDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUIOpenVRPressDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUIOpenVRPressDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUIOpenVRPressDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EUbitusRequest {
    EUR_DEVICE_LANGUAGE,
    EUR_DEVICE_MODE,
    EUR_NETWORK_SERVICE_ACCOUNT_ID,
    EUR_ACCOUNT_AUTHORIZATION_CODE,
    EUR_ACCOUNT_AUTHORIZATION_TOKEN,
    EUR_NETWORK_SERVICE_ACCOUNT_TOKEN,
    EUR_NICKNAME,
    EUR_FRIEND_LIST,
    EUR_BLOCKED_USER_LIST,
    EUR_PROFILE_LIST,
    EUR_ESHOP_INFO,
    EUR_FREE_COMMUNICATION_AVAILABLE,
    EUR_DLC_PURCHASE_STATUS,
    EUR_PAUSE_GAME,
    EUR_RESUME_GAME,
    EUR_ESHOP_CLOSED,
}

impl Aligned for EUbitusRequest {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EUbitusRequest {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EUR_DEVICE_LANGUAGE => 0i32,
            Self::EUR_DEVICE_MODE => 16i32,
            Self::EUR_NETWORK_SERVICE_ACCOUNT_ID => 48i32,
            Self::EUR_ACCOUNT_AUTHORIZATION_CODE => 64i32,
            Self::EUR_ACCOUNT_AUTHORIZATION_TOKEN => 80i32,
            Self::EUR_NETWORK_SERVICE_ACCOUNT_TOKEN => 96i32,
            Self::EUR_NICKNAME => 112i32,
            Self::EUR_FRIEND_LIST => 128i32,
            Self::EUR_BLOCKED_USER_LIST => 144i32,
            Self::EUR_PROFILE_LIST => 160i32,
            Self::EUR_ESHOP_INFO => 176i32,
            Self::EUR_FREE_COMMUNICATION_AVAILABLE => 192i32,
            Self::EUR_DLC_PURCHASE_STATUS => 208i32,
            Self::EUR_PAUSE_GAME => 32800i32,
            Self::EUR_RESUME_GAME => 32801i32,
            Self::EUR_ESHOP_CLOSED => 1226i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EUbitusRequest {
     const TYPE_ID: &str = "EUbitusRequest";
}

impl StaticVariant for Vec<EUbitusRequest> {
     const TYPE_ID: &str = "TArray<EUbitusRequest>";
}

impl StaticVariant for Vec<Vec<EUbitusRequest>> {
     const TYPE_ID: &str = "TArray<TArray<EUbitusRequest>>";
}

impl Variant for EUbitusRequest {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EUbitusRequest")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EUbitusRequest".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EUbitusRequest>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EUbitusRequest>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EUbitusRequest>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfig360CameraAnchor {
    EVRCCA_360FacingCameraAnchor,
    EVRCCA_FixedFacingCameraAnchor,
    EVRCCA_KeepCurrent,
}

impl Aligned for EVRConfig360CameraAnchor {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfig360CameraAnchor {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCCA_360FacingCameraAnchor => 0i32,
            Self::EVRCCA_FixedFacingCameraAnchor => 1i32,
            Self::EVRCCA_KeepCurrent => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfig360CameraAnchor {
     const TYPE_ID: &str = "EVRConfig360CameraAnchor";
}

impl StaticVariant for Vec<EVRConfig360CameraAnchor> {
     const TYPE_ID: &str = "TArray<EVRConfig360CameraAnchor>";
}

impl StaticVariant for Vec<Vec<EVRConfig360CameraAnchor>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfig360CameraAnchor>>";
}

impl Variant for EVRConfig360CameraAnchor {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfig360CameraAnchor")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfig360CameraAnchor".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfig360CameraAnchor>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfig360CameraAnchor>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfig360CameraAnchor>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigAnimationMode {
    EVRCAM_FullAnimation,
    EVRCAM_FullAnimationFreeze,
    EVRCAM_HideAnimation,
    EVRCAM_HideUpperBodyAnimation,
    EVRCAM_RemoveGroundMotion,
    EVRCAM_RemoveFullBodyAndGroundMotion,
    EVRCAM_KeepCurrentMode,
}

impl Aligned for EVRConfigAnimationMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigAnimationMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCAM_FullAnimation => 0i32,
            Self::EVRCAM_FullAnimationFreeze => 1i32,
            Self::EVRCAM_HideAnimation => 2i32,
            Self::EVRCAM_HideUpperBodyAnimation => 3i32,
            Self::EVRCAM_RemoveGroundMotion => 4i32,
            Self::EVRCAM_RemoveFullBodyAndGroundMotion => 5i32,
            Self::EVRCAM_KeepCurrentMode => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigAnimationMode {
     const TYPE_ID: &str = "EVRConfigAnimationMode";
}

impl StaticVariant for Vec<EVRConfigAnimationMode> {
     const TYPE_ID: &str = "TArray<EVRConfigAnimationMode>";
}

impl StaticVariant for Vec<Vec<EVRConfigAnimationMode>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigAnimationMode>>";
}

impl Variant for EVRConfigAnimationMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigAnimationMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigAnimationMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigAnimationMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigAnimationMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigAnimationMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigCameraRotationAllowed {
    EVRCCRA_RotationEnabled,
    EVRCCRA_RotationDisabled,
    EVRCCRA_KeepCurrent,
}

impl Aligned for EVRConfigCameraRotationAllowed {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigCameraRotationAllowed {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCCRA_RotationEnabled => 0i32,
            Self::EVRCCRA_RotationDisabled => 1i32,
            Self::EVRCCRA_KeepCurrent => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigCameraRotationAllowed {
     const TYPE_ID: &str = "EVRConfigCameraRotationAllowed";
}

impl StaticVariant for Vec<EVRConfigCameraRotationAllowed> {
     const TYPE_ID: &str = "TArray<EVRConfigCameraRotationAllowed>";
}

impl StaticVariant for Vec<Vec<EVRConfigCameraRotationAllowed>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigCameraRotationAllowed>>";
}

impl Variant for EVRConfigCameraRotationAllowed {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigCameraRotationAllowed")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigCameraRotationAllowed".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigCameraRotationAllowed>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigCameraRotationAllowed>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigCameraRotationAllowed>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigCapsuleGridSize {
    EVRCCGS_RegularGrid,
    EVRCCGS_SmallGrid,
}

impl Aligned for EVRConfigCapsuleGridSize {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigCapsuleGridSize {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCCGS_RegularGrid => 0i32,
            Self::EVRCCGS_SmallGrid => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigCapsuleGridSize {
     const TYPE_ID: &str = "EVRConfigCapsuleGridSize";
}

impl StaticVariant for Vec<EVRConfigCapsuleGridSize> {
     const TYPE_ID: &str = "TArray<EVRConfigCapsuleGridSize>";
}

impl StaticVariant for Vec<Vec<EVRConfigCapsuleGridSize>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigCapsuleGridSize>>";
}

impl Variant for EVRConfigCapsuleGridSize {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigCapsuleGridSize")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigCapsuleGridSize".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigCapsuleGridSize>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigCapsuleGridSize>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigCapsuleGridSize>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigCinemaMode {
    EVRCCM_CinemaModeEnabled60FPS,
    EVRCCM_CinemaModeEnabled,
    EVRCCM_CinemaModeDisabled,
    EVRCCM_KeepCurrent,
}

impl Aligned for EVRConfigCinemaMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigCinemaMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCCM_CinemaModeEnabled60FPS => 0i32,
            Self::EVRCCM_CinemaModeEnabled => 1i32,
            Self::EVRCCM_CinemaModeDisabled => 2i32,
            Self::EVRCCM_KeepCurrent => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigCinemaMode {
     const TYPE_ID: &str = "EVRConfigCinemaMode";
}

impl StaticVariant for Vec<EVRConfigCinemaMode> {
     const TYPE_ID: &str = "TArray<EVRConfigCinemaMode>";
}

impl StaticVariant for Vec<Vec<EVRConfigCinemaMode>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigCinemaMode>>";
}

impl Variant for EVRConfigCinemaMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigCinemaMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigCinemaMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigCinemaMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigCinemaMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigCinemaMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigCustomEvent {
    EVRCCE_ClosetInside,
    EVRCCE_ClosetExiting,
    EVRCCE_DrainPipeMounted,
    EVRCCE_DrainPipeStartedDismounting,
    EVRCCE_LadderMounted,
    EVRCCE_LadderStartedDismounting,
    EVRCCE_LedgeChange,
    EVRCCE_LedgeShimmyStart,
    EVRCCE_LedgeShimmyStop,
    EVRCCE_PeekEntered,
    EVRCCE_PeekStartedExiting,
    EVRCCE_FriskStartedTurning,
    EVRCCE_FriskEndedTurning,
    EVRCCE_ShowItemStartedTurning,
    EVRCCE_ShowItemEndedTurning,
    EVRCCE_SubactionAnimationStarted,
    EVRCCE_SubactionAnimation_Hide,
    EVRCCE_FocussedInteractionEntered,
    EVRCCE_FocussedInteractionStartedExiting,
    EVRCCE_DisguiseSafeZoneEntered,
    EVRCCE_DisguiseSafeZoneStartedExiting,
    EVRCCE_SniperModeEnter,
    EVRCCE_SniperModeEntered,
    EVRCCE_SniperModeExit,
    EVRCCE_SniperModeExited,
    EVRCCE_VictimMovement0,
    EVRCCE_VictimMovement1,
    EVRCCE_VictimMovement2,
    EVRCCE_VictimMovement3,
    EVRCCE_VictimMovementRemoveControl,
    EVRCCE_AgilityLowVault,
    EVRCCE_AgilityHighVault,
    EVRCCE_AgilityRemoveControl,
    EVRCCE_FiberwireStartPriming,
    EVRCCE_FiberwireStopPriming,
    EVRCCE_ToiletDrownEntered,
    EVRCCE_ToiletDrownExited,
    EVRCCE_CloseCombatStartPriming,
    EVRCCE_CloseCombatStopPriming,
    EVRCCE_SilentTakedownEnterActivationArea,
    EVRCCE_SilentTakedownExitActivationArea,
    EVRCCE_SilentTakedownInstaPacification,
    EVRCCE_SnapNeckEnterActivationArea,
    EVRCCE_SnapNeckExitActivationArea,
    EVRCCE_TeleportStart,
    EVRCCE_TeleportEnd,
}

impl Aligned for EVRConfigCustomEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigCustomEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCCE_ClosetInside => 0i32,
            Self::EVRCCE_ClosetExiting => 1i32,
            Self::EVRCCE_DrainPipeMounted => 2i32,
            Self::EVRCCE_DrainPipeStartedDismounting => 3i32,
            Self::EVRCCE_LadderMounted => 4i32,
            Self::EVRCCE_LadderStartedDismounting => 5i32,
            Self::EVRCCE_LedgeChange => 6i32,
            Self::EVRCCE_LedgeShimmyStart => 7i32,
            Self::EVRCCE_LedgeShimmyStop => 8i32,
            Self::EVRCCE_PeekEntered => 9i32,
            Self::EVRCCE_PeekStartedExiting => 10i32,
            Self::EVRCCE_FriskStartedTurning => 11i32,
            Self::EVRCCE_FriskEndedTurning => 12i32,
            Self::EVRCCE_ShowItemStartedTurning => 13i32,
            Self::EVRCCE_ShowItemEndedTurning => 14i32,
            Self::EVRCCE_SubactionAnimationStarted => 15i32,
            Self::EVRCCE_SubactionAnimation_Hide => 16i32,
            Self::EVRCCE_FocussedInteractionEntered => 17i32,
            Self::EVRCCE_FocussedInteractionStartedExiting => 18i32,
            Self::EVRCCE_DisguiseSafeZoneEntered => 19i32,
            Self::EVRCCE_DisguiseSafeZoneStartedExiting => 20i32,
            Self::EVRCCE_SniperModeEnter => 21i32,
            Self::EVRCCE_SniperModeEntered => 22i32,
            Self::EVRCCE_SniperModeExit => 23i32,
            Self::EVRCCE_SniperModeExited => 24i32,
            Self::EVRCCE_VictimMovement0 => 25i32,
            Self::EVRCCE_VictimMovement1 => 26i32,
            Self::EVRCCE_VictimMovement2 => 27i32,
            Self::EVRCCE_VictimMovement3 => 28i32,
            Self::EVRCCE_VictimMovementRemoveControl => 29i32,
            Self::EVRCCE_AgilityLowVault => 30i32,
            Self::EVRCCE_AgilityHighVault => 31i32,
            Self::EVRCCE_AgilityRemoveControl => 32i32,
            Self::EVRCCE_FiberwireStartPriming => 33i32,
            Self::EVRCCE_FiberwireStopPriming => 34i32,
            Self::EVRCCE_ToiletDrownEntered => 35i32,
            Self::EVRCCE_ToiletDrownExited => 36i32,
            Self::EVRCCE_CloseCombatStartPriming => 37i32,
            Self::EVRCCE_CloseCombatStopPriming => 38i32,
            Self::EVRCCE_SilentTakedownEnterActivationArea => 39i32,
            Self::EVRCCE_SilentTakedownExitActivationArea => 40i32,
            Self::EVRCCE_SilentTakedownInstaPacification => 41i32,
            Self::EVRCCE_SnapNeckEnterActivationArea => 42i32,
            Self::EVRCCE_SnapNeckExitActivationArea => 43i32,
            Self::EVRCCE_TeleportStart => 44i32,
            Self::EVRCCE_TeleportEnd => 45i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigCustomEvent {
     const TYPE_ID: &str = "EVRConfigCustomEvent";
}

impl StaticVariant for Vec<EVRConfigCustomEvent> {
     const TYPE_ID: &str = "TArray<EVRConfigCustomEvent>";
}

impl StaticVariant for Vec<Vec<EVRConfigCustomEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigCustomEvent>>";
}

impl Variant for EVRConfigCustomEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigCustomEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigCustomEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigCustomEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigCustomEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigCustomEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigHeadAnchorMode {
    EVRCHAM_HeadBone,
    EVRCHAM_CapsuleBased,
    EVRCHAM_CapsuleFree,
    EVRCHAM_CapsuleGrid,
    EVRCHAM_LockPosition,
    EVRCHAM_KeepCurrent,
}

impl Aligned for EVRConfigHeadAnchorMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigHeadAnchorMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCHAM_HeadBone => 0i32,
            Self::EVRCHAM_CapsuleBased => 1i32,
            Self::EVRCHAM_CapsuleFree => 2i32,
            Self::EVRCHAM_CapsuleGrid => 3i32,
            Self::EVRCHAM_LockPosition => 4i32,
            Self::EVRCHAM_KeepCurrent => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigHeadAnchorMode {
     const TYPE_ID: &str = "EVRConfigHeadAnchorMode";
}

impl StaticVariant for Vec<EVRConfigHeadAnchorMode> {
     const TYPE_ID: &str = "TArray<EVRConfigHeadAnchorMode>";
}

impl StaticVariant for Vec<Vec<EVRConfigHeadAnchorMode>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigHeadAnchorMode>>";
}

impl Variant for EVRConfigHeadAnchorMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigHeadAnchorMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigHeadAnchorMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigHeadAnchorMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigHeadAnchorMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigHeadAnchorMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRConfigRotationType {
    EVRCRT_None,
    EVRCRT_Lock,
    EVRCRT_Offset,
}

impl Aligned for EVRConfigRotationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRConfigRotationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRCRT_None => 0i32,
            Self::EVRCRT_Lock => 1i32,
            Self::EVRCRT_Offset => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRConfigRotationType {
     const TYPE_ID: &str = "EVRConfigRotationType";
}

impl StaticVariant for Vec<EVRConfigRotationType> {
     const TYPE_ID: &str = "TArray<EVRConfigRotationType>";
}

impl StaticVariant for Vec<Vec<EVRConfigRotationType>> {
     const TYPE_ID: &str = "TArray<TArray<EVRConfigRotationType>>";
}

impl Variant for EVRConfigRotationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRConfigRotationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRConfigRotationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRConfigRotationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRConfigRotationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRConfigRotationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRHUDHandedness {
    ON_LEFT_HAND,
    ON_RIGHT_HAND,
}

impl Aligned for EVRHUDHandedness {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRHUDHandedness {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ON_LEFT_HAND => 0i32,
            Self::ON_RIGHT_HAND => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRHUDHandedness {
     const TYPE_ID: &str = "EVRHUDHandedness";
}

impl StaticVariant for Vec<EVRHUDHandedness> {
     const TYPE_ID: &str = "TArray<EVRHUDHandedness>";
}

impl StaticVariant for Vec<Vec<EVRHUDHandedness>> {
     const TYPE_ID: &str = "TArray<TArray<EVRHUDHandedness>>";
}

impl Variant for EVRHUDHandedness {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRHUDHandedness")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRHUDHandedness".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRHUDHandedness>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRHUDHandedness>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRHUDHandedness>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRIKElement {
    EVRIKE_LeftHand,
    EVRIKE_RightHand,
    EVRIKE_Pelvis,
    EVRIKE_Spine,
}

impl Aligned for EVRIKElement {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRIKElement {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRIKE_LeftHand => 0i32,
            Self::EVRIKE_RightHand => 1i32,
            Self::EVRIKE_Pelvis => 2i32,
            Self::EVRIKE_Spine => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRIKElement {
     const TYPE_ID: &str = "EVRIKElement";
}

impl StaticVariant for Vec<EVRIKElement> {
     const TYPE_ID: &str = "TArray<EVRIKElement>";
}

impl StaticVariant for Vec<Vec<EVRIKElement>> {
     const TYPE_ID: &str = "TArray<TArray<EVRIKElement>>";
}

impl Variant for EVRIKElement {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRIKElement")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRIKElement".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRIKElement>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRIKElement>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRIKElement>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRIKElementMode {
    EVRIKEM_Enabled,
    EVRIKEM_Disabled,
    EVRIKEM_KeepCurrent,
}

impl Aligned for EVRIKElementMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRIKElementMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVRIKEM_Enabled => 0i32,
            Self::EVRIKEM_Disabled => 1i32,
            Self::EVRIKEM_KeepCurrent => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRIKElementMode {
     const TYPE_ID: &str = "EVRIKElementMode";
}

impl StaticVariant for Vec<EVRIKElementMode> {
     const TYPE_ID: &str = "TArray<EVRIKElementMode>";
}

impl StaticVariant for Vec<Vec<EVRIKElementMode>> {
     const TYPE_ID: &str = "TArray<TArray<EVRIKElementMode>>";
}

impl Variant for EVRIKElementMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRIKElementMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRIKElementMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRIKElementMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRIKElementMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRIKElementMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRRenderDeviceType {
    RENDER_VR_DEVICE_TYPE_DUMMY,
    RENDER_VR_DEVICE_TYPE_OCULUS,
    RENDER_VR_DEVICE_TYPE_PSVR,
    RENDER_VR_DEVICE_TYPE_OPENVR,
    RENDER_VR_DEVICE_TYPE_COUNT,
}

impl Aligned for EVRRenderDeviceType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRRenderDeviceType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RENDER_VR_DEVICE_TYPE_DUMMY => 0i32,
            Self::RENDER_VR_DEVICE_TYPE_OCULUS => 1i32,
            Self::RENDER_VR_DEVICE_TYPE_PSVR => 2i32,
            Self::RENDER_VR_DEVICE_TYPE_OPENVR => 3i32,
            Self::RENDER_VR_DEVICE_TYPE_COUNT => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRRenderDeviceType {
     const TYPE_ID: &str = "EVRRenderDeviceType";
}

impl StaticVariant for Vec<EVRRenderDeviceType> {
     const TYPE_ID: &str = "TArray<EVRRenderDeviceType>";
}

impl StaticVariant for Vec<Vec<EVRRenderDeviceType>> {
     const TYPE_ID: &str = "TArray<TArray<EVRRenderDeviceType>>";
}

impl Variant for EVRRenderDeviceType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRRenderDeviceType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRRenderDeviceType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRRenderDeviceType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRRenderDeviceType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRRenderDeviceType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVRRenderingMode {
    VR_RENDER_MODE_2D_SCREEN,
    VR_RENDER_MODE_STEREO_3D,
}

impl Aligned for EVRRenderingMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVRRenderingMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::VR_RENDER_MODE_2D_SCREEN => 0i32,
            Self::VR_RENDER_MODE_STEREO_3D => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVRRenderingMode {
     const TYPE_ID: &str = "EVRRenderingMode";
}

impl StaticVariant for Vec<EVRRenderingMode> {
     const TYPE_ID: &str = "TArray<EVRRenderingMode>";
}

impl StaticVariant for Vec<Vec<EVRRenderingMode>> {
     const TYPE_ID: &str = "TArray<TArray<EVRRenderingMode>>";
}

impl Variant for EVRRenderingMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVRRenderingMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVRRenderingMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVRRenderingMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVRRenderingMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVRRenderingMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum EValueUpdateStrategy {
    UPDATE_STRATEGY_REPLACE,
    UPDATE_STRATEGY_ADD_TO,
    UPDATE_STRATEGY_MULTIPLY,
}

impl Aligned for EValueUpdateStrategy {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for EValueUpdateStrategy {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::UPDATE_STRATEGY_REPLACE => 0i8,
            Self::UPDATE_STRATEGY_ADD_TO => 1i8,
            Self::UPDATE_STRATEGY_MULTIPLY => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EValueUpdateStrategy {
     const TYPE_ID: &str = "EValueUpdateStrategy";
}

impl StaticVariant for Vec<EValueUpdateStrategy> {
     const TYPE_ID: &str = "TArray<EValueUpdateStrategy>";
}

impl StaticVariant for Vec<Vec<EValueUpdateStrategy>> {
     const TYPE_ID: &str = "TArray<TArray<EValueUpdateStrategy>>";
}

impl Variant for EValueUpdateStrategy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EValueUpdateStrategy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EValueUpdateStrategy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EValueUpdateStrategy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EValueUpdateStrategy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EValueUpdateStrategy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVictimMovementType {
    eVictimMovementNone,
    eVictimMovementPullVictimFromWindow,
    eVictimMovementThrowBodyOverRail,
    eVictimMovementDumpBodyOverLedge,
    eVictimMovementTakeDown,
    eVictimMovementRecoveryFinisher,
    eVictimMovementGrabVictim,
    eVictimMovementPushVictimThroughWindowAndRail,
    eVictimMovementContextKill,
    eVictimMovementKickVictimOverLedge,
    eVictimMovementCoupDeGrace,
    eVictimMovementCloseCombat,
    eVictimMovementLast,
}

impl Aligned for EVictimMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVictimMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eVictimMovementNone => -1i32,
            Self::eVictimMovementPullVictimFromWindow => 0i32,
            Self::eVictimMovementThrowBodyOverRail => 1i32,
            Self::eVictimMovementDumpBodyOverLedge => 2i32,
            Self::eVictimMovementTakeDown => 3i32,
            Self::eVictimMovementRecoveryFinisher => 4i32,
            Self::eVictimMovementGrabVictim => 5i32,
            Self::eVictimMovementPushVictimThroughWindowAndRail => 6i32,
            Self::eVictimMovementContextKill => 7i32,
            Self::eVictimMovementKickVictimOverLedge => 8i32,
            Self::eVictimMovementCoupDeGrace => 9i32,
            Self::eVictimMovementCloseCombat => 10i32,
            Self::eVictimMovementLast => 11i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVictimMovementType {
     const TYPE_ID: &str = "EVictimMovementType";
}

impl StaticVariant for Vec<EVictimMovementType> {
     const TYPE_ID: &str = "TArray<EVictimMovementType>";
}

impl StaticVariant for Vec<Vec<EVictimMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<EVictimMovementType>>";
}

impl Variant for EVictimMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVictimMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVictimMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVictimMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVictimMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVictimMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EViewportLock {
    VPL_None,
    VPL_Rectangular,
    VPL_Rectangular_AvoidMinimapOverlap,
}

impl Aligned for EViewportLock {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EViewportLock {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::VPL_None => 0i32,
            Self::VPL_Rectangular => 1i32,
            Self::VPL_Rectangular_AvoidMinimapOverlap => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EViewportLock {
     const TYPE_ID: &str = "EViewportLock";
}

impl StaticVariant for Vec<EViewportLock> {
     const TYPE_ID: &str = "TArray<EViewportLock>";
}

impl StaticVariant for Vec<Vec<EViewportLock>> {
     const TYPE_ID: &str = "TArray<TArray<EViewportLock>>";
}

impl Variant for EViewportLock {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EViewportLock")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EViewportLock".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EViewportLock>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EViewportLock>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EViewportLock>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVirtualPlatformID {
    DEFAULT,
    PC,
    PC_ENHANCED,
    PS4,
    PS4_PRO,
    XBONE,
    XBONE_X,
    STADIA,
    PS5,
    XBSCARLETT,
    XBSCARLETT_ANACONDA,
    VR,
    VR_PC,
    VR_PS4,
    VR_PS4_PRO,
    VR_PS5,
    __SUB,
    __BASE,
    __SYSTEM,
}

impl Aligned for EVirtualPlatformID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVirtualPlatformID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DEFAULT => 0i32,
            Self::PC => 256i32,
            Self::PC_ENHANCED => 257i32,
            Self::PS4 => 512i32,
            Self::PS4_PRO => 513i32,
            Self::XBONE => 768i32,
            Self::XBONE_X => 769i32,
            Self::STADIA => 1024i32,
            Self::PS5 => 1280i32,
            Self::XBSCARLETT => 1536i32,
            Self::XBSCARLETT_ANACONDA => 1537i32,
            Self::VR => 65536i32,
            Self::VR_PC => 65792i32,
            Self::VR_PS4 => 66048i32,
            Self::VR_PS4_PRO => 66049i32,
            Self::VR_PS5 => 66816i32,
            Self::__SUB => 255i32,
            Self::__BASE => 65280i32,
            Self::__SYSTEM => 16711680i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVirtualPlatformID {
     const TYPE_ID: &str = "EVirtualPlatformID";
}

impl StaticVariant for Vec<EVirtualPlatformID> {
     const TYPE_ID: &str = "TArray<EVirtualPlatformID>";
}

impl StaticVariant for Vec<Vec<EVirtualPlatformID>> {
     const TYPE_ID: &str = "TArray<TArray<EVirtualPlatformID>>";
}

impl Variant for EVirtualPlatformID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVirtualPlatformID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVirtualPlatformID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVirtualPlatformID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVirtualPlatformID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVirtualPlatformID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVolumeTriggerEntityTypeFlags {
    VTET_Hitman,
    VTET_ActorAlive,
    VTET_ActorDead,
    VTET_ActorPacified,
    VTET_ThrownItem,
    VTET_Spatial,
    VTET_SoundSweetener,
    VTET_ExplodeableItem,
    VTET_Item,
    VTET_SpatialVisible,
}

impl Aligned for EVolumeTriggerEntityTypeFlags {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVolumeTriggerEntityTypeFlags {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::VTET_Hitman => 1i32,
            Self::VTET_ActorAlive => 2i32,
            Self::VTET_ActorDead => 4i32,
            Self::VTET_ActorPacified => 8i32,
            Self::VTET_ThrownItem => 16i32,
            Self::VTET_Spatial => 32i32,
            Self::VTET_SoundSweetener => 64i32,
            Self::VTET_ExplodeableItem => 128i32,
            Self::VTET_Item => 256i32,
            Self::VTET_SpatialVisible => 512i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVolumeTriggerEntityTypeFlags {
     const TYPE_ID: &str = "EVolumeTriggerEntityTypeFlags";
}

impl StaticVariant for Vec<EVolumeTriggerEntityTypeFlags> {
     const TYPE_ID: &str = "TArray<EVolumeTriggerEntityTypeFlags>";
}

impl StaticVariant for Vec<Vec<EVolumeTriggerEntityTypeFlags>> {
     const TYPE_ID: &str = "TArray<TArray<EVolumeTriggerEntityTypeFlags>>";
}

impl Variant for EVolumeTriggerEntityTypeFlags {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVolumeTriggerEntityTypeFlags")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVolumeTriggerEntityTypeFlags".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVolumeTriggerEntityTypeFlags>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVolumeTriggerEntityTypeFlags>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVolumeTriggerEntityTypeFlags>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EVsGenericEvent {
    eVSGE_MATCH_WON,
    eVSGE_MATCH_LOST,
    eVSGE_MATCH_DRAW,
    eVSGE_TARGET_LEAVING,
    eVSGE_TARGET_LEFT,
    eVSGE_TARGET_ARRIVING,
    eVSGE_TARGET_ARRIVED,
    eVSGE_RESPAWNED,
    eVSGE_OPPONENT_DEAD,
    eVSGE_OPPONENT_RESPAWNED,
    eVSGE_OPPONENT_GOT_WEAPON,
    eVSGE_OPPONENT_GOT_ITEM,
    eVSGE_OPPONENT_DISGUISED,
    eVSGE_TARGET_MISSED,
    eVSGE_NEXT_TARGET_MISSED,
    eVSGE_OPPONENT_TARGET_MISSED,
    eVSGE_OPPONENT_NEXT_TARGET_MISSED,
    eVSGE_OPPONENT_FAR_FROM_TARGET,
    eVSGE_OPPONENT_CLOSE_FROM_TARGET,
    eVSGE_OPPONENT_SCOPES_TARGET,
    eVSGE_MAX,
}

impl Aligned for EVsGenericEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EVsGenericEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eVSGE_MATCH_WON => 0i32,
            Self::eVSGE_MATCH_LOST => 1i32,
            Self::eVSGE_MATCH_DRAW => 2i32,
            Self::eVSGE_TARGET_LEAVING => 3i32,
            Self::eVSGE_TARGET_LEFT => 4i32,
            Self::eVSGE_TARGET_ARRIVING => 5i32,
            Self::eVSGE_TARGET_ARRIVED => 6i32,
            Self::eVSGE_RESPAWNED => 7i32,
            Self::eVSGE_OPPONENT_DEAD => 8i32,
            Self::eVSGE_OPPONENT_RESPAWNED => 9i32,
            Self::eVSGE_OPPONENT_GOT_WEAPON => 10i32,
            Self::eVSGE_OPPONENT_GOT_ITEM => 11i32,
            Self::eVSGE_OPPONENT_DISGUISED => 12i32,
            Self::eVSGE_TARGET_MISSED => 13i32,
            Self::eVSGE_NEXT_TARGET_MISSED => 14i32,
            Self::eVSGE_OPPONENT_TARGET_MISSED => 15i32,
            Self::eVSGE_OPPONENT_NEXT_TARGET_MISSED => 16i32,
            Self::eVSGE_OPPONENT_FAR_FROM_TARGET => 17i32,
            Self::eVSGE_OPPONENT_CLOSE_FROM_TARGET => 18i32,
            Self::eVSGE_OPPONENT_SCOPES_TARGET => 19i32,
            Self::eVSGE_MAX => 20i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EVsGenericEvent {
     const TYPE_ID: &str = "EVsGenericEvent";
}

impl StaticVariant for Vec<EVsGenericEvent> {
     const TYPE_ID: &str = "TArray<EVsGenericEvent>";
}

impl StaticVariant for Vec<Vec<EVsGenericEvent>> {
     const TYPE_ID: &str = "TArray<TArray<EVsGenericEvent>>";
}

impl Variant for EVsGenericEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EVsGenericEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EVsGenericEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EVsGenericEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EVsGenericEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EVsGenericEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EWaypointRotationAlignment {
    RA_NONE,
    RA_LOOSE,
    RA_EXACT,
}

impl Aligned for EWaypointRotationAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EWaypointRotationAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RA_NONE => 0i32,
            Self::RA_LOOSE => 1i32,
            Self::RA_EXACT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EWaypointRotationAlignment {
     const TYPE_ID: &str = "EWaypointRotationAlignment";
}

impl StaticVariant for Vec<EWaypointRotationAlignment> {
     const TYPE_ID: &str = "TArray<EWaypointRotationAlignment>";
}

impl StaticVariant for Vec<Vec<EWaypointRotationAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<EWaypointRotationAlignment>>";
}

impl Variant for EWaypointRotationAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EWaypointRotationAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EWaypointRotationAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EWaypointRotationAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EWaypointRotationAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EWaypointRotationAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EWeaponAnimationCategory {
    eWAC_Undefined,
    eWAC_Pistol,
    eWAC_Revolver,
    eWAC_SMG_2H,
    eWAC_SMG_1H,
    eWAC_Rifle,
    eWAC_Sniper,
    eWAC_Shotgun_Pump,
    eWAC_Shotgun_Semi,
}

impl Aligned for EWeaponAnimationCategory {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EWeaponAnimationCategory {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWAC_Undefined => 0i32,
            Self::eWAC_Pistol => 1i32,
            Self::eWAC_Revolver => 2i32,
            Self::eWAC_SMG_2H => 3i32,
            Self::eWAC_SMG_1H => 4i32,
            Self::eWAC_Rifle => 5i32,
            Self::eWAC_Sniper => 6i32,
            Self::eWAC_Shotgun_Pump => 7i32,
            Self::eWAC_Shotgun_Semi => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EWeaponAnimationCategory {
     const TYPE_ID: &str = "EWeaponAnimationCategory";
}

impl StaticVariant for Vec<EWeaponAnimationCategory> {
     const TYPE_ID: &str = "TArray<EWeaponAnimationCategory>";
}

impl StaticVariant for Vec<Vec<EWeaponAnimationCategory>> {
     const TYPE_ID: &str = "TArray<TArray<EWeaponAnimationCategory>>";
}

impl Variant for EWeaponAnimationCategory {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EWeaponAnimationCategory")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EWeaponAnimationCategory".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EWeaponAnimationCategory>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EWeaponAnimationCategory>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EWeaponAnimationCategory>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EWeaponSpecialSituation {
    WSS_NORMAL,
    WSS_BAREHANDS,
    WSS_EXPLOSION,
    WSS_ACCIDENT,
    WSS_NPC_FRIENDLY_FIRE,
    WSS_EXECUTE_PISTOL,
    WSS_ANY_WEAPON,
    WSS_INVISIBLE,
}

impl Aligned for EWeaponSpecialSituation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EWeaponSpecialSituation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WSS_NORMAL => 0i32,
            Self::WSS_BAREHANDS => 1i32,
            Self::WSS_EXPLOSION => 2i32,
            Self::WSS_ACCIDENT => 3i32,
            Self::WSS_NPC_FRIENDLY_FIRE => 4i32,
            Self::WSS_EXECUTE_PISTOL => 5i32,
            Self::WSS_ANY_WEAPON => 6i32,
            Self::WSS_INVISIBLE => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EWeaponSpecialSituation {
     const TYPE_ID: &str = "EWeaponSpecialSituation";
}

impl StaticVariant for Vec<EWeaponSpecialSituation> {
     const TYPE_ID: &str = "TArray<EWeaponSpecialSituation>";
}

impl StaticVariant for Vec<Vec<EWeaponSpecialSituation>> {
     const TYPE_ID: &str = "TArray<TArray<EWeaponSpecialSituation>>";
}

impl Variant for EWeaponSpecialSituation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EWeaponSpecialSituation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EWeaponSpecialSituation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EWeaponSpecialSituation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EWeaponSpecialSituation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EWeaponSpecialSituation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EWeaponUpgradeIcon {
    WEAPON_UPGRADE_ICON_NONE,
    WEAPON_UPGRADE_ICON_SILENCER,
    WEAPON_UPGRADE_ICON_RED_DOT_SIGHT,
    WEAPON_UPGRADE_ICON_AMMUNITION,
    WEAPON_UPGRADE_ICON_MAGAZINE,
    WEAPON_UPGRADE_ICON_EXTCLIP,
    WEAPON_UPGRADE_ICON_SHELLS,
    WEAPON_UPGRADE_ICON_SLIDE,
    WEAPON_UPGRADE_ICON_BOLT,
    WEAPON_UPGRADE_ICON_BARREL,
    WEAPON_UPGRADE_ICON_HAMMER,
    WEAPON_UPGRADE_ICON_CHUTE,
    WEAPON_UPGRADE_ICON_DUALWIELD,
    WEAPON_UPGRADE_ICON_MAGNUM,
    WEAPON_UPGRADE_ICON_STOCK,
}

impl Aligned for EWeaponUpgradeIcon {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EWeaponUpgradeIcon {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WEAPON_UPGRADE_ICON_NONE => 0i32,
            Self::WEAPON_UPGRADE_ICON_SILENCER => 1i32,
            Self::WEAPON_UPGRADE_ICON_RED_DOT_SIGHT => 2i32,
            Self::WEAPON_UPGRADE_ICON_AMMUNITION => 3i32,
            Self::WEAPON_UPGRADE_ICON_MAGAZINE => 4i32,
            Self::WEAPON_UPGRADE_ICON_EXTCLIP => 5i32,
            Self::WEAPON_UPGRADE_ICON_SHELLS => 6i32,
            Self::WEAPON_UPGRADE_ICON_SLIDE => 7i32,
            Self::WEAPON_UPGRADE_ICON_BOLT => 8i32,
            Self::WEAPON_UPGRADE_ICON_BARREL => 9i32,
            Self::WEAPON_UPGRADE_ICON_HAMMER => 10i32,
            Self::WEAPON_UPGRADE_ICON_CHUTE => 11i32,
            Self::WEAPON_UPGRADE_ICON_DUALWIELD => 12i32,
            Self::WEAPON_UPGRADE_ICON_MAGNUM => 13i32,
            Self::WEAPON_UPGRADE_ICON_STOCK => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EWeaponUpgradeIcon {
     const TYPE_ID: &str = "EWeaponUpgradeIcon";
}

impl StaticVariant for Vec<EWeaponUpgradeIcon> {
     const TYPE_ID: &str = "TArray<EWeaponUpgradeIcon>";
}

impl StaticVariant for Vec<Vec<EWeaponUpgradeIcon>> {
     const TYPE_ID: &str = "TArray<TArray<EWeaponUpgradeIcon>>";
}

impl Variant for EWeaponUpgradeIcon {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EWeaponUpgradeIcon")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EWeaponUpgradeIcon".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EWeaponUpgradeIcon>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EWeaponUpgradeIcon>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EWeaponUpgradeIcon>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum EWeaponUpgradeUse {
    eWUU_PrimaryOnly,
    eWUU_SecondaryOnly,
    eWUU_AllFireModes,
}

impl Aligned for EWeaponUpgradeUse {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for EWeaponUpgradeUse {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWUU_PrimaryOnly => 0i32,
            Self::eWUU_SecondaryOnly => 1i32,
            Self::eWUU_AllFireModes => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for EWeaponUpgradeUse {
     const TYPE_ID: &str = "EWeaponUpgradeUse";
}

impl StaticVariant for Vec<EWeaponUpgradeUse> {
     const TYPE_ID: &str = "TArray<EWeaponUpgradeUse>";
}

impl StaticVariant for Vec<Vec<EWeaponUpgradeUse>> {
     const TYPE_ID: &str = "TArray<TArray<EWeaponUpgradeUse>>";
}

impl Variant for EWeaponUpgradeUse {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("EWeaponUpgradeUse")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("EWeaponUpgradeUse".into()))
    }
}

inventory::submit!(&VariantDeserializer::<EWeaponUpgradeUse>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<EWeaponUpgradeUse>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<EWeaponUpgradeUse>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum GameLobbyState {
    GLS_None,
    GLS_InHud,
    GLS_CreatingLobby,
    GLS_JoiningLobby,
    GLS_ConnectToLobby,
    GLS_ConnectingLobby,
    GLS_InLobby,
    GLS_LeavingLobby,
    GLS_InGame,
}

impl Aligned for GameLobbyState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for GameLobbyState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GLS_None => 0i32,
            Self::GLS_InHud => 1i32,
            Self::GLS_CreatingLobby => 2i32,
            Self::GLS_JoiningLobby => 3i32,
            Self::GLS_ConnectToLobby => 4i32,
            Self::GLS_ConnectingLobby => 5i32,
            Self::GLS_InLobby => 6i32,
            Self::GLS_LeavingLobby => 7i32,
            Self::GLS_InGame => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for GameLobbyState {
     const TYPE_ID: &str = "GameLobbyState";
}

impl StaticVariant for Vec<GameLobbyState> {
     const TYPE_ID: &str = "TArray<GameLobbyState>";
}

impl StaticVariant for Vec<Vec<GameLobbyState>> {
     const TYPE_ID: &str = "TArray<TArray<GameLobbyState>>";
}

impl Variant for GameLobbyState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("GameLobbyState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("GameLobbyState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<GameLobbyState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<GameLobbyState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<GameLobbyState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ICameraEntity_EProjectionType {
    ePerspectiveRH,
    eOrtogonalRH,
    eCustom,
}

impl Aligned for ICameraEntity_EProjectionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ICameraEntity_EProjectionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ePerspectiveRH => 0i32,
            Self::eOrtogonalRH => 1i32,
            Self::eCustom => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ICameraEntity_EProjectionType {
     const TYPE_ID: &str = "ICameraEntity_EProjectionType";
}

impl StaticVariant for Vec<ICameraEntity_EProjectionType> {
     const TYPE_ID: &str = "TArray<ICameraEntity_EProjectionType>";
}

impl StaticVariant for Vec<Vec<ICameraEntity_EProjectionType>> {
     const TYPE_ID: &str = "TArray<TArray<ICameraEntity_EProjectionType>>";
}

impl Variant for ICameraEntity_EProjectionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ICameraEntity_EProjectionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ICameraEntity_EProjectionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ICameraEntity_EProjectionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ICameraEntity_EProjectionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ICameraEntity_EProjectionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ICloset_EClosetType {
    eTypeClosetNormal,
    eTypeClosetCake,
    eTypeClosetDumpster,
    eTypeClosetLast,
}

impl Aligned for ICloset_EClosetType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ICloset_EClosetType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTypeClosetNormal => 0i32,
            Self::eTypeClosetCake => 1i32,
            Self::eTypeClosetDumpster => 2i32,
            Self::eTypeClosetLast => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ICloset_EClosetType {
     const TYPE_ID: &str = "ICloset_EClosetType";
}

impl StaticVariant for Vec<ICloset_EClosetType> {
     const TYPE_ID: &str = "TArray<ICloset_EClosetType>";
}

impl StaticVariant for Vec<Vec<ICloset_EClosetType>> {
     const TYPE_ID: &str = "TArray<TArray<ICloset_EClosetType>>";
}

impl Variant for ICloset_EClosetType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ICloset_EClosetType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ICloset_EClosetType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ICloset_EClosetType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ICloset_EClosetType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ICloset_EClosetType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractEvaluationContextListener_EListenerType {
    eDEFAULT,
    eOBJECTIVECOUNTER,
    eFORCEUPDATE,
    eCUSTOM,
    eINTERNAL,
    eCHALLENGECOUNTER,
    eCHALLENGETREE,
    eTOGGLE,
    eMATCHARRAYS,
}

impl Aligned for IContractEvaluationContextListener_EListenerType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractEvaluationContextListener_EListenerType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDEFAULT => 0i32,
            Self::eOBJECTIVECOUNTER => 1i32,
            Self::eFORCEUPDATE => 2i32,
            Self::eCUSTOM => 3i32,
            Self::eINTERNAL => 4i32,
            Self::eCHALLENGECOUNTER => 5i32,
            Self::eCHALLENGETREE => 6i32,
            Self::eTOGGLE => 7i32,
            Self::eMATCHARRAYS => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractEvaluationContextListener_EListenerType {
     const TYPE_ID: &str = "IContractEvaluationContextListener_EListenerType";
}

impl StaticVariant for Vec<IContractEvaluationContextListener_EListenerType> {
     const TYPE_ID: &str = "TArray<IContractEvaluationContextListener_EListenerType>";
}

impl StaticVariant for Vec<Vec<IContractEvaluationContextListener_EListenerType>> {
     const TYPE_ID: &str = "TArray<TArray<IContractEvaluationContextListener_EListenerType>>";
}

impl Variant for IContractEvaluationContextListener_EListenerType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractEvaluationContextListener_EListenerType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractEvaluationContextListener_EListenerType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractEvaluationContextListener_EListenerType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractEvaluationContextListener_EListenerType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractEvaluationContextListener_EListenerType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractObjective_Category {
    PRIMARY,
    SECONDARY,
    CONDITION,
}

impl Aligned for IContractObjective_Category {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractObjective_Category {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PRIMARY => 0i32,
            Self::SECONDARY => 1i32,
            Self::CONDITION => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractObjective_Category {
     const TYPE_ID: &str = "IContractObjective_Category";
}

impl StaticVariant for Vec<IContractObjective_Category> {
     const TYPE_ID: &str = "TArray<IContractObjective_Category>";
}

impl StaticVariant for Vec<Vec<IContractObjective_Category>> {
     const TYPE_ID: &str = "TArray<TArray<IContractObjective_Category>>";
}

impl Variant for IContractObjective_Category {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractObjective_Category")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractObjective_Category".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractObjective_Category>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractObjective_Category>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractObjective_Category>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractObjective_ObjectiveType {
    KILL,
    SETPIECE,
    CUSTOMKILL,
    CUSTOM,
}

impl Aligned for IContractObjective_ObjectiveType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractObjective_ObjectiveType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::KILL => 0i32,
            Self::SETPIECE => 1i32,
            Self::CUSTOMKILL => 2i32,
            Self::CUSTOM => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractObjective_ObjectiveType {
     const TYPE_ID: &str = "IContractObjective_ObjectiveType";
}

impl StaticVariant for Vec<IContractObjective_ObjectiveType> {
     const TYPE_ID: &str = "TArray<IContractObjective_ObjectiveType>";
}

impl StaticVariant for Vec<Vec<IContractObjective_ObjectiveType>> {
     const TYPE_ID: &str = "TArray<TArray<IContractObjective_ObjectiveType>>";
}

impl Variant for IContractObjective_ObjectiveType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractObjective_ObjectiveType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractObjective_ObjectiveType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractObjective_ObjectiveType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractObjective_ObjectiveType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractObjective_ObjectiveType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractObjective_SCounterData_ECounterType {
    eDEFAULT,
    ePERCENTAGE,
}

impl Aligned for IContractObjective_SCounterData_ECounterType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractObjective_SCounterData_ECounterType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDEFAULT => 0i32,
            Self::ePERCENTAGE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractObjective_SCounterData_ECounterType {
     const TYPE_ID: &str = "IContractObjective_SCounterData_ECounterType";
}

impl StaticVariant for Vec<IContractObjective_SCounterData_ECounterType> {
     const TYPE_ID: &str = "TArray<IContractObjective_SCounterData_ECounterType>";
}

impl StaticVariant for Vec<Vec<IContractObjective_SCounterData_ECounterType>> {
     const TYPE_ID: &str = "TArray<TArray<IContractObjective_SCounterData_ECounterType>>";
}

impl Variant for IContractObjective_SCounterData_ECounterType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractObjective_SCounterData_ECounterType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractObjective_SCounterData_ECounterType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractObjective_SCounterData_ECounterType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractObjective_SCounterData_ECounterType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractObjective_SCounterData_ECounterType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractObjective_State {
    IN_PROGRESS,
    COMPLETED,
    FAILED,
}

impl Aligned for IContractObjective_State {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractObjective_State {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IN_PROGRESS => 0i32,
            Self::COMPLETED => 1i32,
            Self::FAILED => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractObjective_State {
     const TYPE_ID: &str = "IContractObjective_State";
}

impl StaticVariant for Vec<IContractObjective_State> {
     const TYPE_ID: &str = "TArray<IContractObjective_State>";
}

impl StaticVariant for Vec<Vec<IContractObjective_State>> {
     const TYPE_ID: &str = "TArray<TArray<IContractObjective_State>>";
}

impl Variant for IContractObjective_State {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractObjective_State")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractObjective_State".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractObjective_State>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractObjective_State>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractObjective_State>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IContractObjective_Type {
    CONTRACT_OBJ_EVENT_BASED,
    CONTRACT_OBJ_SM_BASED,
}

impl Aligned for IContractObjective_Type {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IContractObjective_Type {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CONTRACT_OBJ_EVENT_BASED => 0i32,
            Self::CONTRACT_OBJ_SM_BASED => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IContractObjective_Type {
     const TYPE_ID: &str = "IContractObjective_Type";
}

impl StaticVariant for Vec<IContractObjective_Type> {
     const TYPE_ID: &str = "TArray<IContractObjective_Type>";
}

impl StaticVariant for Vec<Vec<IContractObjective_Type>> {
     const TYPE_ID: &str = "TArray<TArray<IContractObjective_Type>>";
}

impl Variant for IContractObjective_Type {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IContractObjective_Type")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IContractObjective_Type".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IContractObjective_Type>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IContractObjective_Type>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IContractObjective_Type>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IEvergreenTerritoryDefinition_EDestination {
    AmbroseIsland,
    Bangkok,
    Berlin,
    Chongqing,
    Colorado,
    Dartmoor,
    Dubai,
    HavenIsland,
    HawkesBay,
    Hokkaido,
    IsleOfSgail,
    Marrakesh,
    Mendoza,
    Miami,
    Mumbai,
    NewYork,
    Paris,
    SantaFortuna,
    Sapienza,
    WhittletonCreek,
}

impl Aligned for IEvergreenTerritoryDefinition_EDestination {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IEvergreenTerritoryDefinition_EDestination {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AmbroseIsland => 0i32,
            Self::Bangkok => 1i32,
            Self::Berlin => 2i32,
            Self::Chongqing => 3i32,
            Self::Colorado => 4i32,
            Self::Dartmoor => 5i32,
            Self::Dubai => 6i32,
            Self::HavenIsland => 7i32,
            Self::HawkesBay => 8i32,
            Self::Hokkaido => 9i32,
            Self::IsleOfSgail => 10i32,
            Self::Marrakesh => 11i32,
            Self::Mendoza => 12i32,
            Self::Miami => 13i32,
            Self::Mumbai => 14i32,
            Self::NewYork => 15i32,
            Self::Paris => 16i32,
            Self::SantaFortuna => 17i32,
            Self::Sapienza => 18i32,
            Self::WhittletonCreek => 19i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IEvergreenTerritoryDefinition_EDestination {
     const TYPE_ID: &str = "IEvergreenTerritoryDefinition_EDestination";
}

impl StaticVariant for Vec<IEvergreenTerritoryDefinition_EDestination> {
     const TYPE_ID: &str = "TArray<IEvergreenTerritoryDefinition_EDestination>";
}

impl StaticVariant for Vec<Vec<IEvergreenTerritoryDefinition_EDestination>> {
     const TYPE_ID: &str = "TArray<TArray<IEvergreenTerritoryDefinition_EDestination>>";
}

impl Variant for IEvergreenTerritoryDefinition_EDestination {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IEvergreenTerritoryDefinition_EDestination")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IEvergreenTerritoryDefinition_EDestination".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IEvergreenTerritoryDefinition_EDestination>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IEvergreenTerritoryDefinition_EDestination>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IEvergreenTerritoryDefinition_EDestination>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IEvergreenTerritoryStatus_EVisited {
    NotVisited,
    VisitedAndWon,
    VisitedAndLost,
}

impl Aligned for IEvergreenTerritoryStatus_EVisited {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IEvergreenTerritoryStatus_EVisited {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NotVisited => 0i32,
            Self::VisitedAndWon => 1i32,
            Self::VisitedAndLost => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IEvergreenTerritoryStatus_EVisited {
     const TYPE_ID: &str = "IEvergreenTerritoryStatus_EVisited";
}

impl StaticVariant for Vec<IEvergreenTerritoryStatus_EVisited> {
     const TYPE_ID: &str = "TArray<IEvergreenTerritoryStatus_EVisited>";
}

impl StaticVariant for Vec<Vec<IEvergreenTerritoryStatus_EVisited>> {
     const TYPE_ID: &str = "TArray<TArray<IEvergreenTerritoryStatus_EVisited>>";
}

impl Variant for IEvergreenTerritoryStatus_EVisited {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IEvergreenTerritoryStatus_EVisited")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IEvergreenTerritoryStatus_EVisited".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IEvergreenTerritoryStatus_EVisited>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IEvergreenTerritoryStatus_EVisited>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IEvergreenTerritoryStatus_EVisited>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IHM5Door_ECPDoorLockType {
    CPDLT_NORMAL_LOCK,
    CPDLT_PUSH_BAR_PAD_LOCK,
}

impl Aligned for IHM5Door_ECPDoorLockType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IHM5Door_ECPDoorLockType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CPDLT_NORMAL_LOCK => 0i32,
            Self::CPDLT_PUSH_BAR_PAD_LOCK => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IHM5Door_ECPDoorLockType {
     const TYPE_ID: &str = "IHM5Door_ECPDoorLockType";
}

impl StaticVariant for Vec<IHM5Door_ECPDoorLockType> {
     const TYPE_ID: &str = "TArray<IHM5Door_ECPDoorLockType>";
}

impl StaticVariant for Vec<Vec<IHM5Door_ECPDoorLockType>> {
     const TYPE_ID: &str = "TArray<TArray<IHM5Door_ECPDoorLockType>>";
}

impl Variant for IHM5Door_ECPDoorLockType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IHM5Door_ECPDoorLockType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IHM5Door_ECPDoorLockType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IHM5Door_ECPDoorLockType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IHM5Door_ECPDoorLockType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IHM5Door_ECPDoorLockType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IHM5Door_EInitialState {
    IS_CLOSED,
    IS_OPEN,
    IS_OPEN_IN,
    IS_OPEN_OUT,
}

impl Aligned for IHM5Door_EInitialState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IHM5Door_EInitialState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IS_CLOSED => 0i32,
            Self::IS_OPEN => 1i32,
            Self::IS_OPEN_IN => 2i32,
            Self::IS_OPEN_OUT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IHM5Door_EInitialState {
     const TYPE_ID: &str = "IHM5Door_EInitialState";
}

impl StaticVariant for Vec<IHM5Door_EInitialState> {
     const TYPE_ID: &str = "TArray<IHM5Door_EInitialState>";
}

impl StaticVariant for Vec<Vec<IHM5Door_EInitialState>> {
     const TYPE_ID: &str = "TArray<TArray<IHM5Door_EInitialState>>";
}

impl Variant for IHM5Door_EInitialState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IHM5Door_EInitialState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IHM5Door_EInitialState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IHM5Door_EInitialState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IHM5Door_EInitialState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IHM5Door_EInitialState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IHM5Door_EOpenDir {
    OD_AWAY,
    OD_TOWARS,
    OD_IN,
    OD_OUT,
}

impl Aligned for IHM5Door_EOpenDir {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IHM5Door_EOpenDir {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OD_AWAY => 0i32,
            Self::OD_TOWARS => 1i32,
            Self::OD_IN => 2i32,
            Self::OD_OUT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IHM5Door_EOpenDir {
     const TYPE_ID: &str = "IHM5Door_EOpenDir";
}

impl StaticVariant for Vec<IHM5Door_EOpenDir> {
     const TYPE_ID: &str = "TArray<IHM5Door_EOpenDir>";
}

impl StaticVariant for Vec<Vec<IHM5Door_EOpenDir>> {
     const TYPE_ID: &str = "TArray<TArray<IHM5Door_EOpenDir>>";
}

impl Variant for IHM5Door_EOpenDir {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IHM5Door_EOpenDir")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IHM5Door_EOpenDir".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IHM5Door_EOpenDir>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IHM5Door_EOpenDir>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IHM5Door_EOpenDir>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IHM5Door_EOpenMode {
    OM_TWO_WAY,
    OM_OPEN_POS_SIDE_ONLY,
    OM_OPEN_NEG_SIDE_ONLY,
    OM_DISABLED,
}

impl Aligned for IHM5Door_EOpenMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IHM5Door_EOpenMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OM_TWO_WAY => 0i32,
            Self::OM_OPEN_POS_SIDE_ONLY => 1i32,
            Self::OM_OPEN_NEG_SIDE_ONLY => 2i32,
            Self::OM_DISABLED => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IHM5Door_EOpenMode {
     const TYPE_ID: &str = "IHM5Door_EOpenMode";
}

impl StaticVariant for Vec<IHM5Door_EOpenMode> {
     const TYPE_ID: &str = "TArray<IHM5Door_EOpenMode>";
}

impl StaticVariant for Vec<Vec<IHM5Door_EOpenMode>> {
     const TYPE_ID: &str = "TArray<TArray<IHM5Door_EOpenMode>>";
}

impl Variant for IHM5Door_EOpenMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IHM5Door_EOpenMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IHM5Door_EOpenMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IHM5Door_EOpenMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IHM5Door_EOpenMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IHM5Door_EOpenMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IHM5Door_eCloseMode {
    CM_AUTOCLOSE,
    CM_MANUALCLOSE,
    CM_NEVERCLOSE,
}

impl Aligned for IHM5Door_eCloseMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IHM5Door_eCloseMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CM_AUTOCLOSE => 0i32,
            Self::CM_MANUALCLOSE => 1i32,
            Self::CM_NEVERCLOSE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IHM5Door_eCloseMode {
     const TYPE_ID: &str = "IHM5Door_eCloseMode";
}

impl StaticVariant for Vec<IHM5Door_eCloseMode> {
     const TYPE_ID: &str = "TArray<IHM5Door_eCloseMode>";
}

impl StaticVariant for Vec<Vec<IHM5Door_eCloseMode>> {
     const TYPE_ID: &str = "TArray<TArray<IHM5Door_eCloseMode>>";
}

impl Variant for IHM5Door_eCloseMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IHM5Door_eCloseMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IHM5Door_eCloseMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IHM5Door_eCloseMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IHM5Door_eCloseMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IHM5Door_eCloseMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IItemWeapon_EDeadlyThrowType {
    DEADLYTHROW_NONE,
    DEADLYTHROW_LIGHT,
    DEADLYTHROW_HEAVY,
}

impl Aligned for IItemWeapon_EDeadlyThrowType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IItemWeapon_EDeadlyThrowType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DEADLYTHROW_NONE => 0i32,
            Self::DEADLYTHROW_LIGHT => 1i32,
            Self::DEADLYTHROW_HEAVY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IItemWeapon_EDeadlyThrowType {
     const TYPE_ID: &str = "IItemWeapon_EDeadlyThrowType";
}

impl StaticVariant for Vec<IItemWeapon_EDeadlyThrowType> {
     const TYPE_ID: &str = "TArray<IItemWeapon_EDeadlyThrowType>";
}

impl StaticVariant for Vec<Vec<IItemWeapon_EDeadlyThrowType>> {
     const TYPE_ID: &str = "TArray<TArray<IItemWeapon_EDeadlyThrowType>>";
}

impl Variant for IItemWeapon_EDeadlyThrowType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IItemWeapon_EDeadlyThrowType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IItemWeapon_EDeadlyThrowType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IItemWeapon_EDeadlyThrowType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IItemWeapon_EDeadlyThrowType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IItemWeapon_EDeadlyThrowType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ILightEntity_EFrameIndexStrategy {
    WRAP,
    CLAMP,
}

impl Aligned for ILightEntity_EFrameIndexStrategy {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ILightEntity_EFrameIndexStrategy {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WRAP => 0i32,
            Self::CLAMP => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ILightEntity_EFrameIndexStrategy {
     const TYPE_ID: &str = "ILightEntity_EFrameIndexStrategy";
}

impl StaticVariant for Vec<ILightEntity_EFrameIndexStrategy> {
     const TYPE_ID: &str = "TArray<ILightEntity_EFrameIndexStrategy>";
}

impl StaticVariant for Vec<Vec<ILightEntity_EFrameIndexStrategy>> {
     const TYPE_ID: &str = "TArray<TArray<ILightEntity_EFrameIndexStrategy>>";
}

impl Variant for ILightEntity_EFrameIndexStrategy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ILightEntity_EFrameIndexStrategy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ILightEntity_EFrameIndexStrategy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ILightEntity_EFrameIndexStrategy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ILightEntity_EFrameIndexStrategy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ILightEntity_EFrameIndexStrategy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ILightEntity_ELightType {
    LT_DIRECTIONAL,
    LT_ENVIRONMENT,
    LT_OMNI,
    LT_SPOT,
    LT_SQUARESPOT,
    LT_CAPSULE,
    LT_AREA_QUAD,
}

impl Aligned for ILightEntity_ELightType {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ILightEntity_ELightType {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LT_DIRECTIONAL => 0i8,
            Self::LT_ENVIRONMENT => 1i8,
            Self::LT_OMNI => 2i8,
            Self::LT_SPOT => 3i8,
            Self::LT_SQUARESPOT => 4i8,
            Self::LT_CAPSULE => 5i8,
            Self::LT_AREA_QUAD => 6i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ILightEntity_ELightType {
     const TYPE_ID: &str = "ILightEntity_ELightType";
}

impl StaticVariant for Vec<ILightEntity_ELightType> {
     const TYPE_ID: &str = "TArray<ILightEntity_ELightType>";
}

impl StaticVariant for Vec<Vec<ILightEntity_ELightType>> {
     const TYPE_ID: &str = "TArray<TArray<ILightEntity_ELightType>>";
}

impl Variant for ILightEntity_ELightType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ILightEntity_ELightType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ILightEntity_ELightType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ILightEntity_ELightType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ILightEntity_ELightType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ILightEntity_ELightType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ILightEntity_ERoomLightFlow {
    AUTOMATIC,
    LOCAL,
    ALLROOMS,
}

impl Aligned for ILightEntity_ERoomLightFlow {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ILightEntity_ERoomLightFlow {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AUTOMATIC => 0i32,
            Self::LOCAL => 1i32,
            Self::ALLROOMS => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ILightEntity_ERoomLightFlow {
     const TYPE_ID: &str = "ILightEntity_ERoomLightFlow";
}

impl StaticVariant for Vec<ILightEntity_ERoomLightFlow> {
     const TYPE_ID: &str = "TArray<ILightEntity_ERoomLightFlow>";
}

impl StaticVariant for Vec<Vec<ILightEntity_ERoomLightFlow>> {
     const TYPE_ID: &str = "TArray<TArray<ILightEntity_ERoomLightFlow>>";
}

impl Variant for ILightEntity_ERoomLightFlow {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ILightEntity_ERoomLightFlow")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ILightEntity_ERoomLightFlow".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ILightEntity_ERoomLightFlow>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ILightEntity_ERoomLightFlow>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ILightEntity_ERoomLightFlow>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IRenderCompositorEntity_EMode {
    eSourceA,
    eSourceB,
    eLayered,
    eAlphaLayered,
}

impl Aligned for IRenderCompositorEntity_EMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IRenderCompositorEntity_EMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSourceA => 0i32,
            Self::eSourceB => 1i32,
            Self::eLayered => 2i32,
            Self::eAlphaLayered => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IRenderCompositorEntity_EMode {
     const TYPE_ID: &str = "IRenderCompositorEntity_EMode";
}

impl StaticVariant for Vec<IRenderCompositorEntity_EMode> {
     const TYPE_ID: &str = "TArray<IRenderCompositorEntity_EMode>";
}

impl StaticVariant for Vec<Vec<IRenderCompositorEntity_EMode>> {
     const TYPE_ID: &str = "TArray<TArray<IRenderCompositorEntity_EMode>>";
}

impl Variant for IRenderCompositorEntity_EMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IRenderCompositorEntity_EMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IRenderCompositorEntity_EMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IRenderCompositorEntity_EMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IRenderCompositorEntity_EMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IRenderCompositorEntity_EMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IRenderCompositorEntity_EViewportAnchor {
    eFill,
    eTopLeft,
    eTopRight,
    eBottomLeft,
    eBottomRight,
}

impl Aligned for IRenderCompositorEntity_EViewportAnchor {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IRenderCompositorEntity_EViewportAnchor {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFill => 0i32,
            Self::eTopLeft => 1i32,
            Self::eTopRight => 2i32,
            Self::eBottomLeft => 3i32,
            Self::eBottomRight => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IRenderCompositorEntity_EViewportAnchor {
     const TYPE_ID: &str = "IRenderCompositorEntity_EViewportAnchor";
}

impl StaticVariant for Vec<IRenderCompositorEntity_EViewportAnchor> {
     const TYPE_ID: &str = "TArray<IRenderCompositorEntity_EViewportAnchor>";
}

impl StaticVariant for Vec<Vec<IRenderCompositorEntity_EViewportAnchor>> {
     const TYPE_ID: &str = "TArray<TArray<IRenderCompositorEntity_EViewportAnchor>>";
}

impl Variant for IRenderCompositorEntity_EViewportAnchor {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IRenderCompositorEntity_EViewportAnchor")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IRenderCompositorEntity_EViewportAnchor".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IRenderCompositorEntity_EViewportAnchor>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IRenderCompositorEntity_EViewportAnchor>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IRenderCompositorEntity_EViewportAnchor>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IRenderMaterialEntity_EModifierOperation {
    eLeave,
    eReplace,
    eModulate,
    eAdd,
    eColor,
}

impl Aligned for IRenderMaterialEntity_EModifierOperation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IRenderMaterialEntity_EModifierOperation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLeave => 0i32,
            Self::eReplace => 1i32,
            Self::eModulate => 2i32,
            Self::eAdd => 3i32,
            Self::eColor => 128i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IRenderMaterialEntity_EModifierOperation {
     const TYPE_ID: &str = "IRenderMaterialEntity_EModifierOperation";
}

impl StaticVariant for Vec<IRenderMaterialEntity_EModifierOperation> {
     const TYPE_ID: &str = "TArray<IRenderMaterialEntity_EModifierOperation>";
}

impl StaticVariant for Vec<Vec<IRenderMaterialEntity_EModifierOperation>> {
     const TYPE_ID: &str = "TArray<TArray<IRenderMaterialEntity_EModifierOperation>>";
}

impl Variant for IRenderMaterialEntity_EModifierOperation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IRenderMaterialEntity_EModifierOperation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IRenderMaterialEntity_EModifierOperation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IRenderMaterialEntity_EModifierOperation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IRenderMaterialEntity_EModifierOperation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IRenderMaterialEntity_EModifierOperation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IRoomEntity_EReasoningGridImportance {
    RGI_NoGrid,
    RGI_Low,
    RGI_Normal,
    RGI_High,
    RGI_Extreme,
}

impl Aligned for IRoomEntity_EReasoningGridImportance {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IRoomEntity_EReasoningGridImportance {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RGI_NoGrid => 0i32,
            Self::RGI_Low => 1i32,
            Self::RGI_Normal => 2i32,
            Self::RGI_High => 3i32,
            Self::RGI_Extreme => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IRoomEntity_EReasoningGridImportance {
     const TYPE_ID: &str = "IRoomEntity_EReasoningGridImportance";
}

impl StaticVariant for Vec<IRoomEntity_EReasoningGridImportance> {
     const TYPE_ID: &str = "TArray<IRoomEntity_EReasoningGridImportance>";
}

impl StaticVariant for Vec<Vec<IRoomEntity_EReasoningGridImportance>> {
     const TYPE_ID: &str = "TArray<TArray<IRoomEntity_EReasoningGridImportance>>";
}

impl Variant for IRoomEntity_EReasoningGridImportance {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IRoomEntity_EReasoningGridImportance")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IRoomEntity_EReasoningGridImportance".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IRoomEntity_EReasoningGridImportance>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IRoomEntity_EReasoningGridImportance>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IRoomEntity_EReasoningGridImportance>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IScatterContainerEntity_EBrushType {
    BRUSH_SQUARE,
    BRUSH_CIRCLE,
}

impl Aligned for IScatterContainerEntity_EBrushType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IScatterContainerEntity_EBrushType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BRUSH_SQUARE => 0i32,
            Self::BRUSH_CIRCLE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IScatterContainerEntity_EBrushType {
     const TYPE_ID: &str = "IScatterContainerEntity_EBrushType";
}

impl StaticVariant for Vec<IScatterContainerEntity_EBrushType> {
     const TYPE_ID: &str = "TArray<IScatterContainerEntity_EBrushType>";
}

impl StaticVariant for Vec<Vec<IScatterContainerEntity_EBrushType>> {
     const TYPE_ID: &str = "TArray<TArray<IScatterContainerEntity_EBrushType>>";
}

impl Variant for IScatterContainerEntity_EBrushType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IScatterContainerEntity_EBrushType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IScatterContainerEntity_EBrushType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IScatterContainerEntity_EBrushType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IScatterContainerEntity_EBrushType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IScatterContainerEntity_EBrushType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IScatterContainerEntity_ECanvasClearMode {
    CLEAR_ALL,
    CLEAR_INTENSITY,
    CLEAR_SPECIFICMATERIAL,
    CLEAR_ALLMATERIALS,
    CLEAR_SETINTENSITYVALUECLEARMATERIAL,
    CLEAR_SETINTENSITYVALUEKEEPMATERIAL,
    CLEAR_SETINTENSITYVALUEANDMATERIAL,
    CLEAR_SETMATERIALKEEPINTENSITYVALUE,
}

impl Aligned for IScatterContainerEntity_ECanvasClearMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IScatterContainerEntity_ECanvasClearMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CLEAR_ALL => 0i32,
            Self::CLEAR_INTENSITY => 1i32,
            Self::CLEAR_SPECIFICMATERIAL => 2i32,
            Self::CLEAR_ALLMATERIALS => 3i32,
            Self::CLEAR_SETINTENSITYVALUECLEARMATERIAL => 4i32,
            Self::CLEAR_SETINTENSITYVALUEKEEPMATERIAL => 5i32,
            Self::CLEAR_SETINTENSITYVALUEANDMATERIAL => 6i32,
            Self::CLEAR_SETMATERIALKEEPINTENSITYVALUE => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IScatterContainerEntity_ECanvasClearMode {
     const TYPE_ID: &str = "IScatterContainerEntity_ECanvasClearMode";
}

impl StaticVariant for Vec<IScatterContainerEntity_ECanvasClearMode> {
     const TYPE_ID: &str = "TArray<IScatterContainerEntity_ECanvasClearMode>";
}

impl StaticVariant for Vec<Vec<IScatterContainerEntity_ECanvasClearMode>> {
     const TYPE_ID: &str = "TArray<TArray<IScatterContainerEntity_ECanvasClearMode>>";
}

impl Variant for IScatterContainerEntity_ECanvasClearMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IScatterContainerEntity_ECanvasClearMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IScatterContainerEntity_ECanvasClearMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IScatterContainerEntity_ECanvasClearMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IScatterContainerEntity_ECanvasClearMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IScatterContainerEntity_ECanvasClearMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IScatterContainerEntity_ECanvasSize {
    SIZE_128,
    SIZE_256,
    SIZE_512,
    SIZE_1024,
    SIZE_2048,
    SIZE_4096,
}

impl Aligned for IScatterContainerEntity_ECanvasSize {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IScatterContainerEntity_ECanvasSize {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SIZE_128 => 0i32,
            Self::SIZE_256 => 1i32,
            Self::SIZE_512 => 2i32,
            Self::SIZE_1024 => 3i32,
            Self::SIZE_2048 => 4i32,
            Self::SIZE_4096 => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IScatterContainerEntity_ECanvasSize {
     const TYPE_ID: &str = "IScatterContainerEntity_ECanvasSize";
}

impl StaticVariant for Vec<IScatterContainerEntity_ECanvasSize> {
     const TYPE_ID: &str = "TArray<IScatterContainerEntity_ECanvasSize>";
}

impl StaticVariant for Vec<Vec<IScatterContainerEntity_ECanvasSize>> {
     const TYPE_ID: &str = "TArray<TArray<IScatterContainerEntity_ECanvasSize>>";
}

impl Variant for IScatterContainerEntity_ECanvasSize {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IScatterContainerEntity_ECanvasSize")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IScatterContainerEntity_ECanvasSize".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IScatterContainerEntity_ECanvasSize>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IScatterContainerEntity_ECanvasSize>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IScatterContainerEntity_ECanvasSize>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum IScatterContainerEntity_EResizeMode {
    MODE_CLEAR,
    MODE_KEEPASCENTER,
    MODE_SCALE,
}

impl Aligned for IScatterContainerEntity_EResizeMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for IScatterContainerEntity_EResizeMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MODE_CLEAR => 0i32,
            Self::MODE_KEEPASCENTER => 1i32,
            Self::MODE_SCALE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for IScatterContainerEntity_EResizeMode {
     const TYPE_ID: &str = "IScatterContainerEntity_EResizeMode";
}

impl StaticVariant for Vec<IScatterContainerEntity_EResizeMode> {
     const TYPE_ID: &str = "TArray<IScatterContainerEntity_EResizeMode>";
}

impl StaticVariant for Vec<Vec<IScatterContainerEntity_EResizeMode>> {
     const TYPE_ID: &str = "TArray<TArray<IScatterContainerEntity_EResizeMode>>";
}

impl Variant for IScatterContainerEntity_EResizeMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("IScatterContainerEntity_EResizeMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("IScatterContainerEntity_EResizeMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<IScatterContainerEntity_EResizeMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<IScatterContainerEntity_EResizeMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<IScatterContainerEntity_EResizeMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum InputControlNamesp_eHM5InputAction {
    eIAButtonFaceDown_Downedge,
    eIAButtonFaceDown_FastTap,
    eIAButtonFaceDown_HldDwnOnce,
    eIAButtonFaceDown_Hold,
    eIAButtonFaceDown_HoldDown,
    eIAButtonFaceLeft_Downedge,
    eIAButtonFaceLeft_HldDwnOnce,
    eIAButtonFaceLeft_Hold,
    eIAButtonFaceLeft_HoldDown,
    eIAButtonFaceLeft_FastTap,
    eIAButtonFaceLeft_Tap,
    eIAButtonFaceLeft_Release,
    eIAButtonFaceLeft_Repeat,
    eIAButtonFaceRight_Downedge,
    eIAButtonFaceRight_HldDwnOnce,
    eIAButtonFaceRight_Hold,
    eIAButtonFaceRight_HoldDown,
    eIAButtonFaceRight_FastTap,
    eIAButtonFaceRight_Tap,
    eIAButtonFaceRight_Release,
    eIAButtonFaceRight_Repeat,
    eIAButtonFaceUp_Downedge,
    eIAButtonFaceUp_FastTap,
    eIAButtonFaceUp_HldDwnOnce,
    eIAButtonFaceUp_Hold,
    eIAButtonFaceUp_HoldDown,
    eIABumperLeft_FastTap,
    eIABumperLeft_Downedge,
    eIABumperLeft_Hold,
    eIABumperLeft_Holddown,
    eIABumperLeft_Release,
    eIABumperRight_FastTap,
    eIABumperRight_Downedge,
    eIABumperRight_Hold,
    eIABumperRight_Holddown,
    eIABumperRight_Release,
    eIADpadUp_Downedge,
    eIADpadUp_HldDwnOnce,
    eIADpadUp_Hold,
    eIADpadDown_Hold,
    eIADpadUp_FastTap,
    eIADpadDown_Downedge,
    eIADpadDown_Release,
    eIADpadDown_FastTap,
    eIADpadDown_HldDwnOnce,
    eIADpadLeft_Downedge,
    eIADpadRight_Downedge,
    eIAThumbRight_Hold,
    eIAThumbRight_Downedge,
    eIAThumbLeft_Hold,
    eIAThumbLeft_DownEdge,
    eIATriggerLeft_Downedge,
    eIATriggerLeft_FastTap,
    eIATriggerLeft_Hold,
    eIATriggerLeft_Holddown,
    eIATriggerLeft_Release,
    eIATriggerRight_Downedge,
    eIATriggerRight_FastTap,
    eIATriggerRight_Hold,
    eIATriggerRight_Holddown,
    eIATriggerRight_Release,
    eIAGenericStart_Hold,
    eIAGCMeleeUse_Downedge,
    eIAGCMeleeUse_Hold,
    eIAGCMeleeUse_HoldDown,
    eIAGCMeleeUse_Release,
    eIAGCMeleeUse_HldDwnOnce,
    eIAGCMeleeUse_Repeat,
    eIAGCMeleeUse_Tap,
    eIAGCMeleeUse_FastTap,
    eIAGCAgilityDisguise_Downedge,
    eIAGCAgilityDisguise_Hold,
    eIAGCAgilityDisguise_HoldDown,
    eIAGCAgilityDisguise_Release,
    eIAGCAgilityDisguise_HldDwnOnce,
    eIAGCAgilityDisguise_Repeat,
    eIAGCAgilityDisguise_Tap,
    eIAGCAgilityDisguise_FastTap,
    eIAGCCoverDragBody_Downedge,
    eIAGCCoverDragBody_Hold,
    eIAGCCoverDragBody_HoldDown,
    eIAGCCoverDragBody_Release,
    eIAGCCoverDragBody_HldDwnOnce,
    eIAGCCoverDragBody_Repeat,
    eIAGCCoverDragBody_Tap,
    eIAGCCoverDragBody_FastTap,
    eIAGCInteractPickup_Downedge,
    eIAGCInteractPickup_Hold,
    eIAGCInteractPickup_HoldDown,
    eIAGCInteractPickup_Release,
    eIAGCInteractPickup_HldDwnOnce,
    eIAGCInteractPickup_Repeat,
    eIAGCInteractPickup_Tap,
    eIAGCInteractPickup_FastTap,
    eIAGCReloadInstinct_Downedge,
    eIAGCReloadInstinct_Hold,
    eIAGCReloadInstinct_HoldDown,
    eIAGCReloadInstinct_Release,
    eIAGCReloadInstinct_HldDwnOnce,
    eIAGCReloadInstinct_Repeat,
    eIAGCReloadInstinct_Tap,
    eIAGCReloadInstinct_FastTap,
    eIAGCRun_Downedge,
    eIAGCRun_Hold,
    eIAGCRun_HoldDown,
    eIAGCRun_Release,
    eIAGCRun_HldDwnOnce,
    eIAGCRun_Repeat,
    eIAGCRun_Tap,
    eIAGCRun_FastTap,
    eIAGCHolster_Downedge,
    eIAGCHolster_Hold,
    eIAGCHolster_HoldDown,
    eIAGCHolster_Release,
    eIAGCHolster_HldDwnOnce,
    eIAGCHolster_Repeat,
    eIAGCHolster_Tap,
    eIAGCHolster_FastTap,
    eIAGCInventory_Downedge,
    eIAGCInventory_Hold,
    eIAGCInventory_HoldDown,
    eIAGCInventory_Release,
    eIAGCInventory_HldDwnOnce,
    eIAGCInventory_Repeat,
    eIAGCInventory_Tap,
    eIAGCInventory_FastTap,
    eIAGCEmotes_Downedge,
    eIAGCEmotes_Hold,
    eIAGCEmotes_HoldDown,
    eIAGCEmotes_Release,
    eIAGCEmotes_HldDwnOnce,
    eIAGCEmotes_Repeat,
    eIAGCEmotes_Tap,
    eIAGCEmotes_FastTap,
    eIAGCDropItem_Downedge,
    eIAGCDropItem_Hold,
    eIAGCDropItem_HoldDown,
    eIAGCDropItem_Release,
    eIAGCDropItem_HldDwnOnce,
    eIAGCDropItem_Repeat,
    eIAGCDropItem_Tap,
    eIAGCDropItem_FastTap,
    eIAGCCrouch_Downedge,
    eIAGCCrouch_Hold,
    eIAGCCrouch_HoldDown,
    eIAGCCrouch_Release,
    eIAGCCrouch_HldDwnOnce,
    eIAGCCrouch_Repeat,
    eIAGCCrouch_Tap,
    eIAGCCrouch_FastTap,
    eIAGCCameraShoulder_Downedge,
    eIAGCCameraShoulder_Hold,
    eIAGCCameraShoulder_HoldDown,
    eIAGCCameraShoulder_Release,
    eIAGCCameraShoulder_HldDwnOnce,
    eIAGCCameraShoulder_Repeat,
    eIAGCCameraShoulder_Tap,
    eIAGCCameraShoulder_FastTap,
    eIAKBMMoveUp,
    eIAKBMMoveDown,
    eIAKBMMoveLeft,
    eIAKBMMoveRight,
    eIAKBMMarkTarget,
    eIAKBMNextAmmo,
    eIAKBMPreviousAmmo,
    eIAKBMUse,
    eIAKBMUse2,
    eIAKBMUse2Hold,
    eIAKBMSlideDown,
    eIAKBMPickup,
    eIAKBMCover,
    eIAKBMDragBody,
    eIAKBMMelee,
    eIAKBMMelee_Repeat,
    eIAKBMActivateProp,
    eIAKBMActivateProp_HldDwnOnce,
    eIAKBMActivateProp_Hold,
    eIAKBMActivatePropSecondary,
    eIAKBMConcealRetrieve,
    eIAKBMTakeDisguise,
    eIAKBMRun,
    eIAKBMWalkSlow,
    eIAKBMAim,
    eIAKBMShoot,
    eIAKBMShoot_Downedge,
    eIAKBMShoot_Release,
    eIAKBMReload,
    eIAKBMInstinct,
    eIAKBMCamSwitch,
    eIAKBMSneak,
    eIAKBMHolster,
    eIAKBMFireMode,
    eIAKBMNotebook,
    eIAKBMNotebookMap,
    eIAKBMPause,
    eIAKBMWeapon1,
    eIAKBMWeapon2,
    eIAKBMWeapon3,
    eIAKBMWeapon4,
    eIAKBMWeapon5,
    eIAKBMWeapon6,
    eIAKBMWeapon7,
    eIAKBMPrecisionAim,
    eIAKBMZoomIn,
    eIAKBMZoomOut,
    eIAKBMDropItem,
    eIAKBMInventory,
    eIAKBMEmotes,
    eIAKBMSurrender,
    eIAKBMSurrender_Hold,
    eIAKBMSurrender_HoldDown,
    eIAKBMSurrender_HoldDownOnce,
    eIAKBMTogglePlacement,
    eIAKBMOkay,
    eIAKBMCancel,
    eIAKBMAccept,
    eIATriggerLeft_Analog,
    eIATriggerRight_Analog,
    eIAStickLeftHorizontal_Analog,
    eIAStickLeftVertical_Analog,
    eIAStickRightHorizontal_Analog,
    eIAStickRightVertical_Analog,
    eIAStickLeftHorizontal_Raw,
    eIAStickLeftVertical_Raw,
    eIAStickRightHorizontal_Raw,
    eIAStickRightVertical_Raw,
    eIABumperLeft_Analog,
    eIABumperRight_Analog,
    eIAKBMMoveHorizontal,
    eIAKBMMoveVertical,
    eIAKBMLookHorizontal,
    eIAKBMLookVertical,
    eIActionsNUM,
}

impl Aligned for InputControlNamesp_eHM5InputAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for InputControlNamesp_eHM5InputAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIAButtonFaceDown_Downedge => 0i32,
            Self::eIAButtonFaceDown_FastTap => 1i32,
            Self::eIAButtonFaceDown_HldDwnOnce => 2i32,
            Self::eIAButtonFaceDown_Hold => 3i32,
            Self::eIAButtonFaceDown_HoldDown => 4i32,
            Self::eIAButtonFaceLeft_Downedge => 5i32,
            Self::eIAButtonFaceLeft_HldDwnOnce => 6i32,
            Self::eIAButtonFaceLeft_Hold => 7i32,
            Self::eIAButtonFaceLeft_HoldDown => 8i32,
            Self::eIAButtonFaceLeft_FastTap => 9i32,
            Self::eIAButtonFaceLeft_Tap => 10i32,
            Self::eIAButtonFaceLeft_Release => 11i32,
            Self::eIAButtonFaceLeft_Repeat => 12i32,
            Self::eIAButtonFaceRight_Downedge => 13i32,
            Self::eIAButtonFaceRight_HldDwnOnce => 14i32,
            Self::eIAButtonFaceRight_Hold => 15i32,
            Self::eIAButtonFaceRight_HoldDown => 16i32,
            Self::eIAButtonFaceRight_FastTap => 17i32,
            Self::eIAButtonFaceRight_Tap => 18i32,
            Self::eIAButtonFaceRight_Release => 19i32,
            Self::eIAButtonFaceRight_Repeat => 20i32,
            Self::eIAButtonFaceUp_Downedge => 21i32,
            Self::eIAButtonFaceUp_FastTap => 22i32,
            Self::eIAButtonFaceUp_HldDwnOnce => 23i32,
            Self::eIAButtonFaceUp_Hold => 24i32,
            Self::eIAButtonFaceUp_HoldDown => 25i32,
            Self::eIABumperLeft_FastTap => 26i32,
            Self::eIABumperLeft_Downedge => 27i32,
            Self::eIABumperLeft_Hold => 28i32,
            Self::eIABumperLeft_Holddown => 29i32,
            Self::eIABumperLeft_Release => 30i32,
            Self::eIABumperRight_FastTap => 31i32,
            Self::eIABumperRight_Downedge => 32i32,
            Self::eIABumperRight_Hold => 33i32,
            Self::eIABumperRight_Holddown => 34i32,
            Self::eIABumperRight_Release => 35i32,
            Self::eIADpadUp_Downedge => 36i32,
            Self::eIADpadUp_HldDwnOnce => 37i32,
            Self::eIADpadUp_Hold => 38i32,
            Self::eIADpadDown_Hold => 39i32,
            Self::eIADpadUp_FastTap => 40i32,
            Self::eIADpadDown_Downedge => 41i32,
            Self::eIADpadDown_Release => 42i32,
            Self::eIADpadDown_FastTap => 43i32,
            Self::eIADpadDown_HldDwnOnce => 44i32,
            Self::eIADpadLeft_Downedge => 45i32,
            Self::eIADpadRight_Downedge => 46i32,
            Self::eIAThumbRight_Hold => 47i32,
            Self::eIAThumbRight_Downedge => 48i32,
            Self::eIAThumbLeft_Hold => 49i32,
            Self::eIAThumbLeft_DownEdge => 50i32,
            Self::eIATriggerLeft_Downedge => 51i32,
            Self::eIATriggerLeft_FastTap => 52i32,
            Self::eIATriggerLeft_Hold => 53i32,
            Self::eIATriggerLeft_Holddown => 54i32,
            Self::eIATriggerLeft_Release => 55i32,
            Self::eIATriggerRight_Downedge => 56i32,
            Self::eIATriggerRight_FastTap => 57i32,
            Self::eIATriggerRight_Hold => 58i32,
            Self::eIATriggerRight_Holddown => 59i32,
            Self::eIATriggerRight_Release => 60i32,
            Self::eIAGenericStart_Hold => 61i32,
            Self::eIAGCMeleeUse_Downedge => 62i32,
            Self::eIAGCMeleeUse_Hold => 63i32,
            Self::eIAGCMeleeUse_HoldDown => 64i32,
            Self::eIAGCMeleeUse_Release => 65i32,
            Self::eIAGCMeleeUse_HldDwnOnce => 66i32,
            Self::eIAGCMeleeUse_Repeat => 67i32,
            Self::eIAGCMeleeUse_Tap => 68i32,
            Self::eIAGCMeleeUse_FastTap => 69i32,
            Self::eIAGCAgilityDisguise_Downedge => 70i32,
            Self::eIAGCAgilityDisguise_Hold => 71i32,
            Self::eIAGCAgilityDisguise_HoldDown => 72i32,
            Self::eIAGCAgilityDisguise_Release => 73i32,
            Self::eIAGCAgilityDisguise_HldDwnOnce => 74i32,
            Self::eIAGCAgilityDisguise_Repeat => 75i32,
            Self::eIAGCAgilityDisguise_Tap => 76i32,
            Self::eIAGCAgilityDisguise_FastTap => 77i32,
            Self::eIAGCCoverDragBody_Downedge => 78i32,
            Self::eIAGCCoverDragBody_Hold => 79i32,
            Self::eIAGCCoverDragBody_HoldDown => 80i32,
            Self::eIAGCCoverDragBody_Release => 81i32,
            Self::eIAGCCoverDragBody_HldDwnOnce => 82i32,
            Self::eIAGCCoverDragBody_Repeat => 83i32,
            Self::eIAGCCoverDragBody_Tap => 84i32,
            Self::eIAGCCoverDragBody_FastTap => 85i32,
            Self::eIAGCInteractPickup_Downedge => 86i32,
            Self::eIAGCInteractPickup_Hold => 87i32,
            Self::eIAGCInteractPickup_HoldDown => 88i32,
            Self::eIAGCInteractPickup_Release => 89i32,
            Self::eIAGCInteractPickup_HldDwnOnce => 90i32,
            Self::eIAGCInteractPickup_Repeat => 91i32,
            Self::eIAGCInteractPickup_Tap => 92i32,
            Self::eIAGCInteractPickup_FastTap => 93i32,
            Self::eIAGCReloadInstinct_Downedge => 94i32,
            Self::eIAGCReloadInstinct_Hold => 95i32,
            Self::eIAGCReloadInstinct_HoldDown => 96i32,
            Self::eIAGCReloadInstinct_Release => 97i32,
            Self::eIAGCReloadInstinct_HldDwnOnce => 98i32,
            Self::eIAGCReloadInstinct_Repeat => 99i32,
            Self::eIAGCReloadInstinct_Tap => 100i32,
            Self::eIAGCReloadInstinct_FastTap => 101i32,
            Self::eIAGCRun_Downedge => 102i32,
            Self::eIAGCRun_Hold => 103i32,
            Self::eIAGCRun_HoldDown => 104i32,
            Self::eIAGCRun_Release => 105i32,
            Self::eIAGCRun_HldDwnOnce => 106i32,
            Self::eIAGCRun_Repeat => 107i32,
            Self::eIAGCRun_Tap => 108i32,
            Self::eIAGCRun_FastTap => 109i32,
            Self::eIAGCHolster_Downedge => 110i32,
            Self::eIAGCHolster_Hold => 111i32,
            Self::eIAGCHolster_HoldDown => 112i32,
            Self::eIAGCHolster_Release => 113i32,
            Self::eIAGCHolster_HldDwnOnce => 114i32,
            Self::eIAGCHolster_Repeat => 115i32,
            Self::eIAGCHolster_Tap => 116i32,
            Self::eIAGCHolster_FastTap => 117i32,
            Self::eIAGCInventory_Downedge => 118i32,
            Self::eIAGCInventory_Hold => 119i32,
            Self::eIAGCInventory_HoldDown => 120i32,
            Self::eIAGCInventory_Release => 121i32,
            Self::eIAGCInventory_HldDwnOnce => 122i32,
            Self::eIAGCInventory_Repeat => 123i32,
            Self::eIAGCInventory_Tap => 124i32,
            Self::eIAGCInventory_FastTap => 125i32,
            Self::eIAGCEmotes_Downedge => 126i32,
            Self::eIAGCEmotes_Hold => 127i32,
            Self::eIAGCEmotes_HoldDown => 128i32,
            Self::eIAGCEmotes_Release => 129i32,
            Self::eIAGCEmotes_HldDwnOnce => 130i32,
            Self::eIAGCEmotes_Repeat => 131i32,
            Self::eIAGCEmotes_Tap => 132i32,
            Self::eIAGCEmotes_FastTap => 133i32,
            Self::eIAGCDropItem_Downedge => 134i32,
            Self::eIAGCDropItem_Hold => 135i32,
            Self::eIAGCDropItem_HoldDown => 136i32,
            Self::eIAGCDropItem_Release => 137i32,
            Self::eIAGCDropItem_HldDwnOnce => 138i32,
            Self::eIAGCDropItem_Repeat => 139i32,
            Self::eIAGCDropItem_Tap => 140i32,
            Self::eIAGCDropItem_FastTap => 141i32,
            Self::eIAGCCrouch_Downedge => 142i32,
            Self::eIAGCCrouch_Hold => 143i32,
            Self::eIAGCCrouch_HoldDown => 144i32,
            Self::eIAGCCrouch_Release => 145i32,
            Self::eIAGCCrouch_HldDwnOnce => 146i32,
            Self::eIAGCCrouch_Repeat => 147i32,
            Self::eIAGCCrouch_Tap => 148i32,
            Self::eIAGCCrouch_FastTap => 149i32,
            Self::eIAGCCameraShoulder_Downedge => 150i32,
            Self::eIAGCCameraShoulder_Hold => 151i32,
            Self::eIAGCCameraShoulder_HoldDown => 152i32,
            Self::eIAGCCameraShoulder_Release => 153i32,
            Self::eIAGCCameraShoulder_HldDwnOnce => 154i32,
            Self::eIAGCCameraShoulder_Repeat => 155i32,
            Self::eIAGCCameraShoulder_Tap => 156i32,
            Self::eIAGCCameraShoulder_FastTap => 157i32,
            Self::eIAKBMMoveUp => 158i32,
            Self::eIAKBMMoveDown => 159i32,
            Self::eIAKBMMoveLeft => 160i32,
            Self::eIAKBMMoveRight => 161i32,
            Self::eIAKBMMarkTarget => 162i32,
            Self::eIAKBMNextAmmo => 163i32,
            Self::eIAKBMPreviousAmmo => 164i32,
            Self::eIAKBMUse => 165i32,
            Self::eIAKBMUse2 => 166i32,
            Self::eIAKBMUse2Hold => 167i32,
            Self::eIAKBMSlideDown => 168i32,
            Self::eIAKBMPickup => 169i32,
            Self::eIAKBMCover => 170i32,
            Self::eIAKBMDragBody => 171i32,
            Self::eIAKBMMelee => 172i32,
            Self::eIAKBMMelee_Repeat => 173i32,
            Self::eIAKBMActivateProp => 174i32,
            Self::eIAKBMActivateProp_HldDwnOnce => 175i32,
            Self::eIAKBMActivateProp_Hold => 176i32,
            Self::eIAKBMActivatePropSecondary => 177i32,
            Self::eIAKBMConcealRetrieve => 178i32,
            Self::eIAKBMTakeDisguise => 179i32,
            Self::eIAKBMRun => 180i32,
            Self::eIAKBMWalkSlow => 181i32,
            Self::eIAKBMAim => 182i32,
            Self::eIAKBMShoot => 183i32,
            Self::eIAKBMShoot_Downedge => 184i32,
            Self::eIAKBMShoot_Release => 185i32,
            Self::eIAKBMReload => 186i32,
            Self::eIAKBMInstinct => 187i32,
            Self::eIAKBMCamSwitch => 188i32,
            Self::eIAKBMSneak => 189i32,
            Self::eIAKBMHolster => 190i32,
            Self::eIAKBMFireMode => 191i32,
            Self::eIAKBMNotebook => 192i32,
            Self::eIAKBMNotebookMap => 193i32,
            Self::eIAKBMPause => 194i32,
            Self::eIAKBMWeapon1 => 195i32,
            Self::eIAKBMWeapon2 => 196i32,
            Self::eIAKBMWeapon3 => 197i32,
            Self::eIAKBMWeapon4 => 198i32,
            Self::eIAKBMWeapon5 => 199i32,
            Self::eIAKBMWeapon6 => 200i32,
            Self::eIAKBMWeapon7 => 201i32,
            Self::eIAKBMPrecisionAim => 202i32,
            Self::eIAKBMZoomIn => 203i32,
            Self::eIAKBMZoomOut => 204i32,
            Self::eIAKBMDropItem => 205i32,
            Self::eIAKBMInventory => 206i32,
            Self::eIAKBMEmotes => 207i32,
            Self::eIAKBMSurrender => 208i32,
            Self::eIAKBMSurrender_Hold => 209i32,
            Self::eIAKBMSurrender_HoldDown => 210i32,
            Self::eIAKBMSurrender_HoldDownOnce => 211i32,
            Self::eIAKBMTogglePlacement => 212i32,
            Self::eIAKBMOkay => 213i32,
            Self::eIAKBMCancel => 214i32,
            Self::eIAKBMAccept => 215i32,
            Self::eIATriggerLeft_Analog => 216i32,
            Self::eIATriggerRight_Analog => 217i32,
            Self::eIAStickLeftHorizontal_Analog => 218i32,
            Self::eIAStickLeftVertical_Analog => 219i32,
            Self::eIAStickRightHorizontal_Analog => 220i32,
            Self::eIAStickRightVertical_Analog => 221i32,
            Self::eIAStickLeftHorizontal_Raw => 222i32,
            Self::eIAStickLeftVertical_Raw => 223i32,
            Self::eIAStickRightHorizontal_Raw => 224i32,
            Self::eIAStickRightVertical_Raw => 225i32,
            Self::eIABumperLeft_Analog => 226i32,
            Self::eIABumperRight_Analog => 227i32,
            Self::eIAKBMMoveHorizontal => 228i32,
            Self::eIAKBMMoveVertical => 229i32,
            Self::eIAKBMLookHorizontal => 230i32,
            Self::eIAKBMLookVertical => 231i32,
            Self::eIActionsNUM => 232i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for InputControlNamesp_eHM5InputAction {
     const TYPE_ID: &str = "InputControlNamesp_eHM5InputAction";
}

impl StaticVariant for Vec<InputControlNamesp_eHM5InputAction> {
     const TYPE_ID: &str = "TArray<InputControlNamesp_eHM5InputAction>";
}

impl StaticVariant for Vec<Vec<InputControlNamesp_eHM5InputAction>> {
     const TYPE_ID: &str = "TArray<TArray<InputControlNamesp_eHM5InputAction>>";
}

impl Variant for InputControlNamesp_eHM5InputAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("InputControlNamesp_eHM5InputAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("InputControlNamesp_eHM5InputAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<InputControlNamesp_eHM5InputAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<InputControlNamesp_eHM5InputAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<InputControlNamesp_eHM5InputAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum InputControlNamesp_eHM5InputActionID {
    eIDButtonFaceDown,
    eIDButtonFaceLeft,
    eIDButtonFaceRight,
    eIDButtonFaceUp,
    eIDBumperLeft,
    eIDBumperRight,
    eIDDpadDown,
    eIDDpadLeft,
    eIDDpadRight,
    eIDDpadUp,
    eIDThumbLeft,
    eIDThumbRight,
    eIDButtonStart,
    eIDButtonSelect,
    eIDTriggerLeft,
    eIDTriggerRight,
    eIDStickLeftHorizontal,
    eIDStickLeftVertical,
    eIDStickRightHorizontal,
    eIDStickRightVertical,
    eIDKeyboard,
    eID_INVALID,
}

impl Aligned for InputControlNamesp_eHM5InputActionID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for InputControlNamesp_eHM5InputActionID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIDButtonFaceDown => 0i32,
            Self::eIDButtonFaceLeft => 1i32,
            Self::eIDButtonFaceRight => 2i32,
            Self::eIDButtonFaceUp => 3i32,
            Self::eIDBumperLeft => 4i32,
            Self::eIDBumperRight => 5i32,
            Self::eIDDpadDown => 6i32,
            Self::eIDDpadLeft => 7i32,
            Self::eIDDpadRight => 8i32,
            Self::eIDDpadUp => 9i32,
            Self::eIDThumbLeft => 10i32,
            Self::eIDThumbRight => 11i32,
            Self::eIDButtonStart => 12i32,
            Self::eIDButtonSelect => 13i32,
            Self::eIDTriggerLeft => 14i32,
            Self::eIDTriggerRight => 15i32,
            Self::eIDStickLeftHorizontal => 16i32,
            Self::eIDStickLeftVertical => 17i32,
            Self::eIDStickRightHorizontal => 18i32,
            Self::eIDStickRightVertical => 19i32,
            Self::eIDKeyboard => 20i32,
            Self::eID_INVALID => 21i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for InputControlNamesp_eHM5InputActionID {
     const TYPE_ID: &str = "InputControlNamesp_eHM5InputActionID";
}

impl StaticVariant for Vec<InputControlNamesp_eHM5InputActionID> {
     const TYPE_ID: &str = "TArray<InputControlNamesp_eHM5InputActionID>";
}

impl StaticVariant for Vec<Vec<InputControlNamesp_eHM5InputActionID>> {
     const TYPE_ID: &str = "TArray<TArray<InputControlNamesp_eHM5InputActionID>>";
}

impl Variant for InputControlNamesp_eHM5InputActionID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("InputControlNamesp_eHM5InputActionID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("InputControlNamesp_eHM5InputActionID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<InputControlNamesp_eHM5InputActionID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<InputControlNamesp_eHM5InputActionID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<InputControlNamesp_eHM5InputActionID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum InputControlNamesp_eHM5InputActionType {
    eTypeGet,
    eTypeHold,
    eTypeRepeat,
    eTypeTap,
    eTypeRelease,
    eTypeDownedge,
    eTypeFastTap,
    eTypeHoldDown,
    eTypeFireOnceHoldDown,
    eTypeClickHold,
    eTypePress,
    eTypeANALOG,
    eTypeANALOGRAW,
    eTypeRELATIVE,
    eTYPE_INVALID,
}

impl Aligned for InputControlNamesp_eHM5InputActionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for InputControlNamesp_eHM5InputActionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTypeGet => 0i32,
            Self::eTypeHold => 1i32,
            Self::eTypeRepeat => 2i32,
            Self::eTypeTap => 3i32,
            Self::eTypeRelease => 4i32,
            Self::eTypeDownedge => 5i32,
            Self::eTypeFastTap => 6i32,
            Self::eTypeHoldDown => 7i32,
            Self::eTypeFireOnceHoldDown => 8i32,
            Self::eTypeClickHold => 9i32,
            Self::eTypePress => 10i32,
            Self::eTypeANALOG => 11i32,
            Self::eTypeANALOGRAW => 12i32,
            Self::eTypeRELATIVE => 13i32,
            Self::eTYPE_INVALID => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for InputControlNamesp_eHM5InputActionType {
     const TYPE_ID: &str = "InputControlNamesp_eHM5InputActionType";
}

impl StaticVariant for Vec<InputControlNamesp_eHM5InputActionType> {
     const TYPE_ID: &str = "TArray<InputControlNamesp_eHM5InputActionType>";
}

impl StaticVariant for Vec<Vec<InputControlNamesp_eHM5InputActionType>> {
     const TYPE_ID: &str = "TArray<TArray<InputControlNamesp_eHM5InputActionType>>";
}

impl Variant for InputControlNamesp_eHM5InputActionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("InputControlNamesp_eHM5InputActionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("InputControlNamesp_eHM5InputActionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<InputControlNamesp_eHM5InputActionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<InputControlNamesp_eHM5InputActionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<InputControlNamesp_eHM5InputActionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum JSONTemplate_ETemplateType {
    ETT_BASE,
    ETT_DATA_VALUE,
    ETT_DATA_VALUE_CUSTOM,
    ETT_OBJECT,
    ETT_ARRAY,
    ETT_ASYNCROOT,
    ETT_IF,
    ETT_SWITCH,
    ETT_EACH,
    ETT_LOC,
    ETT_PARENTHESIS,
    ETT_FORMATSTRING,
    ETT_FORMATINT,
    ETT_FORMATNUMBER,
    ETT_INTCLAMP,
    ETT_FORMATPUBLICID,
    ETT_ISNULL,
    ETT_DATA_CONTEXT,
    ETT_ARRAY_ELEMENT,
    ETT_ARRAY_FILTER,
    ETT_ARRAY_CONVERT,
    ETT_ARRAY_SIZE,
    ETT_ARRAY_SORT,
    ETT_ARRAY_GROUPBY,
    ETT_EXPAND,
    ETT_ISNULLOREMPTY,
    ETT_NOT,
    ETT_COMPARE,
    ETT_PARENT,
    ETT_AND,
    ETT_OR,
    ETT_MERGEOBJECTS,
    ETT_MERGEARRAYS,
    ETT_LOCALE_TEXT,
    ETT_LOCALE_AUDIO,
    ETT_CURRENT_LOCALE_TEXT,
    ETT_GET_APPLICATION_OPTION,
    ETT_PLATFORM,
    ETT_REGION,
    ETT_STOREREGION,
    ETT_STORE,
    ETT_IS_DISC_RELEASE,
    ETT_ISDEBUG,
    ETT_INPUTCONTROLLERTYPE,
    ETT_IS_CONTROLLER_AVAILABLE,
    ETT_IS_KEYBOARD_AVAILABLE,
    ETT_IS_NEO_VR_PLATFORM,
    ETT_IS_VR_DEVICE_AVAILABLE,
    ETT_IS_VR_DEVICE_ACTIVE,
    ETT_IS_VR_ACTIVE,
    ETT_VR_MODE,
    ETT_TEMPLATES_OVERRIDE_BEGIN,
    ETT_ONLINE_RESOURCE,
    ETT_INCLUDE,
    ETT_UI_OPTION_VALUE,
    ETT_UI_OPTION_DEFAULT_VALUE,
    ETT_UI_OPTION_DEBUG_VALUE,
    ETT_UI_OPTION_AVAILABLE,
    ETT_UI_OPTION_AVAILABLE_DISPLAY_RESOLUTIONS,
    ETT_UI_OPTION_AVAILABLE_DISPLAY_FULLSCREEN,
    ETT_UI_OPTION_AVAILABLE_MOTION_BLUR,
    ETT_UI_OPTION_AVAILABLE_TEXTURE_QUALITY,
    ETT_UI_OPTION_AVAILABLE_SHADOW_QUALITY,
    ETT_UI_OPTION_AVAILABLE_SUPERSAMPLING,
    ETT_UI_OPTION_AVAILABLE_DOUBLEFRAMERATE,
    ETT_UI_OPTION_AVAILABLE_VRS,
    ETT_UI_OPTION_CAN_CHANGE_DISPLAY_RESOLUTION,
    ETT_CURRENT_CONTRACT_CONTEXT,
    ETT_CURRENT_CONTRACT_OBJECTIVES,
    ETT_CURRENT_CONTRACT_SESSIONID,
    ETT_CURRENT_CONTRACT_CHARACTER_INFO,
    ETT_CURRENT_CONTRACT_TRACKED_OPPORTUNITY,
    ETT_CURRENT_DIFFICULTY,
    ETT_CURRENT_ENGINE_MODE,
    ETT_CURRENT_GAME_MODE,
    ETT_CAN_SAVE,
    ETT_IS_SAVELIMIT_EXCEEDED,
    ETT_IS_ALLOWED_TO_RESTART,
    ETT_IS_LUDEO_CLOUD,
    ETT_ACTIVE_CHALLENGES,
    ETT_USER,
    ETT_ISUSER,
    ETT_DLCCOUNT,
    ETT_PROFILEID,
    ETT_HDRGAMMAVALUERANGEMIN,
    ETT_HDRGAMMAVALUERANGEMAX,
    ETT_HDRGAMMAVALUESTEP,
    ETT_ISDLSSAVAILABLE,
    ETT_ISXESSAVAILABLE,
    ETT_ISXESSINSTALLED,
    ETT_ISHDRAVAILABLE,
    ETT_ISHDRRENDERING,
    ETT_ISRAYTRACINGAVAILABLE,
    ETT_VARIABLERATESHADINGTIER,
    ETT_ITEM,
    ETT_REPOSITORY,
    ETT_ISONLINE,
    ETT_ISINGAME,
    ETT_ISINEDITOR,
    ETT_ISUGCRESTRICTED,
    ETT_ISPACKAGEOWNED,
    ETT_ISININVENTORY,
    ETT_ISINLOADOUT,
    ETT_ISPLATFORMENTITLEMENTOWNED,
    ETT_MULTIPLAYERLOBBYSTATE,
    ETT_MULTIPLAYERLOCALID,
    ETT_MULTIPLAYERJOINEDIDS,
    ETT_MULTIPLAYERISPLAYERREADY,
    ETT_MULTIPLAYERINFO,
    ETT_MULTIPLAYERMATCHMAKINGTIME,
    ETT_MULTIPLAYERNATTYPE,
    ETT_LOADOUT,
    ETT_LOADOUT_SLOT,
    ETT_LOADOUT_AGENCY_PICKUP,
    ETT_LOADOUT_SELECTED_ENTRANCE,
    ETT_PERSISTENTMENUDATA,
    ETT_GAMEPERSISTENTDATA,
    ETT_ENDGAME_PAGETRANSITION_OVERRIDE,
    ETT_VERSUSINFO,
    ETT_SNIPERINFO,
    ETT_GAMEMODE,
    ETT_CACHEDUSERCENTRICCONTRACT,
    ETT_SAVEGAMES,
    ETT_AVAILABILITY_OF_RESOURCES,
    ETT_AVAILABILITY_OF_CONTRACT,
    ETT_AVAILABILITY_OF_USER_CENTRIC_CONTRACT,
    ETT_AS3DATE,
    ETT_IOIACCOUNT_STATUS,
    ETT_ISCONTRACT_IN_PLAYLIST,
    ETT_ISCONTRACT_IN_PLAYLIST_MARKED_FOR_DELETION,
    ETT_IS_VR_SUPPORTED_IN_CONTRACT,
    ETT_VIDEOMEMORYINFO_IS_SUPPORTED,
    ETT_VIDEOMEMORYINFO,
    ETT_DISPLAY_SIZE,
    ETT_IS_VIDEO_VALID,
    ETT_INTEL_IDS,
    ETT_INTEL_DETAILS,
    ETT_MENU_CONFIGURATION,
    ETT_HERO_INVENTORY,
    ETT_MAP_TRACKERINFO,
    ETT_WAS_EXITGATE_TRIGGERED,
    ETT_ARE_OPPORTUNITIES_ENABLED,
    ETT_CHARACTERS,
    ETT_CHARACTERINFO,
    ETT_DATABINDING,
    ETT_DATABINDING_ROOT,
    ETT_ALLOWED_UNLOCKABLES,
    ETT_HAS_FRAMERATE_OPTION,
    ETT_MENU_DATAPROVIDER,
    ETT_INTERACTIONINDICATOR,
    ETT_NVIDIAHIGHLIGHTSAVAILABLE,
    ETT_NVIDIAHIGHLIGHTSHASHIGHLIGHTS,
    ETT_DEBUG_ALLHITMANSUITS,
}

impl Aligned for JSONTemplate_ETemplateType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for JSONTemplate_ETemplateType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETT_BASE => 0i32,
            Self::ETT_DATA_VALUE => 1i32,
            Self::ETT_DATA_VALUE_CUSTOM => 2i32,
            Self::ETT_OBJECT => 3i32,
            Self::ETT_ARRAY => 4i32,
            Self::ETT_ASYNCROOT => 5i32,
            Self::ETT_IF => 6i32,
            Self::ETT_SWITCH => 7i32,
            Self::ETT_EACH => 8i32,
            Self::ETT_LOC => 9i32,
            Self::ETT_PARENTHESIS => 10i32,
            Self::ETT_FORMATSTRING => 11i32,
            Self::ETT_FORMATINT => 12i32,
            Self::ETT_FORMATNUMBER => 13i32,
            Self::ETT_INTCLAMP => 14i32,
            Self::ETT_FORMATPUBLICID => 15i32,
            Self::ETT_ISNULL => 16i32,
            Self::ETT_DATA_CONTEXT => 17i32,
            Self::ETT_ARRAY_ELEMENT => 18i32,
            Self::ETT_ARRAY_FILTER => 19i32,
            Self::ETT_ARRAY_CONVERT => 20i32,
            Self::ETT_ARRAY_SIZE => 21i32,
            Self::ETT_ARRAY_SORT => 22i32,
            Self::ETT_ARRAY_GROUPBY => 23i32,
            Self::ETT_EXPAND => 24i32,
            Self::ETT_ISNULLOREMPTY => 25i32,
            Self::ETT_NOT => 26i32,
            Self::ETT_COMPARE => 27i32,
            Self::ETT_PARENT => 28i32,
            Self::ETT_AND => 29i32,
            Self::ETT_OR => 30i32,
            Self::ETT_MERGEOBJECTS => 31i32,
            Self::ETT_MERGEARRAYS => 32i32,
            Self::ETT_LOCALE_TEXT => 33i32,
            Self::ETT_LOCALE_AUDIO => 34i32,
            Self::ETT_CURRENT_LOCALE_TEXT => 35i32,
            Self::ETT_GET_APPLICATION_OPTION => 36i32,
            Self::ETT_PLATFORM => 37i32,
            Self::ETT_REGION => 38i32,
            Self::ETT_STOREREGION => 39i32,
            Self::ETT_STORE => 40i32,
            Self::ETT_IS_DISC_RELEASE => 41i32,
            Self::ETT_ISDEBUG => 42i32,
            Self::ETT_INPUTCONTROLLERTYPE => 43i32,
            Self::ETT_IS_CONTROLLER_AVAILABLE => 44i32,
            Self::ETT_IS_KEYBOARD_AVAILABLE => 45i32,
            Self::ETT_IS_NEO_VR_PLATFORM => 46i32,
            Self::ETT_IS_VR_DEVICE_AVAILABLE => 47i32,
            Self::ETT_IS_VR_DEVICE_ACTIVE => 48i32,
            Self::ETT_IS_VR_ACTIVE => 49i32,
            Self::ETT_VR_MODE => 50i32,
            Self::ETT_TEMPLATES_OVERRIDE_BEGIN => 51i32,
            Self::ETT_ONLINE_RESOURCE => 51i32,
            Self::ETT_INCLUDE => 52i32,
            Self::ETT_UI_OPTION_VALUE => 53i32,
            Self::ETT_UI_OPTION_DEFAULT_VALUE => 54i32,
            Self::ETT_UI_OPTION_DEBUG_VALUE => 55i32,
            Self::ETT_UI_OPTION_AVAILABLE => 56i32,
            Self::ETT_UI_OPTION_AVAILABLE_DISPLAY_RESOLUTIONS => 57i32,
            Self::ETT_UI_OPTION_AVAILABLE_DISPLAY_FULLSCREEN => 58i32,
            Self::ETT_UI_OPTION_AVAILABLE_MOTION_BLUR => 59i32,
            Self::ETT_UI_OPTION_AVAILABLE_TEXTURE_QUALITY => 60i32,
            Self::ETT_UI_OPTION_AVAILABLE_SHADOW_QUALITY => 61i32,
            Self::ETT_UI_OPTION_AVAILABLE_SUPERSAMPLING => 62i32,
            Self::ETT_UI_OPTION_AVAILABLE_DOUBLEFRAMERATE => 63i32,
            Self::ETT_UI_OPTION_AVAILABLE_VRS => 64i32,
            Self::ETT_UI_OPTION_CAN_CHANGE_DISPLAY_RESOLUTION => 65i32,
            Self::ETT_CURRENT_CONTRACT_CONTEXT => 66i32,
            Self::ETT_CURRENT_CONTRACT_OBJECTIVES => 67i32,
            Self::ETT_CURRENT_CONTRACT_SESSIONID => 68i32,
            Self::ETT_CURRENT_CONTRACT_CHARACTER_INFO => 69i32,
            Self::ETT_CURRENT_CONTRACT_TRACKED_OPPORTUNITY => 70i32,
            Self::ETT_CURRENT_DIFFICULTY => 71i32,
            Self::ETT_CURRENT_ENGINE_MODE => 72i32,
            Self::ETT_CURRENT_GAME_MODE => 73i32,
            Self::ETT_CAN_SAVE => 74i32,
            Self::ETT_IS_SAVELIMIT_EXCEEDED => 75i32,
            Self::ETT_IS_ALLOWED_TO_RESTART => 76i32,
            Self::ETT_IS_LUDEO_CLOUD => 77i32,
            Self::ETT_ACTIVE_CHALLENGES => 78i32,
            Self::ETT_USER => 79i32,
            Self::ETT_ISUSER => 80i32,
            Self::ETT_DLCCOUNT => 81i32,
            Self::ETT_PROFILEID => 82i32,
            Self::ETT_HDRGAMMAVALUERANGEMIN => 83i32,
            Self::ETT_HDRGAMMAVALUERANGEMAX => 84i32,
            Self::ETT_HDRGAMMAVALUESTEP => 85i32,
            Self::ETT_ISDLSSAVAILABLE => 86i32,
            Self::ETT_ISXESSAVAILABLE => 87i32,
            Self::ETT_ISXESSINSTALLED => 88i32,
            Self::ETT_ISHDRAVAILABLE => 89i32,
            Self::ETT_ISHDRRENDERING => 90i32,
            Self::ETT_ISRAYTRACINGAVAILABLE => 91i32,
            Self::ETT_VARIABLERATESHADINGTIER => 92i32,
            Self::ETT_ITEM => 93i32,
            Self::ETT_REPOSITORY => 94i32,
            Self::ETT_ISONLINE => 95i32,
            Self::ETT_ISINGAME => 96i32,
            Self::ETT_ISINEDITOR => 97i32,
            Self::ETT_ISUGCRESTRICTED => 98i32,
            Self::ETT_ISPACKAGEOWNED => 99i32,
            Self::ETT_ISININVENTORY => 100i32,
            Self::ETT_ISINLOADOUT => 101i32,
            Self::ETT_ISPLATFORMENTITLEMENTOWNED => 102i32,
            Self::ETT_MULTIPLAYERLOBBYSTATE => 103i32,
            Self::ETT_MULTIPLAYERLOCALID => 104i32,
            Self::ETT_MULTIPLAYERJOINEDIDS => 105i32,
            Self::ETT_MULTIPLAYERISPLAYERREADY => 106i32,
            Self::ETT_MULTIPLAYERINFO => 107i32,
            Self::ETT_MULTIPLAYERMATCHMAKINGTIME => 108i32,
            Self::ETT_MULTIPLAYERNATTYPE => 109i32,
            Self::ETT_LOADOUT => 110i32,
            Self::ETT_LOADOUT_SLOT => 111i32,
            Self::ETT_LOADOUT_AGENCY_PICKUP => 112i32,
            Self::ETT_LOADOUT_SELECTED_ENTRANCE => 113i32,
            Self::ETT_PERSISTENTMENUDATA => 114i32,
            Self::ETT_GAMEPERSISTENTDATA => 115i32,
            Self::ETT_ENDGAME_PAGETRANSITION_OVERRIDE => 116i32,
            Self::ETT_VERSUSINFO => 117i32,
            Self::ETT_SNIPERINFO => 118i32,
            Self::ETT_GAMEMODE => 119i32,
            Self::ETT_CACHEDUSERCENTRICCONTRACT => 120i32,
            Self::ETT_SAVEGAMES => 121i32,
            Self::ETT_AVAILABILITY_OF_RESOURCES => 122i32,
            Self::ETT_AVAILABILITY_OF_CONTRACT => 123i32,
            Self::ETT_AVAILABILITY_OF_USER_CENTRIC_CONTRACT => 124i32,
            Self::ETT_AS3DATE => 125i32,
            Self::ETT_IOIACCOUNT_STATUS => 126i32,
            Self::ETT_ISCONTRACT_IN_PLAYLIST => 127i32,
            Self::ETT_ISCONTRACT_IN_PLAYLIST_MARKED_FOR_DELETION => 128i32,
            Self::ETT_IS_VR_SUPPORTED_IN_CONTRACT => 129i32,
            Self::ETT_VIDEOMEMORYINFO_IS_SUPPORTED => 130i32,
            Self::ETT_VIDEOMEMORYINFO => 131i32,
            Self::ETT_DISPLAY_SIZE => 132i32,
            Self::ETT_IS_VIDEO_VALID => 133i32,
            Self::ETT_INTEL_IDS => 134i32,
            Self::ETT_INTEL_DETAILS => 135i32,
            Self::ETT_MENU_CONFIGURATION => 136i32,
            Self::ETT_HERO_INVENTORY => 137i32,
            Self::ETT_MAP_TRACKERINFO => 138i32,
            Self::ETT_WAS_EXITGATE_TRIGGERED => 139i32,
            Self::ETT_ARE_OPPORTUNITIES_ENABLED => 140i32,
            Self::ETT_CHARACTERS => 141i32,
            Self::ETT_CHARACTERINFO => 142i32,
            Self::ETT_DATABINDING => 143i32,
            Self::ETT_DATABINDING_ROOT => 144i32,
            Self::ETT_ALLOWED_UNLOCKABLES => 145i32,
            Self::ETT_HAS_FRAMERATE_OPTION => 146i32,
            Self::ETT_MENU_DATAPROVIDER => 147i32,
            Self::ETT_INTERACTIONINDICATOR => 148i32,
            Self::ETT_NVIDIAHIGHLIGHTSAVAILABLE => 149i32,
            Self::ETT_NVIDIAHIGHLIGHTSHASHIGHLIGHTS => 150i32,
            Self::ETT_DEBUG_ALLHITMANSUITS => 151i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for JSONTemplate_ETemplateType {
     const TYPE_ID: &str = "JSONTemplate_ETemplateType";
}

impl StaticVariant for Vec<JSONTemplate_ETemplateType> {
     const TYPE_ID: &str = "TArray<JSONTemplate_ETemplateType>";
}

impl StaticVariant for Vec<Vec<JSONTemplate_ETemplateType>> {
     const TYPE_ID: &str = "TArray<TArray<JSONTemplate_ETemplateType>>";
}

impl Variant for JSONTemplate_ETemplateType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("JSONTemplate_ETemplateType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("JSONTemplate_ETemplateType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<JSONTemplate_ETemplateType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<JSONTemplate_ETemplateType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<JSONTemplate_ETemplateType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum MenuWeaponUpgradeData_EUpgradeAction {
    EUPGRADE_ACTION_NONE,
    EUPGRADE_ACTION_INSTALL,
    EUPGRADE_ACTION_REMOVE,
    EUPGRADE_ACTION_UNLOCK_SLOT,
    EUPGRADE_ACTION_BUY_NEXT_LEVEL,
    EUPGRADE_ACTION_EQUIP_WEAPON,
    EUPGRADE_ACTION_UNEQUIP_WEAPON,
    EUPGRADE_ACTION_CLEAR_LEVELS,
}

impl Aligned for MenuWeaponUpgradeData_EUpgradeAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for MenuWeaponUpgradeData_EUpgradeAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EUPGRADE_ACTION_NONE => 0i32,
            Self::EUPGRADE_ACTION_INSTALL => 1i32,
            Self::EUPGRADE_ACTION_REMOVE => 2i32,
            Self::EUPGRADE_ACTION_UNLOCK_SLOT => 3i32,
            Self::EUPGRADE_ACTION_BUY_NEXT_LEVEL => 4i32,
            Self::EUPGRADE_ACTION_EQUIP_WEAPON => 5i32,
            Self::EUPGRADE_ACTION_UNEQUIP_WEAPON => 6i32,
            Self::EUPGRADE_ACTION_CLEAR_LEVELS => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for MenuWeaponUpgradeData_EUpgradeAction {
     const TYPE_ID: &str = "MenuWeaponUpgradeData_EUpgradeAction";
}

impl StaticVariant for Vec<MenuWeaponUpgradeData_EUpgradeAction> {
     const TYPE_ID: &str = "TArray<MenuWeaponUpgradeData_EUpgradeAction>";
}

impl StaticVariant for Vec<Vec<MenuWeaponUpgradeData_EUpgradeAction>> {
     const TYPE_ID: &str = "TArray<TArray<MenuWeaponUpgradeData_EUpgradeAction>>";
}

impl Variant for MenuWeaponUpgradeData_EUpgradeAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("MenuWeaponUpgradeData_EUpgradeAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("MenuWeaponUpgradeData_EUpgradeAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<MenuWeaponUpgradeData_EUpgradeAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<MenuWeaponUpgradeData_EUpgradeAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<MenuWeaponUpgradeData_EUpgradeAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum Network_OrderingChannel {
    SYSTEM_INTERNAL,
    PLAYER_INPUT,
    SYNCH_POINT,
    CAMERA,
    PROJECTILE,
    PIN_SIGNAL,
    GAME_STATE,
    HERO_STATE,
    NPC_STATE,
    WEAPONS,
    INTERACTIONS,
    ACTS,
    ANIMATION,
    MISC,
    MAX_CHANNELS,
}

impl Aligned for Network_OrderingChannel {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for Network_OrderingChannel {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SYSTEM_INTERNAL => 0i32,
            Self::PLAYER_INPUT => 1i32,
            Self::SYNCH_POINT => 2i32,
            Self::CAMERA => 3i32,
            Self::PROJECTILE => 4i32,
            Self::PIN_SIGNAL => 5i32,
            Self::GAME_STATE => 6i32,
            Self::HERO_STATE => 7i32,
            Self::NPC_STATE => 8i32,
            Self::WEAPONS => 9i32,
            Self::INTERACTIONS => 10i32,
            Self::ACTS => 11i32,
            Self::ANIMATION => 12i32,
            Self::MISC => 13i32,
            Self::MAX_CHANNELS => 16i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for Network_OrderingChannel {
     const TYPE_ID: &str = "Network_OrderingChannel";
}

impl StaticVariant for Vec<Network_OrderingChannel> {
     const TYPE_ID: &str = "TArray<Network_OrderingChannel>";
}

impl StaticVariant for Vec<Vec<Network_OrderingChannel>> {
     const TYPE_ID: &str = "TArray<TArray<Network_OrderingChannel>>";
}

impl Variant for Network_OrderingChannel {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("Network_OrderingChannel")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("Network_OrderingChannel".into()))
    }
}

inventory::submit!(&VariantDeserializer::<Network_OrderingChannel>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Network_OrderingChannel>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<Network_OrderingChannel>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum Network_PacketPriority {
    IMMEDIATE_PRIORITY,
    HIGH_PRIORITY,
    MEDIUM_PRIORITY,
    LOW_PRIORITY,
    NUMBER_OF_PRIORITIES,
}

impl Aligned for Network_PacketPriority {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for Network_PacketPriority {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IMMEDIATE_PRIORITY => 0i32,
            Self::HIGH_PRIORITY => 1i32,
            Self::MEDIUM_PRIORITY => 2i32,
            Self::LOW_PRIORITY => 3i32,
            Self::NUMBER_OF_PRIORITIES => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for Network_PacketPriority {
     const TYPE_ID: &str = "Network_PacketPriority";
}

impl StaticVariant for Vec<Network_PacketPriority> {
     const TYPE_ID: &str = "TArray<Network_PacketPriority>";
}

impl StaticVariant for Vec<Vec<Network_PacketPriority>> {
     const TYPE_ID: &str = "TArray<TArray<Network_PacketPriority>>";
}

impl Variant for Network_PacketPriority {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("Network_PacketPriority")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("Network_PacketPriority".into()))
    }
}

inventory::submit!(&VariantDeserializer::<Network_PacketPriority>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Network_PacketPriority>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<Network_PacketPriority>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum Network_PacketReliability {
    UNRELIABLE,
    UNRELIABLE_SEQUENCED,
    RELIABLE,
    RELIABLE_ORDERED,
    RELIABLE_SEQUENCED,
    UNRELIABLE_WITH_ACK_RECEIPT,
    RELIABLE_WITH_ACK_RECEIPT,
    RELIABLE_ORDERED_WITH_ACK_RECEIPT,
    NUMBER_OF_RELIABILITIES,
}

impl Aligned for Network_PacketReliability {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for Network_PacketReliability {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::UNRELIABLE => 0i32,
            Self::UNRELIABLE_SEQUENCED => 1i32,
            Self::RELIABLE => 2i32,
            Self::RELIABLE_ORDERED => 3i32,
            Self::RELIABLE_SEQUENCED => 4i32,
            Self::UNRELIABLE_WITH_ACK_RECEIPT => 5i32,
            Self::RELIABLE_WITH_ACK_RECEIPT => 6i32,
            Self::RELIABLE_ORDERED_WITH_ACK_RECEIPT => 7i32,
            Self::NUMBER_OF_RELIABILITIES => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for Network_PacketReliability {
     const TYPE_ID: &str = "Network_PacketReliability";
}

impl StaticVariant for Vec<Network_PacketReliability> {
     const TYPE_ID: &str = "TArray<Network_PacketReliability>";
}

impl StaticVariant for Vec<Vec<Network_PacketReliability>> {
     const TYPE_ID: &str = "TArray<TArray<Network_PacketReliability>>";
}

impl Variant for Network_PacketReliability {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("Network_PacketReliability")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("Network_PacketReliability".into()))
    }
}

inventory::submit!(&VariantDeserializer::<Network_PacketReliability>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Network_PacketReliability>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<Network_PacketReliability>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ReverbFidelity {
    Low,
    Medium,
    High,
}

impl Aligned for ReverbFidelity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ReverbFidelity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Low => 0i32,
            Self::Medium => 1i32,
            Self::High => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ReverbFidelity {
     const TYPE_ID: &str = "ReverbFidelity";
}

impl StaticVariant for Vec<ReverbFidelity> {
     const TYPE_ID: &str = "TArray<ReverbFidelity>";
}

impl StaticVariant for Vec<Vec<ReverbFidelity>> {
     const TYPE_ID: &str = "TArray<TArray<ReverbFidelity>>";
}

impl Variant for ReverbFidelity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ReverbFidelity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ReverbFidelity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ReverbFidelity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ReverbFidelity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ReverbFidelity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActBehaviorEntity_EState {
    UNDEFINED,
    IDLE,
    STOPPING,
    PREPARING,
    MOVING,
    ENTERING,
    RUNNING,
    TIMEDOUT,
    COMPLETE,
}

impl Aligned for ZActBehaviorEntity_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActBehaviorEntity_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::UNDEFINED => 0i32,
            Self::IDLE => 1i32,
            Self::STOPPING => 2i32,
            Self::PREPARING => 3i32,
            Self::MOVING => 4i32,
            Self::ENTERING => 5i32,
            Self::RUNNING => 6i32,
            Self::TIMEDOUT => 7i32,
            Self::COMPLETE => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActBehaviorEntity_EState {
     const TYPE_ID: &str = "ZActBehaviorEntity_EState";
}

impl StaticVariant for Vec<ZActBehaviorEntity_EState> {
     const TYPE_ID: &str = "TArray<ZActBehaviorEntity_EState>";
}

impl StaticVariant for Vec<Vec<ZActBehaviorEntity_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZActBehaviorEntity_EState>>";
}

impl Variant for ZActBehaviorEntity_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActBehaviorEntity_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActBehaviorEntity_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActBehaviorEntity_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActBehaviorEntity_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActBehaviorEntity_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum SActorSoundDefs_EDefinition {
    _NoSound,
}

impl Aligned for SActorSoundDefs_EDefinition {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for SActorSoundDefs_EDefinition {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::_NoSound => 0i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SActorSoundDefs_EDefinition {
     const TYPE_ID: &str = "SActorSoundDefs_EDefinition";
}

impl StaticVariant for Vec<SActorSoundDefs_EDefinition> {
     const TYPE_ID: &str = "TArray<SActorSoundDefs_EDefinition>";
}

impl StaticVariant for Vec<Vec<SActorSoundDefs_EDefinition>> {
     const TYPE_ID: &str = "TArray<TArray<SActorSoundDefs_EDefinition>>";
}

impl Variant for SActorSoundDefs_EDefinition {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SActorSoundDefs_EDefinition")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SActorSoundDefs_EDefinition".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SActorSoundDefs_EDefinition>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SActorSoundDefs_EDefinition>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SActorSoundDefs_EDefinition>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5BodyContainer_EBCState {
    BC_CLOSED,
    BC_OPEN,
    BC_FLUSH,
    BC_OPENING,
    BC_CLOSING,
    BC_FLUSHING,
}

impl Aligned for ZHM5BodyContainer_EBCState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5BodyContainer_EBCState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BC_CLOSED => 0i32,
            Self::BC_OPEN => 1i32,
            Self::BC_FLUSH => 2i32,
            Self::BC_OPENING => 3i32,
            Self::BC_CLOSING => 4i32,
            Self::BC_FLUSHING => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5BodyContainer_EBCState {
     const TYPE_ID: &str = "ZHM5BodyContainer_EBCState";
}

impl StaticVariant for Vec<ZHM5BodyContainer_EBCState> {
     const TYPE_ID: &str = "TArray<ZHM5BodyContainer_EBCState>";
}

impl StaticVariant for Vec<Vec<ZHM5BodyContainer_EBCState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5BodyContainer_EBCState>>";
}

impl Variant for ZHM5BodyContainer_EBCState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5BodyContainer_EBCState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5BodyContainer_EBCState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5BodyContainer_EBCState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5BodyContainer_EBCState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5BodyContainer_EBCState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousBackupGroup_EGroupState {
    GS_DistanceField,
    GS_SendBackup,
    GS_Waiting,
    GS_Completed,
}

impl Aligned for ZCautiousBackupGroup_EGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousBackupGroup_EGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::GS_DistanceField => 0i32,
            Self::GS_SendBackup => 1i32,
            Self::GS_Waiting => 2i32,
            Self::GS_Completed => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousBackupGroup_EGroupState {
     const TYPE_ID: &str = "ZCautiousBackupGroup_EGroupState";
}

impl StaticVariant for Vec<ZCautiousBackupGroup_EGroupState> {
     const TYPE_ID: &str = "TArray<ZCautiousBackupGroup_EGroupState>";
}

impl StaticVariant for Vec<Vec<ZCautiousBackupGroup_EGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousBackupGroup_EGroupState>>";
}

impl Variant for ZCautiousBackupGroup_EGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousBackupGroup_EGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousBackupGroup_EGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousBackupGroup_EGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousBackupGroup_EGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousBackupGroup_EGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousInvestigateGroup_EApproachOrderState {
    AOS_RequestHuntApproachNode,
    AOS_RequestLeaderApproachNode,
    AOS_WaitForApproachNode,
    AOS_RequestLOSNode,
    AOS_Ready,
    AOS_NoApproachNode,
}

impl Aligned for ZCautiousInvestigateGroup_EApproachOrderState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousInvestigateGroup_EApproachOrderState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AOS_RequestHuntApproachNode => 0i32,
            Self::AOS_RequestLeaderApproachNode => 1i32,
            Self::AOS_WaitForApproachNode => 2i32,
            Self::AOS_RequestLOSNode => 3i32,
            Self::AOS_Ready => 4i32,
            Self::AOS_NoApproachNode => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousInvestigateGroup_EApproachOrderState {
     const TYPE_ID: &str = "ZCautiousInvestigateGroup_EApproachOrderState";
}

impl StaticVariant for Vec<ZCautiousInvestigateGroup_EApproachOrderState> {
     const TYPE_ID: &str = "TArray<ZCautiousInvestigateGroup_EApproachOrderState>";
}

impl StaticVariant for Vec<Vec<ZCautiousInvestigateGroup_EApproachOrderState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousInvestigateGroup_EApproachOrderState>>";
}

impl Variant for ZCautiousInvestigateGroup_EApproachOrderState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousInvestigateGroup_EApproachOrderState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousInvestigateGroup_EApproachOrderState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousInvestigateGroup_EApproachOrderState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousInvestigateGroup_EApproachOrderState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousInvestigateGroup_EApproachOrderState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInvestigateCautiousSituation_EBystanderState {
    BS_SelectCandidate,
    BS_SelectPoint,
    BS_SearchDangerField,
}

impl Aligned for ZInvestigateCautiousSituation_EBystanderState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInvestigateCautiousSituation_EBystanderState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BS_SelectCandidate => 0i32,
            Self::BS_SelectPoint => 1i32,
            Self::BS_SearchDangerField => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInvestigateCautiousSituation_EBystanderState {
     const TYPE_ID: &str = "ZInvestigateCautiousSituation_EBystanderState";
}

impl StaticVariant for Vec<ZInvestigateCautiousSituation_EBystanderState> {
     const TYPE_ID: &str = "TArray<ZInvestigateCautiousSituation_EBystanderState>";
}

impl StaticVariant for Vec<Vec<ZInvestigateCautiousSituation_EBystanderState>> {
     const TYPE_ID: &str = "TArray<TArray<ZInvestigateCautiousSituation_EBystanderState>>";
}

impl Variant for ZInvestigateCautiousSituation_EBystanderState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInvestigateCautiousSituation_EBystanderState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInvestigateCautiousSituation_EBystanderState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInvestigateCautiousSituation_EBystanderState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInvestigateCautiousSituation_EBystanderState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInvestigateCautiousSituation_EBystanderState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInvestigateCautiousSituation_ESituationState {
    SS_Main,
    SS_StandDownPending,
    SS_StandDown,
}

impl Aligned for ZInvestigateCautiousSituation_ESituationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInvestigateCautiousSituation_ESituationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SS_Main => 0i32,
            Self::SS_StandDownPending => 1i32,
            Self::SS_StandDown => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInvestigateCautiousSituation_ESituationState {
     const TYPE_ID: &str = "ZInvestigateCautiousSituation_ESituationState";
}

impl StaticVariant for Vec<ZInvestigateCautiousSituation_ESituationState> {
     const TYPE_ID: &str = "TArray<ZInvestigateCautiousSituation_ESituationState>";
}

impl StaticVariant for Vec<Vec<ZInvestigateCautiousSituation_ESituationState>> {
     const TYPE_ID: &str = "TArray<TArray<ZInvestigateCautiousSituation_ESituationState>>";
}

impl Variant for ZInvestigateCautiousSituation_ESituationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInvestigateCautiousSituation_ESituationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInvestigateCautiousSituation_ESituationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInvestigateCautiousSituation_ESituationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInvestigateCautiousSituation_ESituationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInvestigateCautiousSituation_ESituationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousSearchGroup_EAssistantState {
    AS_CalculateFields,
    AS_RequestNode,
    AS_Approach,
    AS_Approaching,
    AS_Act,
    AS_Acting,
}

impl Aligned for ZCautiousSearchGroup_EAssistantState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousSearchGroup_EAssistantState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_CalculateFields => 0i32,
            Self::AS_RequestNode => 1i32,
            Self::AS_Approach => 2i32,
            Self::AS_Approaching => 3i32,
            Self::AS_Act => 4i32,
            Self::AS_Acting => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousSearchGroup_EAssistantState {
     const TYPE_ID: &str = "ZCautiousSearchGroup_EAssistantState";
}

impl StaticVariant for Vec<ZCautiousSearchGroup_EAssistantState> {
     const TYPE_ID: &str = "TArray<ZCautiousSearchGroup_EAssistantState>";
}

impl StaticVariant for Vec<Vec<ZCautiousSearchGroup_EAssistantState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousSearchGroup_EAssistantState>>";
}

impl Variant for ZCautiousSearchGroup_EAssistantState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousSearchGroup_EAssistantState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousSearchGroup_EAssistantState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousSearchGroup_EAssistantState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousSearchGroup_EAssistantState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousSearchGroup_EAssistantState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousSearchGroup_ESearchGroupState {
    SGS_Acknowledge,
    SGS_Approach,
    SGS_Approaching,
    SGS_Waiting,
    SGS_Completed,
}

impl Aligned for ZCautiousSearchGroup_ESearchGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousSearchGroup_ESearchGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SGS_Acknowledge => 0i32,
            Self::SGS_Approach => 1i32,
            Self::SGS_Approaching => 2i32,
            Self::SGS_Waiting => 3i32,
            Self::SGS_Completed => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousSearchGroup_ESearchGroupState {
     const TYPE_ID: &str = "ZCautiousSearchGroup_ESearchGroupState";
}

impl StaticVariant for Vec<ZCautiousSearchGroup_ESearchGroupState> {
     const TYPE_ID: &str = "TArray<ZCautiousSearchGroup_ESearchGroupState>";
}

impl StaticVariant for Vec<Vec<ZCautiousSearchGroup_ESearchGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousSearchGroup_ESearchGroupState>>";
}

impl Variant for ZCautiousSearchGroup_ESearchGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousSearchGroup_ESearchGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousSearchGroup_ESearchGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousSearchGroup_ESearchGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousSearchGroup_ESearchGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousSearchGroup_ESearchGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum SDoorSoundDefs_EDefinition {
    DoorOpen,
    DoorClose,
    DoorSlam,
    DoorOpenStop,
}

impl Aligned for SDoorSoundDefs_EDefinition {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for SDoorSoundDefs_EDefinition {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DoorOpen => 0i32,
            Self::DoorClose => 1i32,
            Self::DoorSlam => 2i32,
            Self::DoorOpenStop => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SDoorSoundDefs_EDefinition {
     const TYPE_ID: &str = "SDoorSoundDefs_EDefinition";
}

impl StaticVariant for Vec<SDoorSoundDefs_EDefinition> {
     const TYPE_ID: &str = "TArray<SDoorSoundDefs_EDefinition>";
}

impl StaticVariant for Vec<Vec<SDoorSoundDefs_EDefinition>> {
     const TYPE_ID: &str = "TArray<TArray<SDoorSoundDefs_EDefinition>>";
}

impl Variant for SDoorSoundDefs_EDefinition {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SDoorSoundDefs_EDefinition")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SDoorSoundDefs_EDefinition".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SDoorSoundDefs_EDefinition>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SDoorSoundDefs_EDefinition>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SDoorSoundDefs_EDefinition>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZScreenplay_EState {
    State_Idle,
    State_Running,
    State_Paused,
    State_Failed,
    State_Done,
}

impl Aligned for ZScreenplay_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZScreenplay_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::State_Idle => 0i32,
            Self::State_Running => 1i32,
            Self::State_Paused => 2i32,
            Self::State_Failed => 3i32,
            Self::State_Done => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZScreenplay_EState {
     const TYPE_ID: &str = "ZScreenplay_EState";
}

impl StaticVariant for Vec<ZScreenplay_EState> {
     const TYPE_ID: &str = "TArray<ZScreenplay_EState>";
}

impl StaticVariant for Vec<Vec<ZScreenplay_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZScreenplay_EState>>";
}

impl Variant for ZScreenplay_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZScreenplay_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZScreenplay_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZScreenplay_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZScreenplay_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZScreenplay_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEscortSituation2Entity_EEscortState {
    EES_Idle,
    EES_Evaluate,
    EES_Escorting,
    EES_Searching,
    EES_Intermediate,
}

impl Aligned for ZEscortSituation2Entity_EEscortState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEscortSituation2Entity_EEscortState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EES_Idle => 0i32,
            Self::EES_Evaluate => 1i32,
            Self::EES_Escorting => 2i32,
            Self::EES_Searching => 3i32,
            Self::EES_Intermediate => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEscortSituation2Entity_EEscortState {
     const TYPE_ID: &str = "ZEscortSituation2Entity_EEscortState";
}

impl StaticVariant for Vec<ZEscortSituation2Entity_EEscortState> {
     const TYPE_ID: &str = "TArray<ZEscortSituation2Entity_EEscortState>";
}

impl StaticVariant for Vec<Vec<ZEscortSituation2Entity_EEscortState>> {
     const TYPE_ID: &str = "TArray<TArray<ZEscortSituation2Entity_EEscortState>>";
}

impl Variant for ZEscortSituation2Entity_EEscortState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEscortSituation2Entity_EEscortState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEscortSituation2Entity_EEscortState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEscortSituation2Entity_EEscortState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEscortSituation2Entity_EEscortState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEscortSituation2Entity_EEscortState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEscortSituation2Entity_ETargetState {
    ETS_Unknown,
    ETS_NoTarget,
    ETS_RunningActBehavior,
    ETS_RunningDummyBehavior,
    ETS_RunningOtherBehavior,
    ETS_Dead,
    ETS_TargetIsHitman,
}

impl Aligned for ZEscortSituation2Entity_ETargetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEscortSituation2Entity_ETargetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETS_Unknown => 0i32,
            Self::ETS_NoTarget => 1i32,
            Self::ETS_RunningActBehavior => 2i32,
            Self::ETS_RunningDummyBehavior => 3i32,
            Self::ETS_RunningOtherBehavior => 4i32,
            Self::ETS_Dead => 5i32,
            Self::ETS_TargetIsHitman => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEscortSituation2Entity_ETargetState {
     const TYPE_ID: &str = "ZEscortSituation2Entity_ETargetState";
}

impl StaticVariant for Vec<ZEscortSituation2Entity_ETargetState> {
     const TYPE_ID: &str = "TArray<ZEscortSituation2Entity_ETargetState>";
}

impl StaticVariant for Vec<Vec<ZEscortSituation2Entity_ETargetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZEscortSituation2Entity_ETargetState>>";
}

impl Variant for ZEscortSituation2Entity_ETargetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEscortSituation2Entity_ETargetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEscortSituation2Entity_ETargetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEscortSituation2Entity_ETargetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEscortSituation2Entity_ETargetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEscortSituation2Entity_ETargetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEscortSituationEntity_EEscortState {
    EES_Idle,
    EES_Evaluate,
    EES_Escorting,
    EES_Searching,
    EES_Intermediate,
}

impl Aligned for ZEscortSituationEntity_EEscortState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEscortSituationEntity_EEscortState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EES_Idle => 0i32,
            Self::EES_Evaluate => 1i32,
            Self::EES_Escorting => 2i32,
            Self::EES_Searching => 3i32,
            Self::EES_Intermediate => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEscortSituationEntity_EEscortState {
     const TYPE_ID: &str = "ZEscortSituationEntity_EEscortState";
}

impl StaticVariant for Vec<ZEscortSituationEntity_EEscortState> {
     const TYPE_ID: &str = "TArray<ZEscortSituationEntity_EEscortState>";
}

impl StaticVariant for Vec<Vec<ZEscortSituationEntity_EEscortState>> {
     const TYPE_ID: &str = "TArray<TArray<ZEscortSituationEntity_EEscortState>>";
}

impl Variant for ZEscortSituationEntity_EEscortState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEscortSituationEntity_EEscortState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEscortSituationEntity_EEscortState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEscortSituationEntity_EEscortState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEscortSituationEntity_EEscortState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEscortSituationEntity_EEscortState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEscortSituationEntity_ETargetState {
    ETS_Unknown,
    ETS_NoTarget,
    ETS_RunningActBehavior,
    ETS_RunningDummyBehavior,
    ETS_RunningOtherBehavior,
    ETS_Dead,
    ETS_TargetIsHitman,
}

impl Aligned for ZEscortSituationEntity_ETargetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEscortSituationEntity_ETargetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETS_Unknown => 0i32,
            Self::ETS_NoTarget => 1i32,
            Self::ETS_RunningActBehavior => 2i32,
            Self::ETS_RunningDummyBehavior => 3i32,
            Self::ETS_RunningOtherBehavior => 4i32,
            Self::ETS_Dead => 5i32,
            Self::ETS_TargetIsHitman => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEscortSituationEntity_ETargetState {
     const TYPE_ID: &str = "ZEscortSituationEntity_ETargetState";
}

impl StaticVariant for Vec<ZEscortSituationEntity_ETargetState> {
     const TYPE_ID: &str = "TArray<ZEscortSituationEntity_ETargetState>";
}

impl StaticVariant for Vec<Vec<ZEscortSituationEntity_ETargetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZEscortSituationEntity_ETargetState>>";
}

impl Variant for ZEscortSituationEntity_ETargetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEscortSituationEntity_ETargetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEscortSituationEntity_ETargetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEscortSituationEntity_ETargetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEscortSituationEntity_ETargetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEscortSituationEntity_ETargetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum SFootIKEventData_EFoot {
    eLeft,
    eRight,
    eBoth,
}

impl Aligned for SFootIKEventData_EFoot {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for SFootIKEventData_EFoot {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLeft => 0i32,
            Self::eRight => 1i32,
            Self::eBoth => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SFootIKEventData_EFoot {
     const TYPE_ID: &str = "SFootIKEventData_EFoot";
}

impl StaticVariant for Vec<SFootIKEventData_EFoot> {
     const TYPE_ID: &str = "TArray<SFootIKEventData_EFoot>";
}

impl StaticVariant for Vec<Vec<SFootIKEventData_EFoot>> {
     const TYPE_ID: &str = "TArray<TArray<SFootIKEventData_EFoot>>";
}

impl Variant for SFootIKEventData_EFoot {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SFootIKEventData_EFoot")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SFootIKEventData_EFoot".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SFootIKEventData_EFoot>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SFootIKEventData_EFoot>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SFootIKEventData_EFoot>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZFriskSuspectGroup_EAssistantState {
    AS_Waiting,
    AS_Approach,
    AS_Approaching,
    AS_Covering,
}

impl Aligned for ZFriskSuspectGroup_EAssistantState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZFriskSuspectGroup_EAssistantState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_Waiting => 0i32,
            Self::AS_Approach => 1i32,
            Self::AS_Approaching => 2i32,
            Self::AS_Covering => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZFriskSuspectGroup_EAssistantState {
     const TYPE_ID: &str = "ZFriskSuspectGroup_EAssistantState";
}

impl StaticVariant for Vec<ZFriskSuspectGroup_EAssistantState> {
     const TYPE_ID: &str = "TArray<ZFriskSuspectGroup_EAssistantState>";
}

impl StaticVariant for Vec<Vec<ZFriskSuspectGroup_EAssistantState>> {
     const TYPE_ID: &str = "TArray<TArray<ZFriskSuspectGroup_EAssistantState>>";
}

impl Variant for ZFriskSuspectGroup_EAssistantState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZFriskSuspectGroup_EAssistantState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZFriskSuspectGroup_EAssistantState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZFriskSuspectGroup_EAssistantState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZFriskSuspectGroup_EAssistantState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZFriskSuspectGroup_EAssistantState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZFriskSuspectGroup_EHitmanGreetState {
    HGS_NotGreeted,
    HGS_Greeted,
    HGS_ShrugOff,
}

impl Aligned for ZFriskSuspectGroup_EHitmanGreetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZFriskSuspectGroup_EHitmanGreetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HGS_NotGreeted => 0i32,
            Self::HGS_Greeted => 1i32,
            Self::HGS_ShrugOff => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZFriskSuspectGroup_EHitmanGreetState {
     const TYPE_ID: &str = "ZFriskSuspectGroup_EHitmanGreetState";
}

impl StaticVariant for Vec<ZFriskSuspectGroup_EHitmanGreetState> {
     const TYPE_ID: &str = "TArray<ZFriskSuspectGroup_EHitmanGreetState>";
}

impl StaticVariant for Vec<Vec<ZFriskSuspectGroup_EHitmanGreetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZFriskSuspectGroup_EHitmanGreetState>>";
}

impl Variant for ZFriskSuspectGroup_EHitmanGreetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZFriskSuspectGroup_EHitmanGreetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZFriskSuspectGroup_EHitmanGreetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZFriskSuspectGroup_EHitmanGreetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZFriskSuspectGroup_EHitmanGreetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZFriskSuspectGroup_EHitmanGreetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eAmmoType {
    eAmmoGun,
    eAmmoRevolver,
    eAmmoSMG,
    eAmmoRifle,
    eAmmoShotgun,
    eAmmoSniper,
    eAmmoMG,
    eAmmoRPG,
    eAmmoFake,
    eAmmoHarmless,
    eAmmoLightPistol,
    eAmmoDartTranquilizer,
    eAmmoDartEmetic,
    eAmmoShotgunBeanbag,
    eUnknownAmmoType,
}

impl Aligned for eAmmoType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eAmmoType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAmmoGun => 0i32,
            Self::eAmmoRevolver => 1i32,
            Self::eAmmoSMG => 2i32,
            Self::eAmmoRifle => 3i32,
            Self::eAmmoShotgun => 4i32,
            Self::eAmmoSniper => 5i32,
            Self::eAmmoMG => 6i32,
            Self::eAmmoRPG => 7i32,
            Self::eAmmoFake => 8i32,
            Self::eAmmoHarmless => 9i32,
            Self::eAmmoLightPistol => 10i32,
            Self::eAmmoDartTranquilizer => 11i32,
            Self::eAmmoDartEmetic => 12i32,
            Self::eAmmoShotgunBeanbag => 13i32,
            Self::eUnknownAmmoType => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eAmmoType {
     const TYPE_ID: &str = "eAmmoType";
}

impl StaticVariant for Vec<eAmmoType> {
     const TYPE_ID: &str = "TArray<eAmmoType>";
}

impl StaticVariant for Vec<Vec<eAmmoType>> {
     const TYPE_ID: &str = "TArray<TArray<eAmmoType>>";
}

impl Variant for eAmmoType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eAmmoType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eAmmoType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eAmmoType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eAmmoType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eAmmoType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eItemType {
    eCC_FireExtinguisher_01,
    eCC_Knife,
    eCC_Axe,
    eCC_PetrolCan,
    eCC_Shovel,
    eCC_Hammer,
    eCC_Cleaver,
    eCC_AntitankMine,
    eCC_C4Brick,
    eCC_RemoteExplosive,
    eDetonator,
    eCC_Wrench,
    eCC_Dildo,
    eCC_Bottle,
    eCC_Saw,
    eCC_Screwdriver,
    eCC_MetalPipe,
    eCC_Gavel,
    eCC_Radio,
    eCC_Bong,
    eCC_Statue_Bust_A,
    eGun_44AutoMag,
    eGun_44AutoMagSilenced,
    eGun_Derringer,
    eGun_Glock,
    eGun_GlockDirty,
    eGun_GlockSilenced,
    eGun_HardBaller_01,
    eGun_HardBallerSilenced,
    eGun_Sig226,
    eGun_Sig226Silenced,
    eGun_Sphinx3000,
    eGun_Taurus24_7,
    eGun_Taurus24_7Silenced,
    eGun_Spotter,
    eOther_MG,
    eOther_RPG,
    eRevolver_PoliceRevolver,
    eRevolver_Snubnosed,
    eRevolver_Taurus,
    eRifle_HK416,
    eRifle_HK416Scope,
    eRifle_HK416Silenced,
    eRifle_PumpRifle,
    eRifle_SG552,
    eRifle_SG552Scope,
    eShotgun_M500,
    eShotgun_M500New,
    eSMG_HK_UMP,
    eSMG_HK_UMPFlashlight,
    eSMG_HK_UMPScope,
    eSMG_HK_UMPSilenced,
    eSMG_TMP,
    eSniper_AS50,
    eSniper_Remington700,
    eSniper_SakoTRG,
    eSniper_SakoTRGSilenced,
    eItemAmmo,
    eCC_FiberWire,
    eOther_ZippoLighter,
    eOther_Keycard_A,
    eOther_SecurityTape,
    eCC_PowerCord,
    eCC_PoliceBaton,
    eCC_Scissor,
    eOther_ContractEnvelope,
    eItemIrrelevantWeapon,
    eCC_BaseballBat,
    eCC_GlassShiv,
    eCC_PoolCue,
    eCC_Rake,
    eCC_ToyCar,
    eCC_Crutch,
    eCC_Guitar,
    eCC_Iron,
    eRifle_Beretta_ARX160,
    eShotgun_Spas12,
    eShotgun_Spas12_Compact,
    eShotgun_Silenced,
    eSMG_AK74u,
    eSMG_STK,
    eDLC_TEST_FireArm_01,
    eDLC_TEST_FireArm_02,
    eDLC_TEST_Prop_01,
    eDLC_TEST_Prop_02,
    eHotSauceBarrel,
    eOther_GenericPickup,
    eCC_SledgeHammer,
    eCC_Katana,
    eCC_Brick,
    cCC_Book_A,
    eSyringe_Lethal,
    eSyringe_Sedative,
    eSyringe_Emetic,
    eSuitcase,
    eOther_Camera,
    eUnknownItemType,
}

impl Aligned for eItemType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eItemType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCC_FireExtinguisher_01 => 0i32,
            Self::eCC_Knife => 10i32,
            Self::eCC_Axe => 20i32,
            Self::eCC_PetrolCan => 30i32,
            Self::eCC_Shovel => 40i32,
            Self::eCC_Hammer => 50i32,
            Self::eCC_Cleaver => 60i32,
            Self::eCC_AntitankMine => 70i32,
            Self::eCC_C4Brick => 80i32,
            Self::eCC_RemoteExplosive => 90i32,
            Self::eDetonator => 100i32,
            Self::eCC_Wrench => 110i32,
            Self::eCC_Dildo => 120i32,
            Self::eCC_Bottle => 130i32,
            Self::eCC_Saw => 140i32,
            Self::eCC_Screwdriver => 150i32,
            Self::eCC_MetalPipe => 160i32,
            Self::eCC_Gavel => 170i32,
            Self::eCC_Radio => 180i32,
            Self::eCC_Bong => 190i32,
            Self::eCC_Statue_Bust_A => 200i32,
            Self::eGun_44AutoMag => 210i32,
            Self::eGun_44AutoMagSilenced => 220i32,
            Self::eGun_Derringer => 230i32,
            Self::eGun_Glock => 240i32,
            Self::eGun_GlockDirty => 250i32,
            Self::eGun_GlockSilenced => 260i32,
            Self::eGun_HardBaller_01 => 270i32,
            Self::eGun_HardBallerSilenced => 280i32,
            Self::eGun_Sig226 => 290i32,
            Self::eGun_Sig226Silenced => 300i32,
            Self::eGun_Sphinx3000 => 310i32,
            Self::eGun_Taurus24_7 => 320i32,
            Self::eGun_Taurus24_7Silenced => 330i32,
            Self::eGun_Spotter => 340i32,
            Self::eOther_MG => 350i32,
            Self::eOther_RPG => 360i32,
            Self::eRevolver_PoliceRevolver => 370i32,
            Self::eRevolver_Snubnosed => 380i32,
            Self::eRevolver_Taurus => 390i32,
            Self::eRifle_HK416 => 400i32,
            Self::eRifle_HK416Scope => 410i32,
            Self::eRifle_HK416Silenced => 420i32,
            Self::eRifle_PumpRifle => 430i32,
            Self::eRifle_SG552 => 440i32,
            Self::eRifle_SG552Scope => 450i32,
            Self::eShotgun_M500 => 460i32,
            Self::eShotgun_M500New => 470i32,
            Self::eSMG_HK_UMP => 480i32,
            Self::eSMG_HK_UMPFlashlight => 490i32,
            Self::eSMG_HK_UMPScope => 500i32,
            Self::eSMG_HK_UMPSilenced => 510i32,
            Self::eSMG_TMP => 520i32,
            Self::eSniper_AS50 => 530i32,
            Self::eSniper_Remington700 => 540i32,
            Self::eSniper_SakoTRG => 550i32,
            Self::eSniper_SakoTRGSilenced => 560i32,
            Self::eItemAmmo => 570i32,
            Self::eCC_FiberWire => 580i32,
            Self::eOther_ZippoLighter => 590i32,
            Self::eOther_Keycard_A => 600i32,
            Self::eOther_SecurityTape => 610i32,
            Self::eCC_PowerCord => 620i32,
            Self::eCC_PoliceBaton => 630i32,
            Self::eCC_Scissor => 640i32,
            Self::eOther_ContractEnvelope => 650i32,
            Self::eItemIrrelevantWeapon => 660i32,
            Self::eCC_BaseballBat => 670i32,
            Self::eCC_GlassShiv => 680i32,
            Self::eCC_PoolCue => 690i32,
            Self::eCC_Rake => 700i32,
            Self::eCC_ToyCar => 710i32,
            Self::eCC_Crutch => 720i32,
            Self::eCC_Guitar => 730i32,
            Self::eCC_Iron => 740i32,
            Self::eRifle_Beretta_ARX160 => 760i32,
            Self::eShotgun_Spas12 => 800i32,
            Self::eShotgun_Spas12_Compact => 810i32,
            Self::eShotgun_Silenced => 830i32,
            Self::eSMG_AK74u => 860i32,
            Self::eSMG_STK => 880i32,
            Self::eDLC_TEST_FireArm_01 => 900i32,
            Self::eDLC_TEST_FireArm_02 => 901i32,
            Self::eDLC_TEST_Prop_01 => 902i32,
            Self::eDLC_TEST_Prop_02 => 903i32,
            Self::eHotSauceBarrel => 910i32,
            Self::eOther_GenericPickup => 920i32,
            Self::eCC_SledgeHammer => 921i32,
            Self::eCC_Katana => 922i32,
            Self::eCC_Brick => 923i32,
            Self::cCC_Book_A => 924i32,
            Self::eSyringe_Lethal => 931i32,
            Self::eSyringe_Sedative => 932i32,
            Self::eSyringe_Emetic => 933i32,
            Self::eSuitcase => 934i32,
            Self::eOther_Camera => 940i32,
            Self::eUnknownItemType => 1337i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eItemType {
     const TYPE_ID: &str = "eItemType";
}

impl StaticVariant for Vec<eItemType> {
     const TYPE_ID: &str = "TArray<eItemType>";
}

impl StaticVariant for Vec<Vec<eItemType>> {
     const TYPE_ID: &str = "TArray<TArray<eItemType>>";
}

impl Variant for eItemType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eItemType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eItemType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eItemType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eItemType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eItemType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDUIRoot_EHUDVisibility {
    eHV_INSTANT_OFF,
    eHV_FADE_OUT,
    eHV_FADE_IN,
    eHV_INSTANT_ON,
}

impl Aligned for ZHUDUIRoot_EHUDVisibility {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDUIRoot_EHUDVisibility {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHV_INSTANT_OFF => 0i32,
            Self::eHV_FADE_OUT => 1i32,
            Self::eHV_FADE_IN => 2i32,
            Self::eHV_INSTANT_ON => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDUIRoot_EHUDVisibility {
     const TYPE_ID: &str = "ZHUDUIRoot_EHUDVisibility";
}

impl StaticVariant for Vec<ZHUDUIRoot_EHUDVisibility> {
     const TYPE_ID: &str = "TArray<ZHUDUIRoot_EHUDVisibility>";
}

impl StaticVariant for Vec<Vec<ZHUDUIRoot_EHUDVisibility>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDUIRoot_EHUDVisibility>>";
}

impl Variant for ZHUDUIRoot_EHUDVisibility {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDUIRoot_EHUDVisibility")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDUIRoot_EHUDVisibility".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDUIRoot_EHUDVisibility>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDUIRoot_EHUDVisibility>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDUIRoot_EHUDVisibility>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroEscortSituation2Entity_EEscortState {
    EES_Idle,
    EES_Evaluate,
    EES_Escorting,
    EES_Intermediate,
    EES_OutOfRange,
}

impl Aligned for ZHeroEscortSituation2Entity_EEscortState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroEscortSituation2Entity_EEscortState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EES_Idle => 0i32,
            Self::EES_Evaluate => 1i32,
            Self::EES_Escorting => 2i32,
            Self::EES_Intermediate => 3i32,
            Self::EES_OutOfRange => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroEscortSituation2Entity_EEscortState {
     const TYPE_ID: &str = "ZHeroEscortSituation2Entity_EEscortState";
}

impl StaticVariant for Vec<ZHeroEscortSituation2Entity_EEscortState> {
     const TYPE_ID: &str = "TArray<ZHeroEscortSituation2Entity_EEscortState>";
}

impl StaticVariant for Vec<Vec<ZHeroEscortSituation2Entity_EEscortState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroEscortSituation2Entity_EEscortState>>";
}

impl Variant for ZHeroEscortSituation2Entity_EEscortState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroEscortSituation2Entity_EEscortState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroEscortSituation2Entity_EEscortState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroEscortSituation2Entity_EEscortState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroEscortSituation2Entity_EEscortState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroEscortSituation2Entity_EEscortState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroEscortSituation2Entity_ETargetState {
    ETS_Unknown,
    ETS_NoTarget,
    ETS_RunningActBehavior,
    ETS_RunningDummyBehavior,
    ETS_RunningOtherBehavior,
    ETS_Dead,
    ETS_TargetIsHitman,
}

impl Aligned for ZHeroEscortSituation2Entity_ETargetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroEscortSituation2Entity_ETargetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETS_Unknown => 0i32,
            Self::ETS_NoTarget => 1i32,
            Self::ETS_RunningActBehavior => 2i32,
            Self::ETS_RunningDummyBehavior => 3i32,
            Self::ETS_RunningOtherBehavior => 4i32,
            Self::ETS_Dead => 5i32,
            Self::ETS_TargetIsHitman => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroEscortSituation2Entity_ETargetState {
     const TYPE_ID: &str = "ZHeroEscortSituation2Entity_ETargetState";
}

impl StaticVariant for Vec<ZHeroEscortSituation2Entity_ETargetState> {
     const TYPE_ID: &str = "TArray<ZHeroEscortSituation2Entity_ETargetState>";
}

impl StaticVariant for Vec<Vec<ZHeroEscortSituation2Entity_ETargetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroEscortSituation2Entity_ETargetState>>";
}

impl Variant for ZHeroEscortSituation2Entity_ETargetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroEscortSituation2Entity_ETargetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroEscortSituation2Entity_ETargetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroEscortSituation2Entity_ETargetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroEscortSituation2Entity_ETargetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroEscortSituation2Entity_ETargetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroEscortSituationEntity_EEscortState {
    EES_Idle,
    EES_Evaluate,
    EES_Escorting,
    EES_Intermediate,
    EES_OutOfRange,
}

impl Aligned for ZHeroEscortSituationEntity_EEscortState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroEscortSituationEntity_EEscortState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EES_Idle => 0i32,
            Self::EES_Evaluate => 1i32,
            Self::EES_Escorting => 2i32,
            Self::EES_Intermediate => 3i32,
            Self::EES_OutOfRange => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroEscortSituationEntity_EEscortState {
     const TYPE_ID: &str = "ZHeroEscortSituationEntity_EEscortState";
}

impl StaticVariant for Vec<ZHeroEscortSituationEntity_EEscortState> {
     const TYPE_ID: &str = "TArray<ZHeroEscortSituationEntity_EEscortState>";
}

impl StaticVariant for Vec<Vec<ZHeroEscortSituationEntity_EEscortState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroEscortSituationEntity_EEscortState>>";
}

impl Variant for ZHeroEscortSituationEntity_EEscortState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroEscortSituationEntity_EEscortState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroEscortSituationEntity_EEscortState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroEscortSituationEntity_EEscortState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroEscortSituationEntity_EEscortState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroEscortSituationEntity_EEscortState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroEscortSituationEntity_ETargetState {
    ETS_Unknown,
    ETS_NoTarget,
    ETS_RunningActBehavior,
    ETS_RunningDummyBehavior,
    ETS_RunningOtherBehavior,
    ETS_Dead,
    ETS_TargetIsHitman,
}

impl Aligned for ZHeroEscortSituationEntity_ETargetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroEscortSituationEntity_ETargetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETS_Unknown => 0i32,
            Self::ETS_NoTarget => 1i32,
            Self::ETS_RunningActBehavior => 2i32,
            Self::ETS_RunningDummyBehavior => 3i32,
            Self::ETS_RunningOtherBehavior => 4i32,
            Self::ETS_Dead => 5i32,
            Self::ETS_TargetIsHitman => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroEscortSituationEntity_ETargetState {
     const TYPE_ID: &str = "ZHeroEscortSituationEntity_ETargetState";
}

impl StaticVariant for Vec<ZHeroEscortSituationEntity_ETargetState> {
     const TYPE_ID: &str = "TArray<ZHeroEscortSituationEntity_ETargetState>";
}

impl StaticVariant for Vec<Vec<ZHeroEscortSituationEntity_ETargetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroEscortSituationEntity_ETargetState>>";
}

impl Variant for ZHeroEscortSituationEntity_ETargetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroEscortSituationEntity_ETargetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroEscortSituationEntity_ETargetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroEscortSituationEntity_ETargetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroEscortSituationEntity_ETargetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroEscortSituationEntity_ETargetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eEvergreenItemRarity {
    SAFEHOUSEONLY,
    NONE,
    COMMON,
    RARE,
    EPIC,
    LEGENDARY,
}

impl Aligned for eEvergreenItemRarity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eEvergreenItemRarity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SAFEHOUSEONLY => -1i32,
            Self::NONE => 0i32,
            Self::COMMON => 1i32,
            Self::RARE => 2i32,
            Self::EPIC => 3i32,
            Self::LEGENDARY => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eEvergreenItemRarity {
     const TYPE_ID: &str = "eEvergreenItemRarity";
}

impl StaticVariant for Vec<eEvergreenItemRarity> {
     const TYPE_ID: &str = "TArray<eEvergreenItemRarity>";
}

impl StaticVariant for Vec<Vec<eEvergreenItemRarity>> {
     const TYPE_ID: &str = "TArray<TArray<eEvergreenItemRarity>>";
}

impl Variant for eEvergreenItemRarity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eEvergreenItemRarity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eEvergreenItemRarity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eEvergreenItemRarity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eEvergreenItemRarity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eEvergreenItemRarity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInvestigateDisguiseGroup_EState {
    eInit,
    eGuardBanter,
    eAcknowledge,
    eMain,
    eSearch,
    eMoveback,
    eStandDown,
    eEscalate,
    eDone,
}

impl Aligned for ZInvestigateDisguiseGroup_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInvestigateDisguiseGroup_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eInit => 0i32,
            Self::eGuardBanter => 1i32,
            Self::eAcknowledge => 2i32,
            Self::eMain => 3i32,
            Self::eSearch => 4i32,
            Self::eMoveback => 5i32,
            Self::eStandDown => 6i32,
            Self::eEscalate => 7i32,
            Self::eDone => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInvestigateDisguiseGroup_EState {
     const TYPE_ID: &str = "ZInvestigateDisguiseGroup_EState";
}

impl StaticVariant for Vec<ZInvestigateDisguiseGroup_EState> {
     const TYPE_ID: &str = "TArray<ZInvestigateDisguiseGroup_EState>";
}

impl StaticVariant for Vec<Vec<ZInvestigateDisguiseGroup_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZInvestigateDisguiseGroup_EState>>";
}

impl Variant for ZInvestigateDisguiseGroup_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInvestigateDisguiseGroup_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInvestigateDisguiseGroup_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInvestigateDisguiseGroup_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInvestigateDisguiseGroup_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInvestigateDisguiseGroup_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMoveToOrder_EMoveSpeed {
    MS_AUTO,
    MS_SPRINT,
    MS_JOG,
    MS_WALK,
}

impl Aligned for ZMoveToOrder_EMoveSpeed {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMoveToOrder_EMoveSpeed {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MS_AUTO => 0i32,
            Self::MS_SPRINT => 1i32,
            Self::MS_JOG => 2i32,
            Self::MS_WALK => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMoveToOrder_EMoveSpeed {
     const TYPE_ID: &str = "ZMoveToOrder_EMoveSpeed";
}

impl StaticVariant for Vec<ZMoveToOrder_EMoveSpeed> {
     const TYPE_ID: &str = "TArray<ZMoveToOrder_EMoveSpeed>";
}

impl StaticVariant for Vec<Vec<ZMoveToOrder_EMoveSpeed>> {
     const TYPE_ID: &str = "TArray<TArray<ZMoveToOrder_EMoveSpeed>>";
}

impl Variant for ZMoveToOrder_EMoveSpeed {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMoveToOrder_EMoveSpeed")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMoveToOrder_EMoveSpeed".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMoveToOrder_EMoveSpeed>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMoveToOrder_EMoveSpeed>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMoveToOrder_EMoveSpeed>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZLeadEscortSituationEntity_EEscortState {
    EES_Idle,
    EES_Evaluate,
    EES_Escorting,
    EES_Intermediate,
}

impl Aligned for ZLeadEscortSituationEntity_EEscortState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZLeadEscortSituationEntity_EEscortState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EES_Idle => 0i32,
            Self::EES_Evaluate => 1i32,
            Self::EES_Escorting => 2i32,
            Self::EES_Intermediate => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZLeadEscortSituationEntity_EEscortState {
     const TYPE_ID: &str = "ZLeadEscortSituationEntity_EEscortState";
}

impl StaticVariant for Vec<ZLeadEscortSituationEntity_EEscortState> {
     const TYPE_ID: &str = "TArray<ZLeadEscortSituationEntity_EEscortState>";
}

impl StaticVariant for Vec<Vec<ZLeadEscortSituationEntity_EEscortState>> {
     const TYPE_ID: &str = "TArray<TArray<ZLeadEscortSituationEntity_EEscortState>>";
}

impl Variant for ZLeadEscortSituationEntity_EEscortState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZLeadEscortSituationEntity_EEscortState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZLeadEscortSituationEntity_EEscortState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZLeadEscortSituationEntity_EEscortState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZLeadEscortSituationEntity_EEscortState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZLeadEscortSituationEntity_EEscortState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZLeadEscortSituationEntity_ETargetState {
    ETS_Unknown,
    ETS_NoTarget,
    ETS_RunningActBehavior,
    ETS_RunningDummyBehavior,
    ETS_RunningOtherBehavior,
    ETS_Dead,
    ETS_TargetIsHitman,
}

impl Aligned for ZLeadEscortSituationEntity_ETargetState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZLeadEscortSituationEntity_ETargetState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETS_Unknown => 0i32,
            Self::ETS_NoTarget => 1i32,
            Self::ETS_RunningActBehavior => 2i32,
            Self::ETS_RunningDummyBehavior => 3i32,
            Self::ETS_RunningOtherBehavior => 4i32,
            Self::ETS_Dead => 5i32,
            Self::ETS_TargetIsHitman => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZLeadEscortSituationEntity_ETargetState {
     const TYPE_ID: &str = "ZLeadEscortSituationEntity_ETargetState";
}

impl StaticVariant for Vec<ZLeadEscortSituationEntity_ETargetState> {
     const TYPE_ID: &str = "TArray<ZLeadEscortSituationEntity_ETargetState>";
}

impl StaticVariant for Vec<Vec<ZLeadEscortSituationEntity_ETargetState>> {
     const TYPE_ID: &str = "TArray<TArray<ZLeadEscortSituationEntity_ETargetState>>";
}

impl Variant for ZLeadEscortSituationEntity_ETargetState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZLeadEscortSituationEntity_ETargetState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZLeadEscortSituationEntity_ETargetState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZLeadEscortSituationEntity_ETargetState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZLeadEscortSituationEntity_ETargetState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZLeadEscortSituationEntity_ETargetState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSequenceEntity_ECommand {
    COMMAND_START,
    COMMAND_ENABLE_PREVIEW,
    COMMAND_STOP,
    COMMAND_DISABLE_PREVIEW,
    COMMAND_ABORT,
    COMMAND_PAUSE,
    COMMAND_UNPAUSE,
    COMMAND_SETTIME,
    COMMAND_SKIPTOEND,
    COMMAND_GAME_PAUSE,
    COMMAND_GAME_UNPAUSE,
    COMMAND_PREVIEW_PAUSE,
    COMMAND_PREVIEW_STOP,
    COMMAND_PREVIEW_PLAY,
    COMMAND_PREVIEW_LOOPED,
    COMMAND_CLEAR,
}

impl Aligned for ZSequenceEntity_ECommand {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSequenceEntity_ECommand {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::COMMAND_START => 0i32,
            Self::COMMAND_ENABLE_PREVIEW => 1i32,
            Self::COMMAND_STOP => 2i32,
            Self::COMMAND_DISABLE_PREVIEW => 3i32,
            Self::COMMAND_ABORT => 4i32,
            Self::COMMAND_PAUSE => 5i32,
            Self::COMMAND_UNPAUSE => 6i32,
            Self::COMMAND_SETTIME => 7i32,
            Self::COMMAND_SKIPTOEND => 8i32,
            Self::COMMAND_GAME_PAUSE => 9i32,
            Self::COMMAND_GAME_UNPAUSE => 10i32,
            Self::COMMAND_PREVIEW_PAUSE => 11i32,
            Self::COMMAND_PREVIEW_STOP => 12i32,
            Self::COMMAND_PREVIEW_PLAY => 13i32,
            Self::COMMAND_PREVIEW_LOOPED => 14i32,
            Self::COMMAND_CLEAR => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSequenceEntity_ECommand {
     const TYPE_ID: &str = "ZSequenceEntity_ECommand";
}

impl StaticVariant for Vec<ZSequenceEntity_ECommand> {
     const TYPE_ID: &str = "TArray<ZSequenceEntity_ECommand>";
}

impl StaticVariant for Vec<Vec<ZSequenceEntity_ECommand>> {
     const TYPE_ID: &str = "TArray<TArray<ZSequenceEntity_ECommand>>";
}

impl Variant for ZSequenceEntity_ECommand {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSequenceEntity_ECommand")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSequenceEntity_ECommand".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSequenceEntity_ECommand>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSequenceEntity_ECommand>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSequenceEntity_ECommand>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSmuggleSituationEntity_ESmuggleState {
    ESS_Idle,
    ESS_Evaluate,
    ESS_FindJob,
    ESS_OnRouteToLocation,
    ESS_PickingUp,
    ESS_PuttingDown,
    ESS_OnABreak,
}

impl Aligned for ZSmuggleSituationEntity_ESmuggleState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSmuggleSituationEntity_ESmuggleState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ESS_Idle => 0i32,
            Self::ESS_Evaluate => 1i32,
            Self::ESS_FindJob => 2i32,
            Self::ESS_OnRouteToLocation => 3i32,
            Self::ESS_PickingUp => 4i32,
            Self::ESS_PuttingDown => 5i32,
            Self::ESS_OnABreak => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSmuggleSituationEntity_ESmuggleState {
     const TYPE_ID: &str = "ZSmuggleSituationEntity_ESmuggleState";
}

impl StaticVariant for Vec<ZSmuggleSituationEntity_ESmuggleState> {
     const TYPE_ID: &str = "TArray<ZSmuggleSituationEntity_ESmuggleState>";
}

impl StaticVariant for Vec<Vec<ZSmuggleSituationEntity_ESmuggleState>> {
     const TYPE_ID: &str = "TArray<TArray<ZSmuggleSituationEntity_ESmuggleState>>";
}

impl Variant for ZSmuggleSituationEntity_ESmuggleState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSmuggleSituationEntity_ESmuggleState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSmuggleSituationEntity_ESmuggleState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSmuggleSituationEntity_ESmuggleState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSmuggleSituationEntity_ESmuggleState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSmuggleSituationEntity_ESmuggleState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum STestStruct_ETestEnum {
    ETomato,
    EPotato,
}

impl Aligned for STestStruct_ETestEnum {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for STestStruct_ETestEnum {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETomato => 3i32,
            Self::EPotato => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for STestStruct_ETestEnum {
     const TYPE_ID: &str = "STestStruct_ETestEnum";
}

impl StaticVariant for Vec<STestStruct_ETestEnum> {
     const TYPE_ID: &str = "TArray<STestStruct_ETestEnum>";
}

impl StaticVariant for Vec<Vec<STestStruct_ETestEnum>> {
     const TYPE_ID: &str = "TArray<TArray<STestStruct_ETestEnum>>";
}

impl Variant for STestStruct_ETestEnum {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("STestStruct_ETestEnum")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("STestStruct_ETestEnum".into()))
    }
}

inventory::submit!(&VariantDeserializer::<STestStruct_ETestEnum>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<STestStruct_ETestEnum>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<STestStruct_ETestEnum>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum _EUIOptionKey {
    UI_OPTION_GAME_VIBRATION,
    UI_OPTION_GAME_ADAPTIVE_FEEDBACK,
    UI_OPTION_GAME_AIM_ASSIST,
    UI_OPTION_GAME_AIM_CAUSAL,
    UI_OPTION_GAME_INVERT_INVENTORY_EMOTE,
    UI_OPTION_GAME_INVERT_X,
    UI_OPTION_GAME_INVERT_MOUSE_X,
    UI_OPTION_GAME_INVERT_MOUSE_Y,
    UI_OPTION_GAME_INVERT_Y,
    UI_OPTION_GAME_CONTROL_SCHEME,
    UI_OPTION_GAME_FAST_TARGET,
    UI_OPTION_GAME_ALLOW_CAMERA_SWITCH,
    UI_OPTION_GAME_DIFFICULTY,
    UI_OPTION_GAME_TRIGGER_SHOOT,
    UI_OPTION_GAME_SWITCH_SNEAK_AND_CAMERA,
    UI_OPTION_GAME_LEFT_HANDED_CONTROLS,
    UI_OPTION_GAME_CAMERA_SENSITIVITY_HORZ,
    UI_OPTION_GAME_CAMERA_SENSITIVITY_VERT,
    UI_OPTION_GAME_MOUSE_SENSITIVITY,
    UI_OPTION_GAME_AIM_SENSITIVITY,
    UI_OPTION_GAME_CAMERA_SENSITIVITY,
    UI_OPTION_GAME_INSTINCT_PATHS,
    UI_OPTION_GAME_INSTINCT_NPCGLOW,
    UI_OPTION_GAME_HINTS_TUTORIAL,
    UI_OPTION_GAME_HINTS_INSTINCT,
    UI_OPTION_GAME_LANG_AUDIO,
    UI_OPTION_GAME_LANG_TEXT,
    UI_OPTION_GAME_COVER_TOGGLE,
    UI_OPTION_GAME_FIXED_MAP,
    UI_OPTION_GAME_MAP_SHOW_NORTH_INDICATOR,
    UI_OPTION_GAME_AID_OPPORTUNITIES,
    UI_OPTION_GAME_AID_INSTINCT,
    UI_OPTION_GAME_AID_MINI_MAP,
    UI_OPTION_GAME_AID_NPC_ICONS,
    UI_OPTION_GAME_AID_ATTENTION,
    UI_OPTION_GAME_AID_VITAL_INFO,
    UI_OPTION_GAME_AID_INTERACTION_H,
    UI_OPTION_GAME_AID_OBJECTIVES,
    UI_OPTION_GAME_AID_WEAPON_HUD,
    UI_OPTION_GAME_AID_CHALLENGEDESCRIPTION,
    UI_OPTION_GAME_MINI_MAP_SHOW_NPCS,
    UI_OPTION_GAME_AID_TARGET_INFO,
    UI_OPTION_GAME_AID_CHALLENGE_HUD,
    UI_OPTION_GAME_MINI_MAP_SHOW_TARGETS,
    UI_OPTION_GAME_CHALLENGES_FILTER,
    UI_OPTION_GAME_AID_MISSION_TIMER,
    UI_OPTION_GAME_DIFFICULTY_LEVEL_HUD,
    UI_OPTION_GAME_AID_GLOBAL_HINTS,
    UI_OPTION_GAME_SCORE_HUD,
    UI_OPTION_GAME_AID_LVA,
    UI_OPTION_GAME_AID_PICTURE_IN_PICTURE,
    UI_OPTION_GAME_AID_INTERACTION_PROMPT,
    UI_OPTION_GAME_AID_SA_HUD,
    UI_OPTION_GAME_AID_RELOAD_HUD,
    UI_OPTION_GAME_AID_CAMERA_GRID,
    UI_OPTION_GAME_AID_AIM_TOGGLE,
    UI_OPTION_GAME_AID_OBJECTIVES_VR,
    UI_OPTION_GAME_AID_WEAPON_HUD_VR,
    UI_OPTION_GAME_AID_RELOAD_HUD_VR,
    UI_OPTION_GAME_AID_MINI_MAP_VR,
    UI_OPTION_GAME_AUTOSAVE,
    UI_OPTION_GAME_AUTOSAVE_VR,
    UI_OPTION_GAME_AUTOSAVE_HUD,
    UI_OPTION_GAME_AID_WALK_SPEED_TOGGLE,
    UI_OPTION_GAME_AID_INSTINCT_ACTIVATION_TOGGLE,
    UI_OPTION_GAME_AID_PRECISION_AIM_TOGGLE,
    UI_OPTION_GAME_AID_ITEM_PLACEMENT_TOGGLE,
    UI_OPTION_GAME_FREELANCER_ALERTED_TERRITORY,
    UI_OPTION_GAME_FREELANCER_ASSASSIN_PROXIMITY,
    UI_OPTION_GAME_FREELANCER_LOOKOUT_PROXIMITY,
    UI_OPTION_GAME_FREELANCER_MERCES_INDICATOR,
    UI_OPTION_SOUND_VOLUME_MASTER,
    UI_OPTION_SOUND_VOLUME_EFFECTS,
    UI_OPTION_SOUND_VOLUME_MUSIC,
    UI_OPTION_SOUND_VOLUME_DIALOGUE,
    UI_OPTION_SOUND_MUTE_MICROPHONE,
    UI_OPTION_SOUND_MUTE_OTHER_PLAYER,
    UI_OPTION_SOUND_OUTPUTMODE,
    UI_OPTION_SOUND_SIMULATION_QUALITY,
    UI_OPTION_SOUND_DYNAMIC_RANGE_MODE,
    UI_OPTION_SOUND_DYNAMIC_RANGE_MODE_VR,
    UI_OPTION_GRAPHICS_SUBTITLES,
    UI_OPTION_GRAPHICS_SUBTITLES_SIZE,
    UI_OPTION_GRAPHICS_SUBTITLES_BGALPHA,
    UI_OPTION_GRAPHICS_SUBTITLES_VR,
    UI_OPTION_GRAPHICS_SUBTITLES_SIZE_VR,
    UI_OPTION_GRAPHICS_SUBTITLES_SPEAKER,
    UI_OPTION_GRAPHICS_SAFE_AREA_X,
    UI_OPTION_GRAPHICS_SAFE_AREA_Y,
    UI_OPTION_GSM_AUTHORITY_BEGIN_MARKER,
    UI_OPTION_DISPLAY_RESOLUTION,
    UI_OPTION_DISPLAY_REFRESHRATE,
    UI_OPTION_DISPLAY_FULLSCREEN,
    UI_OPTION_DISPLAY_EXCLUSIVE,
    UI_OPTION_DISPLAY_VSYNC,
    UI_OPTION_DISPLAY_MONITOR,
    UI_OPTION_DISPLAY_QUALITY,
    UI_OPTION_DISPLAY_ASPECT,
    UI_OPTION_DISPLAY_STEREOSCOPIC,
    UI_OPTION_DISPLAY_STEREO_DEPTH,
    UI_OPTION_DISPLAY_STEREO_STRENGTH,
    UI_OPTION_GRAPHICS_QUALITY,
    UI_OPTION_GRAPHICS_SHADOW_QUALITY,
    UI_OPTION_GRAPHICS_SHADOW_RESOLUTION,
    UI_OPTION_GRAPHICS_TEXTURE_QUALITY,
    UI_OPTION_GRAPHICS_TEXTURE_FILTER,
    UI_OPTION_GRAPHICS_ASSAO_QUALITY,
    UI_OPTION_GRAPHICS_VSYNC,
    UI_OPTION_GRAPHICS_TESSELLATION,
    UI_OPTION_GRAPHICS_MIRRORS,
    UI_OPTION_GRAPHICS_LOD,
    UI_OPTION_GRAPHICS_MOTIONBLUR,
    UI_OPTION_GRAPHICS_BOKEH,
    UI_OPTION_GRAPHICS_REFLECTION_QUALITY,
    UI_OPTION_GRAPHICS_MOTION_BLUR,
    UI_OPTION_GRAPHICS_DYNAMIC_SHARPENING,
    UI_OPTION_GRAPHICS_SIMULATION_QUALITY,
    UI_OPTION_GRAPHICS_SSR,
    UI_OPTION_GRAPHICS_VRS,
    UI_OPTION_GRAPHICS_ATMOSPHERIC_QUALITY,
    UI_OPTION_GRAPHICS_SUPER_SAMPLING,
    UI_OPTION_GRAPHICS_GAMMA,
    UI_OPTION_GRAPHICS_REFLEX,
    UI_OPTION_GRAPHICS_DLSSG,
    UI_OPTION_GRAPHICS_RT_ENABLED,
    UI_OPTION_GRAPHICS_RT_SHADOW_QUALITY,
    UI_OPTION_GRAPHICS_RT_REFLECTION_QUALITY,
    UI_OPTION_GRAPHICS_SSAA_METHOD,
    UI_OPTION_GRAPHICS_SSAA_QUALITY,
    UI_OPTION_GRAPHICS_FRAMERATE_LIMIT,
    UI_OPTION_GRAPHICS_HDR,
    UI_OPTION_GSM_AUTHORITY_END_MARKER,
    UI_OPTION_GRAPHICS_HDR_GAMMA,
    UI_OPTION_GRAPHICS_RENDERING_QUALITY,
    UI_OPTION_GRAPHICS_NEUTRAL_LUT_BLEND,
    UI_OPTION_GRAPHICS_DIFFUSE_COLOR_CLAMP,
    UI_OPTION_GRAPHICS_VR_QUALITY,
    UI_OPTION_VR_BLINDERS_ENABLED,
    UI_OPTION_VR_BLINDERS_STRENGTH,
    UI_OPTION_VR_TURN_MODE,
    UI_OPTION_VR_HEAD_BASED_MOVEMENT,
    UI_OPTION_VR_FADE_ON_COLLISION,
    UI_OPTION_VR_TURN_RATE,
    UI_OPTION_VR_TURN_SPEED,
    UI_OPTION_VR_MINIMUM_REPROJECTION_COLOR,
    UI_OPTION_VR_LEFT_HAND_FOLLOW_RIGHT,
    UI_OPTION_VR_SAFE_AREA_ENABLED,
}

impl Aligned for _EUIOptionKey {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for _EUIOptionKey {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::UI_OPTION_GAME_VIBRATION => 100i32,
            Self::UI_OPTION_GAME_ADAPTIVE_FEEDBACK => 110i32,
            Self::UI_OPTION_GAME_AIM_ASSIST => 200i32,
            Self::UI_OPTION_GAME_AIM_CAUSAL => 210i32,
            Self::UI_OPTION_GAME_INVERT_INVENTORY_EMOTE => 220i32,
            Self::UI_OPTION_GAME_INVERT_X => 300i32,
            Self::UI_OPTION_GAME_INVERT_MOUSE_X => 301i32,
            Self::UI_OPTION_GAME_INVERT_MOUSE_Y => 302i32,
            Self::UI_OPTION_GAME_INVERT_Y => 310i32,
            Self::UI_OPTION_GAME_CONTROL_SCHEME => 311i32,
            Self::UI_OPTION_GAME_FAST_TARGET => 312i32,
            Self::UI_OPTION_GAME_ALLOW_CAMERA_SWITCH => 313i32,
            Self::UI_OPTION_GAME_DIFFICULTY => 321i32,
            Self::UI_OPTION_GAME_TRIGGER_SHOOT => 330i32,
            Self::UI_OPTION_GAME_SWITCH_SNEAK_AND_CAMERA => 332i32,
            Self::UI_OPTION_GAME_LEFT_HANDED_CONTROLS => 333i32,
            Self::UI_OPTION_GAME_CAMERA_SENSITIVITY_HORZ => 334i32,
            Self::UI_OPTION_GAME_CAMERA_SENSITIVITY_VERT => 335i32,
            Self::UI_OPTION_GAME_MOUSE_SENSITIVITY => 336i32,
            Self::UI_OPTION_GAME_AIM_SENSITIVITY => 337i32,
            Self::UI_OPTION_GAME_CAMERA_SENSITIVITY => 338i32,
            Self::UI_OPTION_GAME_INSTINCT_PATHS => 340i32,
            Self::UI_OPTION_GAME_INSTINCT_NPCGLOW => 342i32,
            Self::UI_OPTION_GAME_HINTS_TUTORIAL => 346i32,
            Self::UI_OPTION_GAME_HINTS_INSTINCT => 348i32,
            Self::UI_OPTION_GAME_LANG_AUDIO => 350i32,
            Self::UI_OPTION_GAME_LANG_TEXT => 351i32,
            Self::UI_OPTION_GAME_COVER_TOGGLE => 352i32,
            Self::UI_OPTION_GAME_FIXED_MAP => 353i32,
            Self::UI_OPTION_GAME_MAP_SHOW_NORTH_INDICATOR => 354i32,
            Self::UI_OPTION_GAME_AID_OPPORTUNITIES => 360i32,
            Self::UI_OPTION_GAME_AID_INSTINCT => 361i32,
            Self::UI_OPTION_GAME_AID_MINI_MAP => 362i32,
            Self::UI_OPTION_GAME_AID_NPC_ICONS => 363i32,
            Self::UI_OPTION_GAME_AID_ATTENTION => 364i32,
            Self::UI_OPTION_GAME_AID_VITAL_INFO => 365i32,
            Self::UI_OPTION_GAME_AID_INTERACTION_H => 366i32,
            Self::UI_OPTION_GAME_AID_OBJECTIVES => 367i32,
            Self::UI_OPTION_GAME_AID_WEAPON_HUD => 368i32,
            Self::UI_OPTION_GAME_AID_CHALLENGEDESCRIPTION => 369i32,
            Self::UI_OPTION_GAME_MINI_MAP_SHOW_NPCS => 370i32,
            Self::UI_OPTION_GAME_AID_TARGET_INFO => 371i32,
            Self::UI_OPTION_GAME_AID_CHALLENGE_HUD => 372i32,
            Self::UI_OPTION_GAME_MINI_MAP_SHOW_TARGETS => 373i32,
            Self::UI_OPTION_GAME_CHALLENGES_FILTER => 374i32,
            Self::UI_OPTION_GAME_AID_MISSION_TIMER => 375i32,
            Self::UI_OPTION_GAME_DIFFICULTY_LEVEL_HUD => 376i32,
            Self::UI_OPTION_GAME_AID_GLOBAL_HINTS => 377i32,
            Self::UI_OPTION_GAME_SCORE_HUD => 378i32,
            Self::UI_OPTION_GAME_AID_LVA => 379i32,
            Self::UI_OPTION_GAME_AID_PICTURE_IN_PICTURE => 380i32,
            Self::UI_OPTION_GAME_AID_INTERACTION_PROMPT => 381i32,
            Self::UI_OPTION_GAME_AID_SA_HUD => 382i32,
            Self::UI_OPTION_GAME_AID_RELOAD_HUD => 383i32,
            Self::UI_OPTION_GAME_AID_CAMERA_GRID => 384i32,
            Self::UI_OPTION_GAME_AID_AIM_TOGGLE => 385i32,
            Self::UI_OPTION_GAME_AID_OBJECTIVES_VR => 386i32,
            Self::UI_OPTION_GAME_AID_WEAPON_HUD_VR => 387i32,
            Self::UI_OPTION_GAME_AID_RELOAD_HUD_VR => 388i32,
            Self::UI_OPTION_GAME_AID_MINI_MAP_VR => 389i32,
            Self::UI_OPTION_GAME_AUTOSAVE => 390i32,
            Self::UI_OPTION_GAME_AUTOSAVE_VR => 391i32,
            Self::UI_OPTION_GAME_AUTOSAVE_HUD => 400i32,
            Self::UI_OPTION_GAME_AID_WALK_SPEED_TOGGLE => 420i32,
            Self::UI_OPTION_GAME_AID_INSTINCT_ACTIVATION_TOGGLE => 421i32,
            Self::UI_OPTION_GAME_AID_PRECISION_AIM_TOGGLE => 422i32,
            Self::UI_OPTION_GAME_AID_ITEM_PLACEMENT_TOGGLE => 423i32,
            Self::UI_OPTION_GAME_FREELANCER_ALERTED_TERRITORY => 440i32,
            Self::UI_OPTION_GAME_FREELANCER_ASSASSIN_PROXIMITY => 441i32,
            Self::UI_OPTION_GAME_FREELANCER_LOOKOUT_PROXIMITY => 442i32,
            Self::UI_OPTION_GAME_FREELANCER_MERCES_INDICATOR => 443i32,
            Self::UI_OPTION_SOUND_VOLUME_MASTER => 1010i32,
            Self::UI_OPTION_SOUND_VOLUME_EFFECTS => 1020i32,
            Self::UI_OPTION_SOUND_VOLUME_MUSIC => 1030i32,
            Self::UI_OPTION_SOUND_VOLUME_DIALOGUE => 1040i32,
            Self::UI_OPTION_SOUND_MUTE_MICROPHONE => 1050i32,
            Self::UI_OPTION_SOUND_MUTE_OTHER_PLAYER => 1060i32,
            Self::UI_OPTION_SOUND_OUTPUTMODE => 1200i32,
            Self::UI_OPTION_SOUND_SIMULATION_QUALITY => 1210i32,
            Self::UI_OPTION_SOUND_DYNAMIC_RANGE_MODE => 1220i32,
            Self::UI_OPTION_SOUND_DYNAMIC_RANGE_MODE_VR => 1221i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES => 2000i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES_SIZE => 2001i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES_BGALPHA => 2002i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES_VR => 2010i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES_SIZE_VR => 2011i32,
            Self::UI_OPTION_GRAPHICS_SUBTITLES_SPEAKER => 2020i32,
            Self::UI_OPTION_GRAPHICS_SAFE_AREA_X => 2210i32,
            Self::UI_OPTION_GRAPHICS_SAFE_AREA_Y => 2220i32,
            Self::UI_OPTION_GSM_AUTHORITY_BEGIN_MARKER => 2221i32,
            Self::UI_OPTION_DISPLAY_RESOLUTION => 2230i32,
            Self::UI_OPTION_DISPLAY_REFRESHRATE => 2240i32,
            Self::UI_OPTION_DISPLAY_FULLSCREEN => 2250i32,
            Self::UI_OPTION_DISPLAY_EXCLUSIVE => 2260i32,
            Self::UI_OPTION_DISPLAY_VSYNC => 2270i32,
            Self::UI_OPTION_DISPLAY_MONITOR => 2280i32,
            Self::UI_OPTION_DISPLAY_QUALITY => 2290i32,
            Self::UI_OPTION_DISPLAY_ASPECT => 2300i32,
            Self::UI_OPTION_DISPLAY_STEREOSCOPIC => 2310i32,
            Self::UI_OPTION_DISPLAY_STEREO_DEPTH => 2320i32,
            Self::UI_OPTION_DISPLAY_STEREO_STRENGTH => 2330i32,
            Self::UI_OPTION_GRAPHICS_QUALITY => 2600i32,
            Self::UI_OPTION_GRAPHICS_SHADOW_QUALITY => 2610i32,
            Self::UI_OPTION_GRAPHICS_SHADOW_RESOLUTION => 2620i32,
            Self::UI_OPTION_GRAPHICS_TEXTURE_QUALITY => 2630i32,
            Self::UI_OPTION_GRAPHICS_TEXTURE_FILTER => 2640i32,
            Self::UI_OPTION_GRAPHICS_ASSAO_QUALITY => 2650i32,
            Self::UI_OPTION_GRAPHICS_VSYNC => 2660i32,
            Self::UI_OPTION_GRAPHICS_TESSELLATION => 2680i32,
            Self::UI_OPTION_GRAPHICS_MIRRORS => 2690i32,
            Self::UI_OPTION_GRAPHICS_LOD => 2710i32,
            Self::UI_OPTION_GRAPHICS_MOTIONBLUR => 2720i32,
            Self::UI_OPTION_GRAPHICS_BOKEH => 2740i32,
            Self::UI_OPTION_GRAPHICS_REFLECTION_QUALITY => 2742i32,
            Self::UI_OPTION_GRAPHICS_MOTION_BLUR => 2743i32,
            Self::UI_OPTION_GRAPHICS_DYNAMIC_SHARPENING => 2744i32,
            Self::UI_OPTION_GRAPHICS_SIMULATION_QUALITY => 2745i32,
            Self::UI_OPTION_GRAPHICS_SSR => 2746i32,
            Self::UI_OPTION_GRAPHICS_VRS => 2747i32,
            Self::UI_OPTION_GRAPHICS_ATMOSPHERIC_QUALITY => 2749i32,
            Self::UI_OPTION_GRAPHICS_SUPER_SAMPLING => 2750i32,
            Self::UI_OPTION_GRAPHICS_GAMMA => 2760i32,
            Self::UI_OPTION_GRAPHICS_REFLEX => 2761i32,
            Self::UI_OPTION_GRAPHICS_DLSSG => 2762i32,
            Self::UI_OPTION_GRAPHICS_RT_ENABLED => 2765i32,
            Self::UI_OPTION_GRAPHICS_RT_SHADOW_QUALITY => 2766i32,
            Self::UI_OPTION_GRAPHICS_RT_REFLECTION_QUALITY => 2767i32,
            Self::UI_OPTION_GRAPHICS_SSAA_METHOD => 2768i32,
            Self::UI_OPTION_GRAPHICS_SSAA_QUALITY => 2769i32,
            Self::UI_OPTION_GRAPHICS_FRAMERATE_LIMIT => 2770i32,
            Self::UI_OPTION_GRAPHICS_HDR => 2771i32,
            Self::UI_OPTION_GSM_AUTHORITY_END_MARKER => 2771i32,
            Self::UI_OPTION_GRAPHICS_HDR_GAMMA => 2772i32,
            Self::UI_OPTION_GRAPHICS_RENDERING_QUALITY => 2773i32,
            Self::UI_OPTION_GRAPHICS_NEUTRAL_LUT_BLEND => 2774i32,
            Self::UI_OPTION_GRAPHICS_DIFFUSE_COLOR_CLAMP => 2775i32,
            Self::UI_OPTION_GRAPHICS_VR_QUALITY => 2800i32,
            Self::UI_OPTION_VR_BLINDERS_ENABLED => 3000i32,
            Self::UI_OPTION_VR_BLINDERS_STRENGTH => 3001i32,
            Self::UI_OPTION_VR_TURN_MODE => 3002i32,
            Self::UI_OPTION_VR_HEAD_BASED_MOVEMENT => 3003i32,
            Self::UI_OPTION_VR_FADE_ON_COLLISION => 3004i32,
            Self::UI_OPTION_VR_TURN_RATE => 3005i32,
            Self::UI_OPTION_VR_TURN_SPEED => 3006i32,
            Self::UI_OPTION_VR_MINIMUM_REPROJECTION_COLOR => 3007i32,
            Self::UI_OPTION_VR_LEFT_HAND_FOLLOW_RIGHT => 3008i32,
            Self::UI_OPTION_VR_SAFE_AREA_ENABLED => 3009i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for _EUIOptionKey {
     const TYPE_ID: &str = "_EUIOptionKey";
}

impl StaticVariant for Vec<_EUIOptionKey> {
     const TYPE_ID: &str = "TArray<_EUIOptionKey>";
}

impl StaticVariant for Vec<Vec<_EUIOptionKey>> {
     const TYPE_ID: &str = "TArray<TArray<_EUIOptionKey>>";
}

impl Variant for _EUIOptionKey {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("_EUIOptionKey")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("_EUIOptionKey".into()))
    }
}

inventory::submit!(&VariantDeserializer::<_EUIOptionKey>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<_EUIOptionKey>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<_EUIOptionKey>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum SUITestData_ETestEnum {
    ETestEnum_Value_One,
    ETestEnum_Value_Two,
    ETestEnum_Value_Three,
}

impl Aligned for SUITestData_ETestEnum {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for SUITestData_ETestEnum {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETestEnum_Value_One => 1i32,
            Self::ETestEnum_Value_Two => 2i32,
            Self::ETestEnum_Value_Three => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SUITestData_ETestEnum {
     const TYPE_ID: &str = "SUITestData_ETestEnum";
}

impl StaticVariant for Vec<SUITestData_ETestEnum> {
     const TYPE_ID: &str = "TArray<SUITestData_ETestEnum>";
}

impl StaticVariant for Vec<Vec<SUITestData_ETestEnum>> {
     const TYPE_ID: &str = "TArray<TArray<SUITestData_ETestEnum>>";
}

impl Variant for SUITestData_ETestEnum {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SUITestData_ETestEnum")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SUITestData_ETestEnum".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SUITestData_ETestEnum>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SUITestData_ETestEnum>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SUITestData_ETestEnum>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum SniperControllerConditionType {
    SCCT_Enabled,
    SCCT_PrecisionAim,
}

impl Aligned for SniperControllerConditionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for SniperControllerConditionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SCCT_Enabled => 0i32,
            Self::SCCT_PrecisionAim => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SniperControllerConditionType {
     const TYPE_ID: &str = "SniperControllerConditionType";
}

impl StaticVariant for Vec<SniperControllerConditionType> {
     const TYPE_ID: &str = "TArray<SniperControllerConditionType>";
}

impl StaticVariant for Vec<Vec<SniperControllerConditionType>> {
     const TYPE_ID: &str = "TArray<TArray<SniperControllerConditionType>>";
}

impl Variant for SniperControllerConditionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SniperControllerConditionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SniperControllerConditionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SniperControllerConditionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SniperControllerConditionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SniperControllerConditionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum SoundPlayState {
    ePlaying,
    eLoopBreaking,
    eStopping,
}

impl Aligned for SoundPlayState {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for SoundPlayState {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ePlaying => 0i8,
            Self::eLoopBreaking => 1i8,
            Self::eStopping => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for SoundPlayState {
     const TYPE_ID: &str = "SoundPlayState";
}

impl StaticVariant for Vec<SoundPlayState> {
     const TYPE_ID: &str = "TArray<SoundPlayState>";
}

impl StaticVariant for Vec<Vec<SoundPlayState>> {
     const TYPE_ID: &str = "TArray<TArray<SoundPlayState>>";
}

impl Variant for SoundPlayState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("SoundPlayState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("SoundPlayState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<SoundPlayState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<SoundPlayState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<SoundPlayState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum String_Comperator_Poll_EEvaluationType {
    EQUAL,
    NOT_EQUAL,
    LESS,
    LESS_OR_EQUAL,
    HIGHER,
    HIGHER_OR_EQUAL,
}

impl Aligned for String_Comperator_Poll_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for String_Comperator_Poll_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EQUAL => 0i32,
            Self::NOT_EQUAL => 1i32,
            Self::LESS => 2i32,
            Self::LESS_OR_EQUAL => 3i32,
            Self::HIGHER => 4i32,
            Self::HIGHER_OR_EQUAL => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for String_Comperator_Poll_EEvaluationType {
     const TYPE_ID: &str = "String_Comperator_Poll_EEvaluationType";
}

impl StaticVariant for Vec<String_Comperator_Poll_EEvaluationType> {
     const TYPE_ID: &str = "TArray<String_Comperator_Poll_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<String_Comperator_Poll_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<String_Comperator_Poll_EEvaluationType>>";
}

impl Variant for String_Comperator_Poll_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("String_Comperator_Poll_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("String_Comperator_Poll_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<String_Comperator_Poll_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<String_Comperator_Poll_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<String_Comperator_Poll_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum TeleportActionType {
    STAY,
    TELEPORT,
    LEAVE_CROWD,
}

impl Aligned for TeleportActionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for TeleportActionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::STAY => 0i32,
            Self::TELEPORT => 1i32,
            Self::LEAVE_CROWD => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for TeleportActionType {
     const TYPE_ID: &str = "TeleportActionType";
}

impl StaticVariant for Vec<TeleportActionType> {
     const TYPE_ID: &str = "TArray<TeleportActionType>";
}

impl StaticVariant for Vec<Vec<TeleportActionType>> {
     const TYPE_ID: &str = "TArray<TArray<TeleportActionType>>";
}

impl Variant for TeleportActionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("TeleportActionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("TeleportActionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<TeleportActionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<TeleportActionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<TeleportActionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum UIMapLayer_EUIMapLayerID {
    eUIMLI_UNSPECIFIED,
    eUIMLI_STAIRCASE,
    eUIMLI_AREA_UNDISCOVERED,
    eUIMLI_TEXT,
    eUIMLI_DROPPED_ITEMS_AND_DISGUISES,
    eUIMLI_NPC,
    eUIMLI_NORTH_INDICATOR,
    eUIMLI_SECURITY_CAMERA,
    eUIMLI_AGENCY_PICKUP,
    eUIMLI_OPPORTUNITY,
    eUIMLI_EXIT,
    eUIMLI_OBJECTIVE,
    eUIMLI_TARGET,
    eUIMLI_OPPONENT,
    eUIMLI_HERO,
}

impl Aligned for UIMapLayer_EUIMapLayerID {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for UIMapLayer_EUIMapLayerID {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eUIMLI_UNSPECIFIED => 0i32,
            Self::eUIMLI_STAIRCASE => 1i32,
            Self::eUIMLI_AREA_UNDISCOVERED => 2i32,
            Self::eUIMLI_TEXT => 3i32,
            Self::eUIMLI_DROPPED_ITEMS_AND_DISGUISES => 4i32,
            Self::eUIMLI_NPC => 5i32,
            Self::eUIMLI_NORTH_INDICATOR => 6i32,
            Self::eUIMLI_SECURITY_CAMERA => 7i32,
            Self::eUIMLI_AGENCY_PICKUP => 8i32,
            Self::eUIMLI_OPPORTUNITY => 9i32,
            Self::eUIMLI_EXIT => 10i32,
            Self::eUIMLI_OBJECTIVE => 11i32,
            Self::eUIMLI_TARGET => 12i32,
            Self::eUIMLI_OPPONENT => 13i32,
            Self::eUIMLI_HERO => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for UIMapLayer_EUIMapLayerID {
     const TYPE_ID: &str = "UIMapLayer_EUIMapLayerID";
}

impl StaticVariant for Vec<UIMapLayer_EUIMapLayerID> {
     const TYPE_ID: &str = "TArray<UIMapLayer_EUIMapLayerID>";
}

impl StaticVariant for Vec<Vec<UIMapLayer_EUIMapLayerID>> {
     const TYPE_ID: &str = "TArray<TArray<UIMapLayer_EUIMapLayerID>>";
}

impl Variant for UIMapLayer_EUIMapLayerID {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("UIMapLayer_EUIMapLayerID")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("UIMapLayer_EUIMapLayerID".into()))
    }
}

inventory::submit!(&VariantDeserializer::<UIMapLayer_EUIMapLayerID>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<UIMapLayer_EUIMapLayerID>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<UIMapLayer_EUIMapLayerID>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum WebSocketUtils_ECloseStatus {
    eCS_NORMAL,
    eCS_GOINGAWAY,
    eCS_PROTOCOLERROR,
    eCS_INVALIDDATA,
    eCS_1004,
    eCS_NOSTATUSRCVD,
    eCS_ABNORMALCLOSURE,
    eCS_INVALIDPAYLOAD,
    eCS_POLICYVIOLATION,
    eCS_MSGTOOBIG,
    eCS_MANDATORYEXT,
    eCS_INTERNALSRVERR,
    eCS_TLSHANDSHAKE,
}

impl Aligned for WebSocketUtils_ECloseStatus {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for WebSocketUtils_ECloseStatus {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCS_NORMAL => 1000i32,
            Self::eCS_GOINGAWAY => 1001i32,
            Self::eCS_PROTOCOLERROR => 1002i32,
            Self::eCS_INVALIDDATA => 1003i32,
            Self::eCS_1004 => 1004i32,
            Self::eCS_NOSTATUSRCVD => 1005i32,
            Self::eCS_ABNORMALCLOSURE => 1006i32,
            Self::eCS_INVALIDPAYLOAD => 1007i32,
            Self::eCS_POLICYVIOLATION => 1008i32,
            Self::eCS_MSGTOOBIG => 1009i32,
            Self::eCS_MANDATORYEXT => 1010i32,
            Self::eCS_INTERNALSRVERR => 1011i32,
            Self::eCS_TLSHANDSHAKE => 1015i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for WebSocketUtils_ECloseStatus {
     const TYPE_ID: &str = "WebSocketUtils_ECloseStatus";
}

impl StaticVariant for Vec<WebSocketUtils_ECloseStatus> {
     const TYPE_ID: &str = "TArray<WebSocketUtils_ECloseStatus>";
}

impl StaticVariant for Vec<Vec<WebSocketUtils_ECloseStatus>> {
     const TYPE_ID: &str = "TArray<TArray<WebSocketUtils_ECloseStatus>>";
}

impl Variant for WebSocketUtils_ECloseStatus {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("WebSocketUtils_ECloseStatus")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("WebSocketUtils_ECloseStatus".into()))
    }
}

inventory::submit!(&VariantDeserializer::<WebSocketUtils_ECloseStatus>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<WebSocketUtils_ECloseStatus>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<WebSocketUtils_ECloseStatus>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum WebSocketUtils_EOpCode {
    eCONTINUATION,
    eTEXT,
    eBINARY,
    eCLOSE,
    ePING,
    ePONG,
    eNONE,
}

impl Aligned for WebSocketUtils_EOpCode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for WebSocketUtils_EOpCode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCONTINUATION => 0i32,
            Self::eTEXT => 1i32,
            Self::eBINARY => 2i32,
            Self::eCLOSE => 8i32,
            Self::ePING => 9i32,
            Self::ePONG => 10i32,
            Self::eNONE => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for WebSocketUtils_EOpCode {
     const TYPE_ID: &str = "WebSocketUtils_EOpCode";
}

impl StaticVariant for Vec<WebSocketUtils_EOpCode> {
     const TYPE_ID: &str = "TArray<WebSocketUtils_EOpCode>";
}

impl StaticVariant for Vec<Vec<WebSocketUtils_EOpCode>> {
     const TYPE_ID: &str = "TArray<TArray<WebSocketUtils_EOpCode>>";
}

impl Variant for WebSocketUtils_EOpCode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("WebSocketUtils_EOpCode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("WebSocketUtils_EOpCode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<WebSocketUtils_EOpCode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<WebSocketUtils_EOpCode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<WebSocketUtils_EOpCode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAIPerceptibleEntity_EReactionBehaviorMode {
    FullBehavior,
    StopOnInvestigate,
    StopOnReacted,
}

impl Aligned for ZAIPerceptibleEntity_EReactionBehaviorMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAIPerceptibleEntity_EReactionBehaviorMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FullBehavior => 0i32,
            Self::StopOnInvestigate => 1i32,
            Self::StopOnReacted => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAIPerceptibleEntity_EReactionBehaviorMode {
     const TYPE_ID: &str = "ZAIPerceptibleEntity_EReactionBehaviorMode";
}

impl StaticVariant for Vec<ZAIPerceptibleEntity_EReactionBehaviorMode> {
     const TYPE_ID: &str = "TArray<ZAIPerceptibleEntity_EReactionBehaviorMode>";
}

impl StaticVariant for Vec<Vec<ZAIPerceptibleEntity_EReactionBehaviorMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZAIPerceptibleEntity_EReactionBehaviorMode>>";
}

impl Variant for ZAIPerceptibleEntity_EReactionBehaviorMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAIPerceptibleEntity_EReactionBehaviorMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAIPerceptibleEntity_EReactionBehaviorMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAIPerceptibleEntity_EReactionBehaviorMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAIPerceptibleEntity_EReactionBehaviorMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAIPerceptibleEntity_EReactionBehaviorMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAISoundEvent_ELoudness {
    EAISEL_Default,
    EAISEL_VeryLow,
    EAISEL_Low,
    EAISEL_Normal,
    EAISEL_Loud,
    EAISEL_VeryLoud,
}

impl Aligned for ZAISoundEvent_ELoudness {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAISoundEvent_ELoudness {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EAISEL_Default => 0i32,
            Self::EAISEL_VeryLow => 1i32,
            Self::EAISEL_Low => 2i32,
            Self::EAISEL_Normal => 3i32,
            Self::EAISEL_Loud => 4i32,
            Self::EAISEL_VeryLoud => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAISoundEvent_ELoudness {
     const TYPE_ID: &str = "ZAISoundEvent_ELoudness";
}

impl StaticVariant for Vec<ZAISoundEvent_ELoudness> {
     const TYPE_ID: &str = "TArray<ZAISoundEvent_ELoudness>";
}

impl StaticVariant for Vec<Vec<ZAISoundEvent_ELoudness>> {
     const TYPE_ID: &str = "TArray<TArray<ZAISoundEvent_ELoudness>>";
}

impl Variant for ZAISoundEvent_ELoudness {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAISoundEvent_ELoudness")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAISoundEvent_ELoudness".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAISoundEvent_ELoudness>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAISoundEvent_ELoudness>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAISoundEvent_ELoudness>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAT2Controller_EFoot {
    FOOT_LEFT,
    FOOT_RIGHT,
}

impl Aligned for ZAT2Controller_EFoot {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAT2Controller_EFoot {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FOOT_LEFT => 0i32,
            Self::FOOT_RIGHT => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAT2Controller_EFoot {
     const TYPE_ID: &str = "ZAT2Controller_EFoot";
}

impl StaticVariant for Vec<ZAT2Controller_EFoot> {
     const TYPE_ID: &str = "TArray<ZAT2Controller_EFoot>";
}

impl StaticVariant for Vec<Vec<ZAT2Controller_EFoot>> {
     const TYPE_ID: &str = "TArray<TArray<ZAT2Controller_EFoot>>";
}

impl Variant for ZAT2Controller_EFoot {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAT2Controller_EFoot")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAT2Controller_EFoot".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAT2Controller_EFoot>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAT2Controller_EFoot>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAT2Controller_EFoot>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAT2Controller_EFootstepsMovementType {
    MOVEMENT_WALKING,
    MOVEMENT_WALKING_SLIDING,
    MOVEMENT_RUNNING,
    MOVEMENT_STANDING,
}

impl Aligned for ZAT2Controller_EFootstepsMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAT2Controller_EFootstepsMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MOVEMENT_WALKING => 0i32,
            Self::MOVEMENT_WALKING_SLIDING => 1i32,
            Self::MOVEMENT_RUNNING => 2i32,
            Self::MOVEMENT_STANDING => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAT2Controller_EFootstepsMovementType {
     const TYPE_ID: &str = "ZAT2Controller_EFootstepsMovementType";
}

impl StaticVariant for Vec<ZAT2Controller_EFootstepsMovementType> {
     const TYPE_ID: &str = "TArray<ZAT2Controller_EFootstepsMovementType>";
}

impl StaticVariant for Vec<Vec<ZAT2Controller_EFootstepsMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<ZAT2Controller_EFootstepsMovementType>>";
}

impl Variant for ZAT2Controller_EFootstepsMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAT2Controller_EFootstepsMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAT2Controller_EFootstepsMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAT2Controller_EFootstepsMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAT2Controller_EFootstepsMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAT2Controller_EFootstepsMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActBehaviorEntity_EApproachAlignment {
    AA_STRICT,
    AA_LOOSE,
}

impl Aligned for ZActBehaviorEntity_EApproachAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActBehaviorEntity_EApproachAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AA_STRICT => 0i32,
            Self::AA_LOOSE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActBehaviorEntity_EApproachAlignment {
     const TYPE_ID: &str = "ZActBehaviorEntity_EApproachAlignment";
}

impl StaticVariant for Vec<ZActBehaviorEntity_EApproachAlignment> {
     const TYPE_ID: &str = "TArray<ZActBehaviorEntity_EApproachAlignment>";
}

impl StaticVariant for Vec<Vec<ZActBehaviorEntity_EApproachAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZActBehaviorEntity_EApproachAlignment>>";
}

impl Variant for ZActBehaviorEntity_EApproachAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActBehaviorEntity_EApproachAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActBehaviorEntity_EApproachAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActBehaviorEntity_EApproachAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActBehaviorEntity_EApproachAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActBehaviorEntity_EApproachAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActBehaviorEntity_EMovementType {
    MT_WALK,
    MT_SNAP,
    MT_IGNORE_POSITION,
}

impl Aligned for ZActBehaviorEntity_EMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActBehaviorEntity_EMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MT_WALK => 0i32,
            Self::MT_SNAP => 1i32,
            Self::MT_IGNORE_POSITION => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActBehaviorEntity_EMovementType {
     const TYPE_ID: &str = "ZActBehaviorEntity_EMovementType";
}

impl StaticVariant for Vec<ZActBehaviorEntity_EMovementType> {
     const TYPE_ID: &str = "TArray<ZActBehaviorEntity_EMovementType>";
}

impl StaticVariant for Vec<Vec<ZActBehaviorEntity_EMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActBehaviorEntity_EMovementType>>";
}

impl Variant for ZActBehaviorEntity_EMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActBehaviorEntity_EMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActBehaviorEntity_EMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActBehaviorEntity_EMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActBehaviorEntity_EMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActBehaviorEntity_EMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActBehaviorEntity_ERotationAlignment {
    RA_NONE,
    RA_LOOSE,
    RA_EXACT,
}

impl Aligned for ZActBehaviorEntity_ERotationAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActBehaviorEntity_ERotationAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RA_NONE => 0i32,
            Self::RA_LOOSE => 1i32,
            Self::RA_EXACT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActBehaviorEntity_ERotationAlignment {
     const TYPE_ID: &str = "ZActBehaviorEntity_ERotationAlignment";
}

impl StaticVariant for Vec<ZActBehaviorEntity_ERotationAlignment> {
     const TYPE_ID: &str = "TArray<ZActBehaviorEntity_ERotationAlignment>";
}

impl StaticVariant for Vec<Vec<ZActBehaviorEntity_ERotationAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZActBehaviorEntity_ERotationAlignment>>";
}

impl Variant for ZActBehaviorEntity_ERotationAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActBehaviorEntity_ERotationAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActBehaviorEntity_ERotationAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActBehaviorEntity_ERotationAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActBehaviorEntity_ERotationAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActBehaviorEntity_ERotationAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActDurationCondition_EState {
    MOVING,
    ENTERING,
    PLAYING,
    STOPPING,
}

impl Aligned for ZActDurationCondition_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActDurationCondition_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MOVING => 0i32,
            Self::ENTERING => 1i32,
            Self::PLAYING => 2i32,
            Self::STOPPING => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActDurationCondition_EState {
     const TYPE_ID: &str = "ZActDurationCondition_EState";
}

impl StaticVariant for Vec<ZActDurationCondition_EState> {
     const TYPE_ID: &str = "TArray<ZActDurationCondition_EState>";
}

impl StaticVariant for Vec<Vec<ZActDurationCondition_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZActDurationCondition_EState>>";
}

impl Variant for ZActDurationCondition_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActDurationCondition_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActDurationCondition_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActDurationCondition_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActDurationCondition_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActDurationCondition_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActStateCondition_EState {
    MOVING,
    ENTERING,
    PLAYING,
}

impl Aligned for ZActStateCondition_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActStateCondition_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MOVING => 0i32,
            Self::ENTERING => 1i32,
            Self::PLAYING => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActStateCondition_EState {
     const TYPE_ID: &str = "ZActStateCondition_EState";
}

impl StaticVariant for Vec<ZActStateCondition_EState> {
     const TYPE_ID: &str = "TArray<ZActStateCondition_EState>";
}

impl StaticVariant for Vec<Vec<ZActStateCondition_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZActStateCondition_EState>>";
}

impl Variant for ZActStateCondition_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActStateCondition_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActStateCondition_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActStateCondition_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActStateCondition_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActStateCondition_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorAccessoryItemCondition_EConditionTypes {
    ECT_HasInPool,
    ECT_HasAttached,
}

impl Aligned for ZActorAccessoryItemCondition_EConditionTypes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorAccessoryItemCondition_EConditionTypes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ECT_HasInPool => 0i32,
            Self::ECT_HasAttached => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorAccessoryItemCondition_EConditionTypes {
     const TYPE_ID: &str = "ZActorAccessoryItemCondition_EConditionTypes";
}

impl StaticVariant for Vec<ZActorAccessoryItemCondition_EConditionTypes> {
     const TYPE_ID: &str = "TArray<ZActorAccessoryItemCondition_EConditionTypes>";
}

impl StaticVariant for Vec<Vec<ZActorAccessoryItemCondition_EConditionTypes>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorAccessoryItemCondition_EConditionTypes>>";
}

impl Variant for ZActorAccessoryItemCondition_EConditionTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorAccessoryItemCondition_EConditionTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorAccessoryItemCondition_EConditionTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorAccessoryItemCondition_EConditionTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorAccessoryItemCondition_EConditionTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorAccessoryItemCondition_EConditionTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorBoneAttachEntity_EResetMode {
    eAtBoneOrigin,
    eKeepOffset,
}

impl Aligned for ZActorBoneAttachEntity_EResetMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorBoneAttachEntity_EResetMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAtBoneOrigin => 0i32,
            Self::eKeepOffset => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorBoneAttachEntity_EResetMode {
     const TYPE_ID: &str = "ZActorBoneAttachEntity_EResetMode";
}

impl StaticVariant for Vec<ZActorBoneAttachEntity_EResetMode> {
     const TYPE_ID: &str = "TArray<ZActorBoneAttachEntity_EResetMode>";
}

impl StaticVariant for Vec<Vec<ZActorBoneAttachEntity_EResetMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorBoneAttachEntity_EResetMode>>";
}

impl Variant for ZActorBoneAttachEntity_EResetMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorBoneAttachEntity_EResetMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorBoneAttachEntity_EResetMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorBoneAttachEntity_EResetMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorBoneAttachEntity_EResetMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorBoneAttachEntity_EResetMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorDebugEntity_EActorDebugColor {
    EDC_RED,
    EDC_GREEN,
    EDC_BLUE,
    EDC_PINK,
    EDC_DARK_RED,
    EDC_DARK_GREEN,
    EDC_DARK_BLUE,
    EDC_DARK_PINK,
    EDC_BLACK,
    EDC_WHITE,
}

impl Aligned for ZActorDebugEntity_EActorDebugColor {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorDebugEntity_EActorDebugColor {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EDC_RED => 255i32,
            Self::EDC_GREEN => 65280i32,
            Self::EDC_BLUE => 16711680i32,
            Self::EDC_PINK => 16711935i32,
            Self::EDC_DARK_RED => 127i32,
            Self::EDC_DARK_GREEN => 32512i32,
            Self::EDC_DARK_BLUE => 8323072i32,
            Self::EDC_DARK_PINK => 8323199i32,
            Self::EDC_BLACK => 0i32,
            Self::EDC_WHITE => 16777215i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorDebugEntity_EActorDebugColor {
     const TYPE_ID: &str = "ZActorDebugEntity_EActorDebugColor";
}

impl StaticVariant for Vec<ZActorDebugEntity_EActorDebugColor> {
     const TYPE_ID: &str = "TArray<ZActorDebugEntity_EActorDebugColor>";
}

impl StaticVariant for Vec<Vec<ZActorDebugEntity_EActorDebugColor>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorDebugEntity_EActorDebugColor>>";
}

impl Variant for ZActorDebugEntity_EActorDebugColor {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorDebugEntity_EActorDebugColor")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorDebugEntity_EActorDebugColor".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorDebugEntity_EActorDebugColor>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorDebugEntity_EActorDebugColor>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorDebugEntity_EActorDebugColor>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorInstanceEntity_EFFXMode {
    eFFX_MODE_DISABLE,
    eFFX_MODE_OVERWRITE,
}

impl Aligned for ZActorInstanceEntity_EFFXMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorInstanceEntity_EFFXMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFFX_MODE_DISABLE => 0i32,
            Self::eFFX_MODE_OVERWRITE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorInstanceEntity_EFFXMode {
     const TYPE_ID: &str = "ZActorInstanceEntity_EFFXMode";
}

impl StaticVariant for Vec<ZActorInstanceEntity_EFFXMode> {
     const TYPE_ID: &str = "TArray<ZActorInstanceEntity_EFFXMode>";
}

impl StaticVariant for Vec<Vec<ZActorInstanceEntity_EFFXMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorInstanceEntity_EFFXMode>>";
}

impl Variant for ZActorInstanceEntity_EFFXMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorInstanceEntity_EFFXMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorInstanceEntity_EFFXMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorInstanceEntity_EFFXMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorInstanceEntity_EFFXMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorInstanceEntity_EFFXMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorKeywordCondition_EEvaluationType {
    ALL,
    NONE,
    ANY,
    ANY_TRUE_IF_NO_REQS,
}

impl Aligned for ZActorKeywordCondition_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorKeywordCondition_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::ANY_TRUE_IF_NO_REQS => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorKeywordCondition_EEvaluationType {
     const TYPE_ID: &str = "ZActorKeywordCondition_EEvaluationType";
}

impl StaticVariant for Vec<ZActorKeywordCondition_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorKeywordCondition_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorKeywordCondition_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorKeywordCondition_EEvaluationType>>";
}

impl Variant for ZActorKeywordCondition_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorKeywordCondition_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorKeywordCondition_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorKeywordCondition_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorKeywordCondition_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorKeywordCondition_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorKnowledgeCondition_EEvaluationType {
    ALL,
    ANY,
}

impl Aligned for ZActorKnowledgeCondition_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorKnowledgeCondition_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::ANY => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorKnowledgeCondition_EEvaluationType {
     const TYPE_ID: &str = "ZActorKnowledgeCondition_EEvaluationType";
}

impl StaticVariant for Vec<ZActorKnowledgeCondition_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorKnowledgeCondition_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorKnowledgeCondition_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorKnowledgeCondition_EEvaluationType>>";
}

impl Variant for ZActorKnowledgeCondition_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorKnowledgeCondition_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorKnowledgeCondition_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorKnowledgeCondition_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorKnowledgeCondition_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorKnowledgeCondition_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPicker_EKeywordEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZActorPicker_EKeywordEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPicker_EKeywordEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPicker_EKeywordEvaluationType {
     const TYPE_ID: &str = "ZActorPicker_EKeywordEvaluationType";
}

impl StaticVariant for Vec<ZActorPicker_EKeywordEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorPicker_EKeywordEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorPicker_EKeywordEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPicker_EKeywordEvaluationType>>";
}

impl Variant for ZActorPicker_EKeywordEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPicker_EKeywordEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPicker_EKeywordEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPicker_EKeywordEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPicker_EKeywordEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPicker_EKeywordEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPickerEffectDrama_EEffectPhaseAction {
    EPA_START,
    EPA_LEAVE,
}

impl Aligned for ZActorPickerEffectDrama_EEffectPhaseAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPickerEffectDrama_EEffectPhaseAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EPA_START => 0i32,
            Self::EPA_LEAVE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPickerEffectDrama_EEffectPhaseAction {
     const TYPE_ID: &str = "ZActorPickerEffectDrama_EEffectPhaseAction";
}

impl StaticVariant for Vec<ZActorPickerEffectDrama_EEffectPhaseAction> {
     const TYPE_ID: &str = "TArray<ZActorPickerEffectDrama_EEffectPhaseAction>";
}

impl StaticVariant for Vec<Vec<ZActorPickerEffectDrama_EEffectPhaseAction>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPickerEffectDrama_EEffectPhaseAction>>";
}

impl Variant for ZActorPickerEffectDrama_EEffectPhaseAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPickerEffectDrama_EEffectPhaseAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPickerEffectDrama_EEffectPhaseAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPickerEffectDrama_EEffectPhaseAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPickerEffectDrama_EEffectPhaseAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPickerEffectDrama_EEffectPhaseAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPickerEffectTemplate_EEffectPhaseAction {
    EPA_NONE,
    EPA_START_TEMPLATE,
    EPA_STOP_TEMPLATE,
}

impl Aligned for ZActorPickerEffectTemplate_EEffectPhaseAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPickerEffectTemplate_EEffectPhaseAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EPA_NONE => 0i32,
            Self::EPA_START_TEMPLATE => 1i32,
            Self::EPA_STOP_TEMPLATE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPickerEffectTemplate_EEffectPhaseAction {
     const TYPE_ID: &str = "ZActorPickerEffectTemplate_EEffectPhaseAction";
}

impl StaticVariant for Vec<ZActorPickerEffectTemplate_EEffectPhaseAction> {
     const TYPE_ID: &str = "TArray<ZActorPickerEffectTemplate_EEffectPhaseAction>";
}

impl StaticVariant for Vec<Vec<ZActorPickerEffectTemplate_EEffectPhaseAction>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPickerEffectTemplate_EEffectPhaseAction>>";
}

impl Variant for ZActorPickerEffectTemplate_EEffectPhaseAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPickerEffectTemplate_EEffectPhaseAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPickerEffectTemplate_EEffectPhaseAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPickerEffectTemplate_EEffectPhaseAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPickerEffectTemplate_EEffectPhaseAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPickerEffectTemplate_EEffectPhaseAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPickerEffectTrack_EEffectPhaseAction {
    EPA_ATTACH,
    EPA_DETACH,
}

impl Aligned for ZActorPickerEffectTrack_EEffectPhaseAction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPickerEffectTrack_EEffectPhaseAction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EPA_ATTACH => 0i32,
            Self::EPA_DETACH => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPickerEffectTrack_EEffectPhaseAction {
     const TYPE_ID: &str = "ZActorPickerEffectTrack_EEffectPhaseAction";
}

impl StaticVariant for Vec<ZActorPickerEffectTrack_EEffectPhaseAction> {
     const TYPE_ID: &str = "TArray<ZActorPickerEffectTrack_EEffectPhaseAction>";
}

impl StaticVariant for Vec<Vec<ZActorPickerEffectTrack_EEffectPhaseAction>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPickerEffectTrack_EEffectPhaseAction>>";
}

impl Variant for ZActorPickerEffectTrack_EEffectPhaseAction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPickerEffectTrack_EEffectPhaseAction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPickerEffectTrack_EEffectPhaseAction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPickerEffectTrack_EEffectPhaseAction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPickerEffectTrack_EEffectPhaseAction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPickerEffectTrack_EEffectPhaseAction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPickerFilterGroup_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZActorPickerFilterGroup_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPickerFilterGroup_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPickerFilterGroup_EEvaluationType {
     const TYPE_ID: &str = "ZActorPickerFilterGroup_EEvaluationType";
}

impl StaticVariant for Vec<ZActorPickerFilterGroup_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorPickerFilterGroup_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorPickerFilterGroup_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPickerFilterGroup_EEvaluationType>>";
}

impl Variant for ZActorPickerFilterGroup_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPickerFilterGroup_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPickerFilterGroup_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPickerFilterGroup_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPickerFilterGroup_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPickerFilterGroup_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorPickerFilterKeyword_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZActorPickerFilterKeyword_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorPickerFilterKeyword_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorPickerFilterKeyword_EEvaluationType {
     const TYPE_ID: &str = "ZActorPickerFilterKeyword_EEvaluationType";
}

impl StaticVariant for Vec<ZActorPickerFilterKeyword_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorPickerFilterKeyword_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorPickerFilterKeyword_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorPickerFilterKeyword_EEvaluationType>>";
}

impl Variant for ZActorPickerFilterKeyword_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorPickerFilterKeyword_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorPickerFilterKeyword_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorPickerFilterKeyword_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorPickerFilterKeyword_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorPickerFilterKeyword_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorProviderFilterKeyword_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZActorProviderFilterKeyword_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorProviderFilterKeyword_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorProviderFilterKeyword_EEvaluationType {
     const TYPE_ID: &str = "ZActorProviderFilterKeyword_EEvaluationType";
}

impl StaticVariant for Vec<ZActorProviderFilterKeyword_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZActorProviderFilterKeyword_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZActorProviderFilterKeyword_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorProviderFilterKeyword_EEvaluationType>>";
}

impl Variant for ZActorProviderFilterKeyword_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorProviderFilterKeyword_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorProviderFilterKeyword_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorProviderFilterKeyword_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorProviderFilterKeyword_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorProviderFilterKeyword_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZActorTensionEntity_ETensionCheckMode {
    ETCM_INSIDE_VOLUME_OR_LIST,
    ETCM_INSIDE_VOLUME_AND_LIST,
}

impl Aligned for ZActorTensionEntity_ETensionCheckMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZActorTensionEntity_ETensionCheckMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ETCM_INSIDE_VOLUME_OR_LIST => 0i32,
            Self::ETCM_INSIDE_VOLUME_AND_LIST => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZActorTensionEntity_ETensionCheckMode {
     const TYPE_ID: &str = "ZActorTensionEntity_ETensionCheckMode";
}

impl StaticVariant for Vec<ZActorTensionEntity_ETensionCheckMode> {
     const TYPE_ID: &str = "TArray<ZActorTensionEntity_ETensionCheckMode>";
}

impl StaticVariant for Vec<Vec<ZActorTensionEntity_ETensionCheckMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZActorTensionEntity_ETensionCheckMode>>";
}

impl Variant for ZActorTensionEntity_ETensionCheckMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZActorTensionEntity_ETensionCheckMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZActorTensionEntity_ETensionCheckMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZActorTensionEntity_ETensionCheckMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZActorTensionEntity_ETensionCheckMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZActorTensionEntity_ETensionCheckMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZApproachOrder_EApproachStyle {
    AS_AUTO,
    AS_SPRINT,
    AS_JOG,
    AS_WALK,
}

impl Aligned for ZApproachOrder_EApproachStyle {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZApproachOrder_EApproachStyle {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_AUTO => 0i32,
            Self::AS_SPRINT => 1i32,
            Self::AS_JOG => 2i32,
            Self::AS_WALK => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZApproachOrder_EApproachStyle {
     const TYPE_ID: &str = "ZApproachOrder_EApproachStyle";
}

impl StaticVariant for Vec<ZApproachOrder_EApproachStyle> {
     const TYPE_ID: &str = "TArray<ZApproachOrder_EApproachStyle>";
}

impl StaticVariant for Vec<Vec<ZApproachOrder_EApproachStyle>> {
     const TYPE_ID: &str = "TArray<TArray<ZApproachOrder_EApproachStyle>>";
}

impl Variant for ZApproachOrder_EApproachStyle {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZApproachOrder_EApproachStyle")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZApproachOrder_EApproachStyle".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZApproachOrder_EApproachStyle>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZApproachOrder_EApproachStyle>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZApproachOrder_EApproachStyle>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAudioSequenceTrack_EPlaybackTarget {
    eNone,
    eTargetEntityAudioPlayer,
    eTargetEntityEmitter,
    ePreviewEmitter,
}

impl Aligned for ZAudioSequenceTrack_EPlaybackTarget {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAudioSequenceTrack_EPlaybackTarget {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNone => 0i32,
            Self::eTargetEntityAudioPlayer => 1i32,
            Self::eTargetEntityEmitter => 2i32,
            Self::ePreviewEmitter => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAudioSequenceTrack_EPlaybackTarget {
     const TYPE_ID: &str = "ZAudioSequenceTrack_EPlaybackTarget";
}

impl StaticVariant for Vec<ZAudioSequenceTrack_EPlaybackTarget> {
     const TYPE_ID: &str = "TArray<ZAudioSequenceTrack_EPlaybackTarget>";
}

impl StaticVariant for Vec<Vec<ZAudioSequenceTrack_EPlaybackTarget>> {
     const TYPE_ID: &str = "TArray<TArray<ZAudioSequenceTrack_EPlaybackTarget>>";
}

impl Variant for ZAudioSequenceTrack_EPlaybackTarget {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAudioSequenceTrack_EPlaybackTarget")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAudioSequenceTrack_EPlaybackTarget".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAudioSequenceTrack_EPlaybackTarget>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAudioSequenceTrack_EPlaybackTarget>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAudioSequenceTrack_EPlaybackTarget>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState {
    IGS_SelectDestination,
    IGS_Move,
    IGS_Jump,
    IGS_Wait,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_SelectDestination => 0i32,
            Self::IGS_Move => 1i32,
            Self::IGS_Jump => 2i32,
            Self::IGS_Wait => 3i32,
            Self::IGS_Completed => 4i32,
            Self::IGS_Max => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState {
     const TYPE_ID: &str = "ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState";
}

impl StaticVariant for Vec<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState> {
     const TYPE_ID: &str = "TArray<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>";
}

impl StaticVariant for Vec<Vec<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>>";
}

impl Variant for ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZAvoidDangerousAreaGroup_EAvoidDangerousAreaGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZBoneAttachEntity_EResetMode {
    eAtBoneOrigin,
    eKeepOffset,
}

impl Aligned for ZBoneAttachEntity_EResetMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZBoneAttachEntity_EResetMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAtBoneOrigin => 0i32,
            Self::eKeepOffset => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZBoneAttachEntity_EResetMode {
     const TYPE_ID: &str = "ZBoneAttachEntity_EResetMode";
}

impl StaticVariant for Vec<ZBoneAttachEntity_EResetMode> {
     const TYPE_ID: &str = "TArray<ZBoneAttachEntity_EResetMode>";
}

impl StaticVariant for Vec<Vec<ZBoneAttachEntity_EResetMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZBoneAttachEntity_EResetMode>>";
}

impl Variant for ZBoneAttachEntity_EResetMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZBoneAttachEntity_EResetMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZBoneAttachEntity_EResetMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZBoneAttachEntity_EResetMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZBoneAttachEntity_EResetMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZBoneAttachEntity_EResetMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZBoneWeightRotationEntity_eRotationAxises {
    AXIS_X,
    AXIS_Y,
    AXIS_Z,
}

impl Aligned for ZBoneWeightRotationEntity_eRotationAxises {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZBoneWeightRotationEntity_eRotationAxises {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AXIS_X => 0i32,
            Self::AXIS_Y => 1i32,
            Self::AXIS_Z => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZBoneWeightRotationEntity_eRotationAxises {
     const TYPE_ID: &str = "ZBoneWeightRotationEntity_eRotationAxises";
}

impl StaticVariant for Vec<ZBoneWeightRotationEntity_eRotationAxises> {
     const TYPE_ID: &str = "TArray<ZBoneWeightRotationEntity_eRotationAxises>";
}

impl StaticVariant for Vec<Vec<ZBoneWeightRotationEntity_eRotationAxises>> {
     const TYPE_ID: &str = "TArray<TArray<ZBoneWeightRotationEntity_eRotationAxises>>";
}

impl Variant for ZBoneWeightRotationEntity_eRotationAxises {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZBoneWeightRotationEntity_eRotationAxises")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZBoneWeightRotationEntity_eRotationAxises".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZBoneWeightRotationEntity_eRotationAxises>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZBoneWeightRotationEntity_eRotationAxises>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZBoneWeightRotationEntity_eRotationAxises>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZBoxReflectionEntity_EBoundsType {
    eBox,
    eRoom,
}

impl Aligned for ZBoxReflectionEntity_EBoundsType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZBoxReflectionEntity_EBoundsType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBox => 0i32,
            Self::eRoom => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZBoxReflectionEntity_EBoundsType {
     const TYPE_ID: &str = "ZBoxReflectionEntity_EBoundsType";
}

impl StaticVariant for Vec<ZBoxReflectionEntity_EBoundsType> {
     const TYPE_ID: &str = "TArray<ZBoxReflectionEntity_EBoundsType>";
}

impl StaticVariant for Vec<Vec<ZBoxReflectionEntity_EBoundsType>> {
     const TYPE_ID: &str = "TArray<TArray<ZBoxReflectionEntity_EBoundsType>>";
}

impl Variant for ZBoxReflectionEntity_EBoundsType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZBoxReflectionEntity_EBoundsType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZBoxReflectionEntity_EBoundsType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZBoxReflectionEntity_EBoundsType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZBoxReflectionEntity_EBoundsType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZBoxReflectionEntity_EBoundsType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZBoxReflectionEntity_EType {
    eLocal,
    eFallback,
}

impl Aligned for ZBoxReflectionEntity_EType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZBoxReflectionEntity_EType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLocal => 0i32,
            Self::eFallback => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZBoxReflectionEntity_EType {
     const TYPE_ID: &str = "ZBoxReflectionEntity_EType";
}

impl StaticVariant for Vec<ZBoxReflectionEntity_EType> {
     const TYPE_ID: &str = "TArray<ZBoxReflectionEntity_EType>";
}

impl StaticVariant for Vec<Vec<ZBoxReflectionEntity_EType>> {
     const TYPE_ID: &str = "TArray<TArray<ZBoxReflectionEntity_EType>>";
}

impl Variant for ZBoxReflectionEntity_EType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZBoxReflectionEntity_EType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZBoxReflectionEntity_EType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZBoxReflectionEntity_EType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZBoxReflectionEntity_EType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZBoxReflectionEntity_EType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCameraConeTriggerEntity_EAlignment {
    X_POSITIVE,
    Y_POSITIVE,
    Z_POSITIVE,
    X_NEGATIVE,
    Y_NEGATIVE,
    Z_NEGATIVE,
}

impl Aligned for ZCameraConeTriggerEntity_EAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCameraConeTriggerEntity_EAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X_POSITIVE => 0i32,
            Self::Y_POSITIVE => 1i32,
            Self::Z_POSITIVE => 2i32,
            Self::X_NEGATIVE => 3i32,
            Self::Y_NEGATIVE => 4i32,
            Self::Z_NEGATIVE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCameraConeTriggerEntity_EAlignment {
     const TYPE_ID: &str = "ZCameraConeTriggerEntity_EAlignment";
}

impl StaticVariant for Vec<ZCameraConeTriggerEntity_EAlignment> {
     const TYPE_ID: &str = "TArray<ZCameraConeTriggerEntity_EAlignment>";
}

impl StaticVariant for Vec<Vec<ZCameraConeTriggerEntity_EAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZCameraConeTriggerEntity_EAlignment>>";
}

impl Variant for ZCameraConeTriggerEntity_EAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCameraConeTriggerEntity_EAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCameraConeTriggerEntity_EAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCameraConeTriggerEntity_EAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCameraConeTriggerEntity_EAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCameraConeTriggerEntity_EAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCameraPlaneAlignedTriggerEntity_EAlignment {
    X_POSITIVE,
    Y_POSITIVE,
    Z_POSITIVE,
    X_NEGATIVE,
    Y_NEGATIVE,
    Z_NEGATIVE,
}

impl Aligned for ZCameraPlaneAlignedTriggerEntity_EAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCameraPlaneAlignedTriggerEntity_EAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X_POSITIVE => 0i32,
            Self::Y_POSITIVE => 1i32,
            Self::Z_POSITIVE => 2i32,
            Self::X_NEGATIVE => 3i32,
            Self::Y_NEGATIVE => 4i32,
            Self::Z_NEGATIVE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCameraPlaneAlignedTriggerEntity_EAlignment {
     const TYPE_ID: &str = "ZCameraPlaneAlignedTriggerEntity_EAlignment";
}

impl StaticVariant for Vec<ZCameraPlaneAlignedTriggerEntity_EAlignment> {
     const TYPE_ID: &str = "TArray<ZCameraPlaneAlignedTriggerEntity_EAlignment>";
}

impl StaticVariant for Vec<Vec<ZCameraPlaneAlignedTriggerEntity_EAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZCameraPlaneAlignedTriggerEntity_EAlignment>>";
}

impl Variant for ZCameraPlaneAlignedTriggerEntity_EAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCameraPlaneAlignedTriggerEntity_EAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCameraPlaneAlignedTriggerEntity_EAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCameraPlaneAlignedTriggerEntity_EAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCameraPlaneAlignedTriggerEntity_EAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCameraPlaneAlignedTriggerEntity_EAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCameraPlaneTriggerEntity_EAlignment {
    XY,
    XZ,
    YZ,
}

impl Aligned for ZCameraPlaneTriggerEntity_EAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCameraPlaneTriggerEntity_EAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::XY => 0i32,
            Self::XZ => 1i32,
            Self::YZ => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCameraPlaneTriggerEntity_EAlignment {
     const TYPE_ID: &str = "ZCameraPlaneTriggerEntity_EAlignment";
}

impl StaticVariant for Vec<ZCameraPlaneTriggerEntity_EAlignment> {
     const TYPE_ID: &str = "TArray<ZCameraPlaneTriggerEntity_EAlignment>";
}

impl StaticVariant for Vec<Vec<ZCameraPlaneTriggerEntity_EAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZCameraPlaneTriggerEntity_EAlignment>>";
}

impl Variant for ZCameraPlaneTriggerEntity_EAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCameraPlaneTriggerEntity_EAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCameraPlaneTriggerEntity_EAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCameraPlaneTriggerEntity_EAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCameraPlaneTriggerEntity_EAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCameraPlaneTriggerEntity_EAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCausalNodeEntity_ECauseEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZCausalNodeEntity_ECauseEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCausalNodeEntity_ECauseEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCausalNodeEntity_ECauseEvaluationType {
     const TYPE_ID: &str = "ZCausalNodeEntity_ECauseEvaluationType";
}

impl StaticVariant for Vec<ZCausalNodeEntity_ECauseEvaluationType> {
     const TYPE_ID: &str = "TArray<ZCausalNodeEntity_ECauseEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZCausalNodeEntity_ECauseEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZCausalNodeEntity_ECauseEvaluationType>>";
}

impl Variant for ZCausalNodeEntity_ECauseEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCausalNodeEntity_ECauseEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCausalNodeEntity_ECauseEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCausalNodeEntity_ECauseEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCausalNodeEntity_ECauseEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCausalNodeEntity_ECauseEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousInvestigateGroup_EAssistantState {
    AS_Waiting,
    AS_CalculateFields,
    AS_RequestNode,
    AS_Moving,
    AS_Investigating,
    AS_Max,
}

impl Aligned for ZCautiousInvestigateGroup_EAssistantState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousInvestigateGroup_EAssistantState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AS_Waiting => 0i32,
            Self::AS_CalculateFields => 1i32,
            Self::AS_RequestNode => 2i32,
            Self::AS_Moving => 3i32,
            Self::AS_Investigating => 4i32,
            Self::AS_Max => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousInvestigateGroup_EAssistantState {
     const TYPE_ID: &str = "ZCautiousInvestigateGroup_EAssistantState";
}

impl StaticVariant for Vec<ZCautiousInvestigateGroup_EAssistantState> {
     const TYPE_ID: &str = "TArray<ZCautiousInvestigateGroup_EAssistantState>";
}

impl StaticVariant for Vec<Vec<ZCautiousInvestigateGroup_EAssistantState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousInvestigateGroup_EAssistantState>>";
}

impl Variant for ZCautiousInvestigateGroup_EAssistantState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousInvestigateGroup_EAssistantState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousInvestigateGroup_EAssistantState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousInvestigateGroup_EAssistantState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousInvestigateGroup_EAssistantState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousInvestigateGroup_EAssistantState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCautiousInvestigateGroup_EInvestigateGroupState {
    IGS_FindAssistant,
    IGS_PreAcknowledge,
    IGS_Acknowledge,
    IGS_Approach,
    IGS_Approaching,
    IGS_Investigating,
    IGS_DeadBody,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZCautiousInvestigateGroup_EInvestigateGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCautiousInvestigateGroup_EInvestigateGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_FindAssistant => 0i32,
            Self::IGS_PreAcknowledge => 1i32,
            Self::IGS_Acknowledge => 2i32,
            Self::IGS_Approach => 3i32,
            Self::IGS_Approaching => 4i32,
            Self::IGS_Investigating => 5i32,
            Self::IGS_DeadBody => 6i32,
            Self::IGS_Completed => 7i32,
            Self::IGS_Max => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCautiousInvestigateGroup_EInvestigateGroupState {
     const TYPE_ID: &str = "ZCautiousInvestigateGroup_EInvestigateGroupState";
}

impl StaticVariant for Vec<ZCautiousInvestigateGroup_EInvestigateGroupState> {
     const TYPE_ID: &str = "TArray<ZCautiousInvestigateGroup_EInvestigateGroupState>";
}

impl StaticVariant for Vec<Vec<ZCautiousInvestigateGroup_EInvestigateGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCautiousInvestigateGroup_EInvestigateGroupState>>";
}

impl Variant for ZCautiousInvestigateGroup_EInvestigateGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCautiousInvestigateGroup_EInvestigateGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCautiousInvestigateGroup_EInvestigateGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCautiousInvestigateGroup_EInvestigateGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCautiousInvestigateGroup_EInvestigateGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCautiousInvestigateGroup_EInvestigateGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZChannelKeywordCondition_EEvaluationType {
    ALL,
    NONE,
    ANY,
    ANY_TRUE_IF_NO_REQS,
}

impl Aligned for ZChannelKeywordCondition_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZChannelKeywordCondition_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::ANY_TRUE_IF_NO_REQS => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZChannelKeywordCondition_EEvaluationType {
     const TYPE_ID: &str = "ZChannelKeywordCondition_EEvaluationType";
}

impl StaticVariant for Vec<ZChannelKeywordCondition_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZChannelKeywordCondition_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZChannelKeywordCondition_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZChannelKeywordCondition_EEvaluationType>>";
}

impl Variant for ZChannelKeywordCondition_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZChannelKeywordCondition_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZChannelKeywordCondition_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZChannelKeywordCondition_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZChannelKeywordCondition_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZChannelKeywordCondition_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCharacterSpeakCondition_EState {
    Started,
    Playing,
    PlayingAndAudible,
    Completed,
    SubsSeenAndCompleted,
    Failed,
    Stopped,
}

impl Aligned for ZCharacterSpeakCondition_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCharacterSpeakCondition_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Started => 0i32,
            Self::Playing => 1i32,
            Self::PlayingAndAudible => 2i32,
            Self::Completed => 3i32,
            Self::SubsSeenAndCompleted => 4i32,
            Self::Failed => 5i32,
            Self::Stopped => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCharacterSpeakCondition_EState {
     const TYPE_ID: &str = "ZCharacterSpeakCondition_EState";
}

impl StaticVariant for Vec<ZCharacterSpeakCondition_EState> {
     const TYPE_ID: &str = "TArray<ZCharacterSpeakCondition_EState>";
}

impl StaticVariant for Vec<Vec<ZCharacterSpeakCondition_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZCharacterSpeakCondition_EState>>";
}

impl Variant for ZCharacterSpeakCondition_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCharacterSpeakCondition_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCharacterSpeakCondition_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCharacterSpeakCondition_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCharacterSpeakCondition_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCharacterSpeakCondition_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZConditionListEntity_EEvaluationType {
    ALL_TRUE,
    ANY_TRUE,
}

impl Aligned for ZConditionListEntity_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZConditionListEntity_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL_TRUE => 0i32,
            Self::ANY_TRUE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZConditionListEntity_EEvaluationType {
     const TYPE_ID: &str = "ZConditionListEntity_EEvaluationType";
}

impl StaticVariant for Vec<ZConditionListEntity_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZConditionListEntity_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZConditionListEntity_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZConditionListEntity_EEvaluationType>>";
}

impl Variant for ZConditionListEntity_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZConditionListEntity_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZConditionListEntity_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZConditionListEntity_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZConditionListEntity_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZConditionListEntity_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZContextKillGuide_EContextKillType {
    eCKT_TOILET_DROWN,
    eCKT_SNAP_AND_TOSS,
    eCKT_PUSH,
    eCKT_NO_ANIMATION,
    eCKT_END,
}

impl Aligned for ZContextKillGuide_EContextKillType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZContextKillGuide_EContextKillType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCKT_TOILET_DROWN => 0i32,
            Self::eCKT_SNAP_AND_TOSS => 1i32,
            Self::eCKT_PUSH => 2i32,
            Self::eCKT_NO_ANIMATION => 3i32,
            Self::eCKT_END => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZContextKillGuide_EContextKillType {
     const TYPE_ID: &str = "ZContextKillGuide_EContextKillType";
}

impl StaticVariant for Vec<ZContextKillGuide_EContextKillType> {
     const TYPE_ID: &str = "TArray<ZContextKillGuide_EContextKillType>";
}

impl StaticVariant for Vec<Vec<ZContextKillGuide_EContextKillType>> {
     const TYPE_ID: &str = "TArray<TArray<ZContextKillGuide_EContextKillType>>";
}

impl Variant for ZContextKillGuide_EContextKillType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZContextKillGuide_EContextKillType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZContextKillGuide_EContextKillType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZContextKillGuide_EContextKillType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZContextKillGuide_EContextKillType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZContextKillGuide_EContextKillType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZContextKillGuide_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZContextKillGuide_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZContextKillGuide_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZContextKillGuide_EEvaluationType {
     const TYPE_ID: &str = "ZContextKillGuide_EEvaluationType";
}

impl StaticVariant for Vec<ZContextKillGuide_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZContextKillGuide_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZContextKillGuide_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZContextKillGuide_EEvaluationType>>";
}

impl Variant for ZContextKillGuide_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZContextKillGuide_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZContextKillGuide_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZContextKillGuide_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZContextKillGuide_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZContextKillGuide_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZContractObjectiveHudHintEntity_EObjectiveHintIcon {
    eNone,
    eSuitcase,
    eObjective_A,
    eObjective_B,
    eObjective_C,
    eObjective_D,
    eInfoIcon,
    eExclamationMark,
    eIntelIcon,
    eDiscoveryIcon,
    eDiscoveryIcon_A,
    eDiscoveryIcon_B,
    eDiscoveryIcon_C,
    eDiscoveryIcon_A_Compleed,
    eDiscoveryIcon_B_Compleed,
    eDiscoveryIcon_C_Compleed,
    eMissionObjective,
    eExitMissionIcon,
}

impl Aligned for ZContractObjectiveHudHintEntity_EObjectiveHintIcon {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZContractObjectiveHudHintEntity_EObjectiveHintIcon {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNone => 0i32,
            Self::eSuitcase => 1i32,
            Self::eObjective_A => 3i32,
            Self::eObjective_B => 4i32,
            Self::eObjective_C => 5i32,
            Self::eObjective_D => 6i32,
            Self::eInfoIcon => 7i32,
            Self::eExclamationMark => 8i32,
            Self::eIntelIcon => 9i32,
            Self::eDiscoveryIcon => 10i32,
            Self::eDiscoveryIcon_A => 11i32,
            Self::eDiscoveryIcon_B => 12i32,
            Self::eDiscoveryIcon_C => 13i32,
            Self::eDiscoveryIcon_A_Compleed => 14i32,
            Self::eDiscoveryIcon_B_Compleed => 15i32,
            Self::eDiscoveryIcon_C_Compleed => 16i32,
            Self::eMissionObjective => 17i32,
            Self::eExitMissionIcon => 18i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZContractObjectiveHudHintEntity_EObjectiveHintIcon {
     const TYPE_ID: &str = "ZContractObjectiveHudHintEntity_EObjectiveHintIcon";
}

impl StaticVariant for Vec<ZContractObjectiveHudHintEntity_EObjectiveHintIcon> {
     const TYPE_ID: &str = "TArray<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>";
}

impl StaticVariant for Vec<Vec<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>> {
     const TYPE_ID: &str = "TArray<TArray<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>>";
}

impl Variant for ZContractObjectiveHudHintEntity_EObjectiveHintIcon {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZContractObjectiveHudHintEntity_EObjectiveHintIcon")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZContractObjectiveHudHintEntity_EObjectiveHintIcon".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZContractObjectiveHudHintEntity_EObjectiveHintIcon>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCoverPlane_ECoverSize {
    eLowCover,
    eMediumCover,
    eHighCover,
}

impl Aligned for ZCoverPlane_ECoverSize {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCoverPlane_ECoverSize {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLowCover => 0i32,
            Self::eMediumCover => 1i32,
            Self::eHighCover => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCoverPlane_ECoverSize {
     const TYPE_ID: &str = "ZCoverPlane_ECoverSize";
}

impl StaticVariant for Vec<ZCoverPlane_ECoverSize> {
     const TYPE_ID: &str = "TArray<ZCoverPlane_ECoverSize>";
}

impl StaticVariant for Vec<Vec<ZCoverPlane_ECoverSize>> {
     const TYPE_ID: &str = "TArray<TArray<ZCoverPlane_ECoverSize>>";
}

impl Variant for ZCoverPlane_ECoverSize {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCoverPlane_ECoverSize")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCoverPlane_ECoverSize".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCoverPlane_ECoverSize>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCoverPlane_ECoverSize>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCoverPlane_ECoverSize>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCoverPlane_ECoverType {
    eCoverOnly,
    eCoverAndRail,
    eRailOnly,
}

impl Aligned for ZCoverPlane_ECoverType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCoverPlane_ECoverType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCoverOnly => 0i32,
            Self::eCoverAndRail => 1i32,
            Self::eRailOnly => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCoverPlane_ECoverType {
     const TYPE_ID: &str = "ZCoverPlane_ECoverType";
}

impl StaticVariant for Vec<ZCoverPlane_ECoverType> {
     const TYPE_ID: &str = "TArray<ZCoverPlane_ECoverType>";
}

impl StaticVariant for Vec<Vec<ZCoverPlane_ECoverType>> {
     const TYPE_ID: &str = "TArray<TArray<ZCoverPlane_ECoverType>>";
}

impl Variant for ZCoverPlane_ECoverType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCoverPlane_ECoverType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCoverPlane_ECoverType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCoverPlane_ECoverType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCoverPlane_ECoverType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCoverPlane_ECoverType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZCrowdActorEntity_ECharacterSoundType {
    eSoundType_Male,
    eSoundType_Female,
    eSoundType_Female_Heels,
}

impl Aligned for ZCrowdActorEntity_ECharacterSoundType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZCrowdActorEntity_ECharacterSoundType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSoundType_Male => 0i32,
            Self::eSoundType_Female => 1i32,
            Self::eSoundType_Female_Heels => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZCrowdActorEntity_ECharacterSoundType {
     const TYPE_ID: &str = "ZCrowdActorEntity_ECharacterSoundType";
}

impl StaticVariant for Vec<ZCrowdActorEntity_ECharacterSoundType> {
     const TYPE_ID: &str = "TArray<ZCrowdActorEntity_ECharacterSoundType>";
}

impl StaticVariant for Vec<Vec<ZCrowdActorEntity_ECharacterSoundType>> {
     const TYPE_ID: &str = "TArray<TArray<ZCrowdActorEntity_ECharacterSoundType>>";
}

impl Variant for ZCrowdActorEntity_ECharacterSoundType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZCrowdActorEntity_ECharacterSoundType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZCrowdActorEntity_ECharacterSoundType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZCrowdActorEntity_ECharacterSoundType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZCrowdActorEntity_ECharacterSoundType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZCrowdActorEntity_ECharacterSoundType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDeadBodySituation_ESituationFlavor {
    SF_None,
    SF_Unconscious,
    SF_DeadBody,
    SF_Accident,
}

impl Aligned for ZDeadBodySituation_ESituationFlavor {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDeadBodySituation_ESituationFlavor {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SF_None => 0i32,
            Self::SF_Unconscious => 1i32,
            Self::SF_DeadBody => 2i32,
            Self::SF_Accident => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDeadBodySituation_ESituationFlavor {
     const TYPE_ID: &str = "ZDeadBodySituation_ESituationFlavor";
}

impl StaticVariant for Vec<ZDeadBodySituation_ESituationFlavor> {
     const TYPE_ID: &str = "TArray<ZDeadBodySituation_ESituationFlavor>";
}

impl StaticVariant for Vec<Vec<ZDeadBodySituation_ESituationFlavor>> {
     const TYPE_ID: &str = "TArray<TArray<ZDeadBodySituation_ESituationFlavor>>";
}

impl Variant for ZDeadBodySituation_ESituationFlavor {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDeadBodySituation_ESituationFlavor")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDeadBodySituation_ESituationFlavor".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDeadBodySituation_ESituationFlavor>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDeadBodySituation_ESituationFlavor>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDeadBodySituation_ESituationFlavor>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDebugGizmoEntity_EDrawLayer {
    DL_DEFAULT,
    DL_LIGHT,
    DL_PARTICLES,
    DL_PARTITIONING,
    DL_DECALS,
    DL_CROWD,
    DL_PHYSICS,
    DL_HERO,
    DL_AI,
    DL_AI_GRID,
    DL_AI_SITUATION,
    DL_AI_AREA,
    DL_NPC_LOCOMOTION,
    DL_GAME,
    DL_ALIGNMENT,
    DL_ENGINE,
    DL_SOUND,
    DL_ANIMATION,
    DL_CLOTH,
    DL_SOUND_PARTITIONING,
    DL_UI,
}

impl Aligned for ZDebugGizmoEntity_EDrawLayer {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDebugGizmoEntity_EDrawLayer {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DL_DEFAULT => 0i32,
            Self::DL_LIGHT => 1i32,
            Self::DL_PARTICLES => 2i32,
            Self::DL_PARTITIONING => 3i32,
            Self::DL_DECALS => 4i32,
            Self::DL_CROWD => 5i32,
            Self::DL_PHYSICS => 6i32,
            Self::DL_HERO => 7i32,
            Self::DL_AI => 8i32,
            Self::DL_AI_GRID => 9i32,
            Self::DL_AI_SITUATION => 10i32,
            Self::DL_AI_AREA => 11i32,
            Self::DL_NPC_LOCOMOTION => 12i32,
            Self::DL_GAME => 13i32,
            Self::DL_ALIGNMENT => 14i32,
            Self::DL_ENGINE => 15i32,
            Self::DL_SOUND => 16i32,
            Self::DL_ANIMATION => 17i32,
            Self::DL_CLOTH => 18i32,
            Self::DL_SOUND_PARTITIONING => 19i32,
            Self::DL_UI => 20i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDebugGizmoEntity_EDrawLayer {
     const TYPE_ID: &str = "ZDebugGizmoEntity_EDrawLayer";
}

impl StaticVariant for Vec<ZDebugGizmoEntity_EDrawLayer> {
     const TYPE_ID: &str = "TArray<ZDebugGizmoEntity_EDrawLayer>";
}

impl StaticVariant for Vec<Vec<ZDebugGizmoEntity_EDrawLayer>> {
     const TYPE_ID: &str = "TArray<TArray<ZDebugGizmoEntity_EDrawLayer>>";
}

impl Variant for ZDebugGizmoEntity_EDrawLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDebugGizmoEntity_EDrawLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDebugGizmoEntity_EDrawLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDebugGizmoEntity_EDrawLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDebugGizmoEntity_EDrawLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDebugGizmoEntity_EDrawLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDebugHM5GameTimeMultiplierEnt_eTMLDReason {
    eTMLDR_HintMessages,
    eTMLDR_Sequence,
    eTMLDR_ActionKillHeadShot,
    eTMLDR_ActionKillCCProp,
    eTMLDR_ActionKillExplosion,
    eTMLDR_ActionKillLastEnemyInEncounter,
    eTMLDR_ActionKillLastEnemyInCheckPoint,
    eTMLDR_NOTSET,
}

impl Aligned for ZDebugHM5GameTimeMultiplierEnt_eTMLDReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDebugHM5GameTimeMultiplierEnt_eTMLDReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTMLDR_HintMessages => 0i32,
            Self::eTMLDR_Sequence => 1i32,
            Self::eTMLDR_ActionKillHeadShot => 2i32,
            Self::eTMLDR_ActionKillCCProp => 3i32,
            Self::eTMLDR_ActionKillExplosion => 4i32,
            Self::eTMLDR_ActionKillLastEnemyInEncounter => 5i32,
            Self::eTMLDR_ActionKillLastEnemyInCheckPoint => 6i32,
            Self::eTMLDR_NOTSET => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDebugHM5GameTimeMultiplierEnt_eTMLDReason {
     const TYPE_ID: &str = "ZDebugHM5GameTimeMultiplierEnt_eTMLDReason";
}

impl StaticVariant for Vec<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason> {
     const TYPE_ID: &str = "TArray<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>";
}

impl StaticVariant for Vec<Vec<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>> {
     const TYPE_ID: &str = "TArray<TArray<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>>";
}

impl Variant for ZDebugHM5GameTimeMultiplierEnt_eTMLDReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDebugHM5GameTimeMultiplierEnt_eTMLDReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDebugHM5GameTimeMultiplierEnt_eTMLDReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDebugHM5GameTimeMultiplierEnt_eTMLDReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDebugSpatialEntity_EDrawLayer {
    DL_DEFAULT,
    DL_LIGHT,
    DL_PARTICLES,
    DL_PARTITIONING,
    DL_DECALS,
    DL_CROWD,
    DL_PHYSICS,
    DL_HERO,
    DL_AI,
    DL_AI_GRID,
    DL_AI_SITUATION,
    DL_NPC_LOCOMOTION,
    DL_GAME,
    DL_ALIGNMENT,
    DL_ENGINE,
    DL_SOUND,
    DL_ANIMATION,
    DL_CLOTH,
    DL_SOUND_PARTITIONING,
    DL_UI,
}

impl Aligned for ZDebugSpatialEntity_EDrawLayer {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDebugSpatialEntity_EDrawLayer {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DL_DEFAULT => 0i32,
            Self::DL_LIGHT => 1i32,
            Self::DL_PARTICLES => 2i32,
            Self::DL_PARTITIONING => 3i32,
            Self::DL_DECALS => 4i32,
            Self::DL_CROWD => 5i32,
            Self::DL_PHYSICS => 6i32,
            Self::DL_HERO => 7i32,
            Self::DL_AI => 8i32,
            Self::DL_AI_GRID => 9i32,
            Self::DL_AI_SITUATION => 10i32,
            Self::DL_NPC_LOCOMOTION => 11i32,
            Self::DL_GAME => 12i32,
            Self::DL_ALIGNMENT => 13i32,
            Self::DL_ENGINE => 14i32,
            Self::DL_SOUND => 15i32,
            Self::DL_ANIMATION => 16i32,
            Self::DL_CLOTH => 17i32,
            Self::DL_SOUND_PARTITIONING => 18i32,
            Self::DL_UI => 19i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDebugSpatialEntity_EDrawLayer {
     const TYPE_ID: &str = "ZDebugSpatialEntity_EDrawLayer";
}

impl StaticVariant for Vec<ZDebugSpatialEntity_EDrawLayer> {
     const TYPE_ID: &str = "TArray<ZDebugSpatialEntity_EDrawLayer>";
}

impl StaticVariant for Vec<Vec<ZDebugSpatialEntity_EDrawLayer>> {
     const TYPE_ID: &str = "TArray<TArray<ZDebugSpatialEntity_EDrawLayer>>";
}

impl Variant for ZDebugSpatialEntity_EDrawLayer {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDebugSpatialEntity_EDrawLayer")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDebugSpatialEntity_EDrawLayer".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDebugSpatialEntity_EDrawLayer>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDebugSpatialEntity_EDrawLayer>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDebugSpatialEntity_EDrawLayer>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDebugTextEntity_EHorizontalAlignment {
    HA_LEFT,
    HA_CENTER,
    HA_RIGHT,
}

impl Aligned for ZDebugTextEntity_EHorizontalAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDebugTextEntity_EHorizontalAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::HA_LEFT => 1i32,
            Self::HA_CENTER => 0i32,
            Self::HA_RIGHT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDebugTextEntity_EHorizontalAlignment {
     const TYPE_ID: &str = "ZDebugTextEntity_EHorizontalAlignment";
}

impl StaticVariant for Vec<ZDebugTextEntity_EHorizontalAlignment> {
     const TYPE_ID: &str = "TArray<ZDebugTextEntity_EHorizontalAlignment>";
}

impl StaticVariant for Vec<Vec<ZDebugTextEntity_EHorizontalAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZDebugTextEntity_EHorizontalAlignment>>";
}

impl Variant for ZDebugTextEntity_EHorizontalAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDebugTextEntity_EHorizontalAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDebugTextEntity_EHorizontalAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDebugTextEntity_EHorizontalAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDebugTextEntity_EHorizontalAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDebugTextEntity_EHorizontalAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDebugTextEntity_EVerticalAlignment {
    VA_TOP,
    VA_CENTER,
    VA_BOTTOM,
}

impl Aligned for ZDebugTextEntity_EVerticalAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDebugTextEntity_EVerticalAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::VA_TOP => 16i32,
            Self::VA_CENTER => 0i32,
            Self::VA_BOTTOM => 32i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDebugTextEntity_EVerticalAlignment {
     const TYPE_ID: &str = "ZDebugTextEntity_EVerticalAlignment";
}

impl StaticVariant for Vec<ZDebugTextEntity_EVerticalAlignment> {
     const TYPE_ID: &str = "TArray<ZDebugTextEntity_EVerticalAlignment>";
}

impl StaticVariant for Vec<Vec<ZDebugTextEntity_EVerticalAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZDebugTextEntity_EVerticalAlignment>>";
}

impl Variant for ZDebugTextEntity_EVerticalAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDebugTextEntity_EVerticalAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDebugTextEntity_EVerticalAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDebugTextEntity_EVerticalAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDebugTextEntity_EVerticalAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDebugTextEntity_EVerticalAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDecalControllerEntity_ERotationType {
    eRotationDisable,
    eRotationAlignRay,
    eRotationRandom,
}

impl Aligned for ZDecalControllerEntity_ERotationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDecalControllerEntity_ERotationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRotationDisable => 0i32,
            Self::eRotationAlignRay => 1i32,
            Self::eRotationRandom => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDecalControllerEntity_ERotationType {
     const TYPE_ID: &str = "ZDecalControllerEntity_ERotationType";
}

impl StaticVariant for Vec<ZDecalControllerEntity_ERotationType> {
     const TYPE_ID: &str = "TArray<ZDecalControllerEntity_ERotationType>";
}

impl StaticVariant for Vec<Vec<ZDecalControllerEntity_ERotationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZDecalControllerEntity_ERotationType>>";
}

impl Variant for ZDecalControllerEntity_ERotationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDecalControllerEntity_ERotationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDecalControllerEntity_ERotationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDecalControllerEntity_ERotationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDecalControllerEntity_ERotationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDecalControllerEntity_ERotationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDecalControllerEntity_EScaleType {
    eScaleDisable,
    eScaleUniform,
    eScaleY,
}

impl Aligned for ZDecalControllerEntity_EScaleType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDecalControllerEntity_EScaleType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eScaleDisable => 0i32,
            Self::eScaleUniform => 1i32,
            Self::eScaleY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDecalControllerEntity_EScaleType {
     const TYPE_ID: &str = "ZDecalControllerEntity_EScaleType";
}

impl StaticVariant for Vec<ZDecalControllerEntity_EScaleType> {
     const TYPE_ID: &str = "TArray<ZDecalControllerEntity_EScaleType>";
}

impl StaticVariant for Vec<Vec<ZDecalControllerEntity_EScaleType>> {
     const TYPE_ID: &str = "TArray<TArray<ZDecalControllerEntity_EScaleType>>";
}

impl Variant for ZDecalControllerEntity_EScaleType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDecalControllerEntity_EScaleType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDecalControllerEntity_EScaleType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDecalControllerEntity_EScaleType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDecalControllerEntity_EScaleType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDecalControllerEntity_EScaleType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDetectedInPrivateGroup_EInvestigateGroupState {
    IGS_Delay,
    IGS_Talk,
    IGS_Move,
    IGS_Wait,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZDetectedInPrivateGroup_EInvestigateGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDetectedInPrivateGroup_EInvestigateGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_Delay => 0i32,
            Self::IGS_Talk => 1i32,
            Self::IGS_Move => 2i32,
            Self::IGS_Wait => 3i32,
            Self::IGS_Completed => 4i32,
            Self::IGS_Max => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDetectedInPrivateGroup_EInvestigateGroupState {
     const TYPE_ID: &str = "ZDetectedInPrivateGroup_EInvestigateGroupState";
}

impl StaticVariant for Vec<ZDetectedInPrivateGroup_EInvestigateGroupState> {
     const TYPE_ID: &str = "TArray<ZDetectedInPrivateGroup_EInvestigateGroupState>";
}

impl StaticVariant for Vec<Vec<ZDetectedInPrivateGroup_EInvestigateGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZDetectedInPrivateGroup_EInvestigateGroupState>>";
}

impl Variant for ZDetectedInPrivateGroup_EInvestigateGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDetectedInPrivateGroup_EInvestigateGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDetectedInPrivateGroup_EInvestigateGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDetectedInPrivateGroup_EInvestigateGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDetectedInPrivateGroup_EInvestigateGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDetectedInPrivateGroup_EInvestigateGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDistanceCondition_ECompareMethod {
    CM_GreaterOrEqualThan,
    CM_LessThan,
}

impl Aligned for ZDistanceCondition_ECompareMethod {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDistanceCondition_ECompareMethod {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CM_GreaterOrEqualThan => 0i32,
            Self::CM_LessThan => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDistanceCondition_ECompareMethod {
     const TYPE_ID: &str = "ZDistanceCondition_ECompareMethod";
}

impl StaticVariant for Vec<ZDistanceCondition_ECompareMethod> {
     const TYPE_ID: &str = "TArray<ZDistanceCondition_ECompareMethod>";
}

impl StaticVariant for Vec<Vec<ZDistanceCondition_ECompareMethod>> {
     const TYPE_ID: &str = "TArray<TArray<ZDistanceCondition_ECompareMethod>>";
}

impl Variant for ZDistanceCondition_ECompareMethod {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDistanceCondition_ECompareMethod")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDistanceCondition_ECompareMethod".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDistanceCondition_ECompareMethod>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDistanceCondition_ECompareMethod>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDistanceCondition_ECompareMethod>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDistanceCondition_EObjectType {
    DT_ToCam,
    DT_ToPlayer,
}

impl Aligned for ZDistanceCondition_EObjectType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDistanceCondition_EObjectType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DT_ToCam => 0i32,
            Self::DT_ToPlayer => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDistanceCondition_EObjectType {
     const TYPE_ID: &str = "ZDistanceCondition_EObjectType";
}

impl StaticVariant for Vec<ZDistanceCondition_EObjectType> {
     const TYPE_ID: &str = "TArray<ZDistanceCondition_EObjectType>";
}

impl StaticVariant for Vec<Vec<ZDistanceCondition_EObjectType>> {
     const TYPE_ID: &str = "TArray<TArray<ZDistanceCondition_EObjectType>>";
}

impl Variant for ZDistanceCondition_EObjectType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDistanceCondition_EObjectType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDistanceCondition_EObjectType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDistanceCondition_EObjectType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDistanceCondition_EObjectType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDistanceCondition_EObjectType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZDramaSituationEntity_EReentryBehavior {
    RB_CONTINUE,
    RB_TERMINATE,
    RB_RESTART,
    RB_RECASTANDRESTART,
    RB_RECASTANDCONTINUE,
}

impl Aligned for ZDramaSituationEntity_EReentryBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZDramaSituationEntity_EReentryBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RB_CONTINUE => 0i32,
            Self::RB_TERMINATE => 1i32,
            Self::RB_RESTART => 2i32,
            Self::RB_RECASTANDRESTART => 3i32,
            Self::RB_RECASTANDCONTINUE => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZDramaSituationEntity_EReentryBehavior {
     const TYPE_ID: &str = "ZDramaSituationEntity_EReentryBehavior";
}

impl StaticVariant for Vec<ZDramaSituationEntity_EReentryBehavior> {
     const TYPE_ID: &str = "TArray<ZDramaSituationEntity_EReentryBehavior>";
}

impl StaticVariant for Vec<Vec<ZDramaSituationEntity_EReentryBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<ZDramaSituationEntity_EReentryBehavior>>";
}

impl Variant for ZDramaSituationEntity_EReentryBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZDramaSituationEntity_EReentryBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZDramaSituationEntity_EReentryBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZDramaSituationEntity_EReentryBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZDramaSituationEntity_EReentryBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZDramaSituationEntity_EReentryBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEntityPropertyReplica_EReplicationStrategy {
    REP_ALL_PROPERTIES,
    REP_ALL_EXCEPT,
    REP_ONLY_SPECIFIC,
}

impl Aligned for ZEntityPropertyReplica_EReplicationStrategy {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEntityPropertyReplica_EReplicationStrategy {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::REP_ALL_PROPERTIES => 0i32,
            Self::REP_ALL_EXCEPT => 1i32,
            Self::REP_ONLY_SPECIFIC => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEntityPropertyReplica_EReplicationStrategy {
     const TYPE_ID: &str = "ZEntityPropertyReplica_EReplicationStrategy";
}

impl StaticVariant for Vec<ZEntityPropertyReplica_EReplicationStrategy> {
     const TYPE_ID: &str = "TArray<ZEntityPropertyReplica_EReplicationStrategy>";
}

impl StaticVariant for Vec<Vec<ZEntityPropertyReplica_EReplicationStrategy>> {
     const TYPE_ID: &str = "TArray<TArray<ZEntityPropertyReplica_EReplicationStrategy>>";
}

impl Variant for ZEntityPropertyReplica_EReplicationStrategy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEntityPropertyReplica_EReplicationStrategy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEntityPropertyReplica_EReplicationStrategy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEntityPropertyReplica_EReplicationStrategy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEntityPropertyReplica_EReplicationStrategy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEntityPropertyReplica_EReplicationStrategy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenCampaignDefinitionPollInt_EQuery {
    DifficultyRank,
    Deposit,
    PayoutBase,
    NumTerritories,
}

impl Aligned for ZEvergreenCampaignDefinitionPollInt_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenCampaignDefinitionPollInt_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DifficultyRank => 0i32,
            Self::Deposit => 1i32,
            Self::PayoutBase => 2i32,
            Self::NumTerritories => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenCampaignDefinitionPollInt_EQuery {
     const TYPE_ID: &str = "ZEvergreenCampaignDefinitionPollInt_EQuery";
}

impl StaticVariant for Vec<ZEvergreenCampaignDefinitionPollInt_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenCampaignDefinitionPollInt_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenCampaignDefinitionPollInt_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenCampaignDefinitionPollInt_EQuery>>";
}

impl Variant for ZEvergreenCampaignDefinitionPollInt_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenCampaignDefinitionPollInt_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenCampaignDefinitionPollInt_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenCampaignDefinitionPollInt_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenCampaignDefinitionPollInt_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenCampaignDefinitionPollInt_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenCampaignDefinitionPollString_EQuery {
    LeaderCodename,
    Biography,
}

impl Aligned for ZEvergreenCampaignDefinitionPollString_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenCampaignDefinitionPollString_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LeaderCodename => 0i32,
            Self::Biography => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenCampaignDefinitionPollString_EQuery {
     const TYPE_ID: &str = "ZEvergreenCampaignDefinitionPollString_EQuery";
}

impl StaticVariant for Vec<ZEvergreenCampaignDefinitionPollString_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenCampaignDefinitionPollString_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenCampaignDefinitionPollString_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenCampaignDefinitionPollString_EQuery>>";
}

impl Variant for ZEvergreenCampaignDefinitionPollString_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenCampaignDefinitionPollString_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenCampaignDefinitionPollString_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenCampaignDefinitionPollString_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenCampaignDefinitionPollString_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenCampaignDefinitionPollString_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenCampaignStatusPollInt_EQuery {
    DifficultyRank,
    Deposit,
    PayoutBase,
    NumTerritories,
}

impl Aligned for ZEvergreenCampaignStatusPollInt_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenCampaignStatusPollInt_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::DifficultyRank => 0i32,
            Self::Deposit => 1i32,
            Self::PayoutBase => 2i32,
            Self::NumTerritories => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenCampaignStatusPollInt_EQuery {
     const TYPE_ID: &str = "ZEvergreenCampaignStatusPollInt_EQuery";
}

impl StaticVariant for Vec<ZEvergreenCampaignStatusPollInt_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenCampaignStatusPollInt_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenCampaignStatusPollInt_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenCampaignStatusPollInt_EQuery>>";
}

impl Variant for ZEvergreenCampaignStatusPollInt_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenCampaignStatusPollInt_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenCampaignStatusPollInt_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenCampaignStatusPollInt_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenCampaignStatusPollInt_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenCampaignStatusPollInt_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenCampaignStatusPollString_EQuery {
    LeaderCodename,
    Biography,
}

impl Aligned for ZEvergreenCampaignStatusPollString_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenCampaignStatusPollString_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LeaderCodename => 0i32,
            Self::Biography => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenCampaignStatusPollString_EQuery {
     const TYPE_ID: &str = "ZEvergreenCampaignStatusPollString_EQuery";
}

impl StaticVariant for Vec<ZEvergreenCampaignStatusPollString_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenCampaignStatusPollString_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenCampaignStatusPollString_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenCampaignStatusPollString_EQuery>>";
}

impl Variant for ZEvergreenCampaignStatusPollString_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenCampaignStatusPollString_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenCampaignStatusPollString_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenCampaignStatusPollString_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenCampaignStatusPollString_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenCampaignStatusPollString_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenGearWallMenuEntryAddOn_EItemRarity {
    SAFEHOUSEONLY,
    NONE,
    COMMON,
    RARE,
    EPIC,
    LEGENDARY,
}

impl Aligned for ZEvergreenGearWallMenuEntryAddOn_EItemRarity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenGearWallMenuEntryAddOn_EItemRarity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SAFEHOUSEONLY => -1i32,
            Self::NONE => 0i32,
            Self::COMMON => 1i32,
            Self::RARE => 2i32,
            Self::EPIC => 3i32,
            Self::LEGENDARY => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenGearWallMenuEntryAddOn_EItemRarity {
     const TYPE_ID: &str = "ZEvergreenGearWallMenuEntryAddOn_EItemRarity";
}

impl StaticVariant for Vec<ZEvergreenGearWallMenuEntryAddOn_EItemRarity> {
     const TYPE_ID: &str = "TArray<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>";
}

impl StaticVariant for Vec<Vec<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>>";
}

impl Variant for ZEvergreenGearWallMenuEntryAddOn_EItemRarity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenGearWallMenuEntryAddOn_EItemRarity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenGearWallMenuEntryAddOn_EItemRarity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenGearWallMenuEntryAddOn_EItemRarity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZEvergreenIntelWallDataProvider_EAgenda {
    Unknown,
    HandoverMeeting,
    BusinessMeeting,
    SecretMeeting,
    NoMeeting,
}

impl Aligned for ZEvergreenIntelWallDataProvider_EAgenda {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZEvergreenIntelWallDataProvider_EAgenda {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Unknown => -1i8,
            Self::HandoverMeeting => 0i8,
            Self::BusinessMeeting => 1i8,
            Self::SecretMeeting => 2i8,
            Self::NoMeeting => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenIntelWallDataProvider_EAgenda {
     const TYPE_ID: &str = "ZEvergreenIntelWallDataProvider_EAgenda";
}

impl StaticVariant for Vec<ZEvergreenIntelWallDataProvider_EAgenda> {
     const TYPE_ID: &str = "TArray<ZEvergreenIntelWallDataProvider_EAgenda>";
}

impl StaticVariant for Vec<Vec<ZEvergreenIntelWallDataProvider_EAgenda>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenIntelWallDataProvider_EAgenda>>";
}

impl Variant for ZEvergreenIntelWallDataProvider_EAgenda {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenIntelWallDataProvider_EAgenda")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenIntelWallDataProvider_EAgenda".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenIntelWallDataProvider_EAgenda>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenIntelWallDataProvider_EAgenda>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenIntelWallDataProvider_EAgenda>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZEvergreenIntelWallDataProvider_ELook {
    Unknown,
    Glasses,
    Earrings,
    Necklace,
    Watch,
    Hat,
    Tattoo,
    BlackHair,
    BrownHair,
    BlondeHair,
    GreyHair,
    RedHair,
    NoHair,
}

impl Aligned for ZEvergreenIntelWallDataProvider_ELook {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZEvergreenIntelWallDataProvider_ELook {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Unknown => -1i8,
            Self::Glasses => 0i8,
            Self::Earrings => 1i8,
            Self::Necklace => 2i8,
            Self::Watch => 3i8,
            Self::Hat => 4i8,
            Self::Tattoo => 5i8,
            Self::BlackHair => 6i8,
            Self::BrownHair => 7i8,
            Self::BlondeHair => 8i8,
            Self::GreyHair => 9i8,
            Self::RedHair => 10i8,
            Self::NoHair => 11i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenIntelWallDataProvider_ELook {
     const TYPE_ID: &str = "ZEvergreenIntelWallDataProvider_ELook";
}

impl StaticVariant for Vec<ZEvergreenIntelWallDataProvider_ELook> {
     const TYPE_ID: &str = "TArray<ZEvergreenIntelWallDataProvider_ELook>";
}

impl StaticVariant for Vec<Vec<ZEvergreenIntelWallDataProvider_ELook>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenIntelWallDataProvider_ELook>>";
}

impl Variant for ZEvergreenIntelWallDataProvider_ELook {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenIntelWallDataProvider_ELook")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenIntelWallDataProvider_ELook".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenIntelWallDataProvider_ELook>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenIntelWallDataProvider_ELook>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenIntelWallDataProvider_ELook>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZEvergreenIntelWallDataProvider_ETell {
    Unknown,
    Smoker,
    Allergic,
    SweetTooth,
    Bookworm,
    Nervous,
    Dehydrated,
    Foodie,
}

impl Aligned for ZEvergreenIntelWallDataProvider_ETell {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZEvergreenIntelWallDataProvider_ETell {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Unknown => -1i8,
            Self::Smoker => 0i8,
            Self::Allergic => 1i8,
            Self::SweetTooth => 2i8,
            Self::Bookworm => 3i8,
            Self::Nervous => 4i8,
            Self::Dehydrated => 5i8,
            Self::Foodie => 6i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenIntelWallDataProvider_ETell {
     const TYPE_ID: &str = "ZEvergreenIntelWallDataProvider_ETell";
}

impl StaticVariant for Vec<ZEvergreenIntelWallDataProvider_ETell> {
     const TYPE_ID: &str = "TArray<ZEvergreenIntelWallDataProvider_ETell>";
}

impl StaticVariant for Vec<Vec<ZEvergreenIntelWallDataProvider_ETell>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenIntelWallDataProvider_ETell>>";
}

impl Variant for ZEvergreenIntelWallDataProvider_ETell {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenIntelWallDataProvider_ETell")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenIntelWallDataProvider_ETell".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenIntelWallDataProvider_ETell>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenIntelWallDataProvider_ETell>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenIntelWallDataProvider_ETell>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenLocationIntelDataProvider_EVisited {
    NotVisited,
    VisitedAndWon,
    VisitedAndLost,
}

impl Aligned for ZEvergreenLocationIntelDataProvider_EVisited {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenLocationIntelDataProvider_EVisited {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NotVisited => 0i32,
            Self::VisitedAndWon => 1i32,
            Self::VisitedAndLost => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenLocationIntelDataProvider_EVisited {
     const TYPE_ID: &str = "ZEvergreenLocationIntelDataProvider_EVisited";
}

impl StaticVariant for Vec<ZEvergreenLocationIntelDataProvider_EVisited> {
     const TYPE_ID: &str = "TArray<ZEvergreenLocationIntelDataProvider_EVisited>";
}

impl StaticVariant for Vec<Vec<ZEvergreenLocationIntelDataProvider_EVisited>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenLocationIntelDataProvider_EVisited>>";
}

impl Variant for ZEvergreenLocationIntelDataProvider_EVisited {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenLocationIntelDataProvider_EVisited")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenLocationIntelDataProvider_EVisited".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenLocationIntelDataProvider_EVisited>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenLocationIntelDataProvider_EVisited>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenLocationIntelDataProvider_EVisited>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuCondition_EQuery {
    IS_OPENING,
    IS_OPEN,
    IS_OPENING_OR_OPEN,
    IS_CLOSING,
    IS_CLOSED,
    IS_PROCESSING_INPUT,
    IS_ZOOMED_IN,
    IS_ZOOMED_OUT,
}

impl Aligned for ZEvergreenMenuCondition_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuCondition_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IS_OPENING => 0i32,
            Self::IS_OPEN => 1i32,
            Self::IS_OPENING_OR_OPEN => 2i32,
            Self::IS_CLOSING => 3i32,
            Self::IS_CLOSED => 4i32,
            Self::IS_PROCESSING_INPUT => 5i32,
            Self::IS_ZOOMED_IN => 6i32,
            Self::IS_ZOOMED_OUT => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuCondition_EQuery {
     const TYPE_ID: &str = "ZEvergreenMenuCondition_EQuery";
}

impl StaticVariant for Vec<ZEvergreenMenuCondition_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuCondition_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuCondition_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuCondition_EQuery>>";
}

impl Variant for ZEvergreenMenuCondition_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuCondition_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuCondition_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuCondition_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuCondition_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuCondition_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuCounterScrollEntity_EAxis2DMouse {
    X,
    Y,
    XInverted,
    YInverted,
}

impl Aligned for ZEvergreenMenuCounterScrollEntity_EAxis2DMouse {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuCounterScrollEntity_EAxis2DMouse {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X => 0i32,
            Self::Y => 1i32,
            Self::XInverted => 2i32,
            Self::YInverted => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuCounterScrollEntity_EAxis2DMouse {
     const TYPE_ID: &str = "ZEvergreenMenuCounterScrollEntity_EAxis2DMouse";
}

impl StaticVariant for Vec<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>>";
}

impl Variant for ZEvergreenMenuCounterScrollEntity_EAxis2DMouse {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuCounterScrollEntity_EAxis2DMouse")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuCounterScrollEntity_EAxis2DMouse".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuCounterScrollEntity_EAxis2DMouse>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuCounterScrollEntity_EAxis3DSpace {
    X,
    Y,
    Z,
}

impl Aligned for ZEvergreenMenuCounterScrollEntity_EAxis3DSpace {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuCounterScrollEntity_EAxis3DSpace {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X => 0i32,
            Self::Y => 1i32,
            Self::Z => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuCounterScrollEntity_EAxis3DSpace {
     const TYPE_ID: &str = "ZEvergreenMenuCounterScrollEntity_EAxis3DSpace";
}

impl StaticVariant for Vec<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>>";
}

impl Variant for ZEvergreenMenuCounterScrollEntity_EAxis3DSpace {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuCounterScrollEntity_EAxis3DSpace")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuCounterScrollEntity_EAxis3DSpace".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuCounterScrollEntity_EAxis3DSpace>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuEntryCondition_EQuery {
    IS_SELECTED,
    IS_SELECTED_AND_ZOOMED_OUT,
    IS_SELECTED_AND_ZOOMED_IN,
}

impl Aligned for ZEvergreenMenuEntryCondition_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuEntryCondition_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IS_SELECTED => 0i32,
            Self::IS_SELECTED_AND_ZOOMED_OUT => 1i32,
            Self::IS_SELECTED_AND_ZOOMED_IN => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuEntryCondition_EQuery {
     const TYPE_ID: &str = "ZEvergreenMenuEntryCondition_EQuery";
}

impl StaticVariant for Vec<ZEvergreenMenuEntryCondition_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuEntryCondition_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuEntryCondition_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuEntryCondition_EQuery>>";
}

impl Variant for ZEvergreenMenuEntryCondition_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuEntryCondition_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuEntryCondition_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuEntryCondition_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuEntryCondition_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuEntryCondition_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuEntryEntity_ECursorShape {
    AUTO,
    FLAT,
    CYLINDER,
    SPHERE,
    NONE,
}

impl Aligned for ZEvergreenMenuEntryEntity_ECursorShape {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuEntryEntity_ECursorShape {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AUTO => 0i32,
            Self::FLAT => 1i32,
            Self::CYLINDER => 2i32,
            Self::SPHERE => 3i32,
            Self::NONE => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuEntryEntity_ECursorShape {
     const TYPE_ID: &str = "ZEvergreenMenuEntryEntity_ECursorShape";
}

impl StaticVariant for Vec<ZEvergreenMenuEntryEntity_ECursorShape> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuEntryEntity_ECursorShape>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuEntryEntity_ECursorShape>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuEntryEntity_ECursorShape>>";
}

impl Variant for ZEvergreenMenuEntryEntity_ECursorShape {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuEntryEntity_ECursorShape")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuEntryEntity_ECursorShape".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuEntryEntity_ECursorShape>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuEntryEntity_ECursorShape>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuEntryEntity_ECursorShape>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuEntryPromptButtonAction_EInputTrigger {
    ACCEPT,
    CANCEL,
    ACTION_X,
    ACTION_Y,
}

impl Aligned for ZEvergreenMenuEntryPromptButtonAction_EInputTrigger {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuEntryPromptButtonAction_EInputTrigger {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ACCEPT => 0i32,
            Self::CANCEL => 1i32,
            Self::ACTION_X => 2i32,
            Self::ACTION_Y => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuEntryPromptButtonAction_EInputTrigger {
     const TYPE_ID: &str = "ZEvergreenMenuEntryPromptButtonAction_EInputTrigger";
}

impl StaticVariant for Vec<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>>";
}

impl Variant for ZEvergreenMenuEntryPromptButtonAction_EInputTrigger {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuEntryPromptButtonAction_EInputTrigger")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuEntryPromptButtonAction_EInputTrigger".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuEntryPromptButtonAction_EInputTrigger>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuGlobalCondition_EQuery {
    IS_ANY_MENU_OPEN,
    IS_ANY_MENU_PROCESSING_INPUT,
    IS_ANY_MENU_SUPPRESSING_SPATIAL_ICONS,
}

impl Aligned for ZEvergreenMenuGlobalCondition_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuGlobalCondition_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IS_ANY_MENU_OPEN => 0i32,
            Self::IS_ANY_MENU_PROCESSING_INPUT => 1i32,
            Self::IS_ANY_MENU_SUPPRESSING_SPATIAL_ICONS => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuGlobalCondition_EQuery {
     const TYPE_ID: &str = "ZEvergreenMenuGlobalCondition_EQuery";
}

impl StaticVariant for Vec<ZEvergreenMenuGlobalCondition_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuGlobalCondition_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuGlobalCondition_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuGlobalCondition_EQuery>>";
}

impl Variant for ZEvergreenMenuGlobalCondition_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuGlobalCondition_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuGlobalCondition_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuGlobalCondition_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuGlobalCondition_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuGlobalCondition_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuValueFloatQuery_EQuery {
    OPEN_ANIM_PROGRESS,
    ZOOM_ANIM_PROGRESS,
}

impl Aligned for ZEvergreenMenuValueFloatQuery_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuValueFloatQuery_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::OPEN_ANIM_PROGRESS => 0i32,
            Self::ZOOM_ANIM_PROGRESS => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuValueFloatQuery_EQuery {
     const TYPE_ID: &str = "ZEvergreenMenuValueFloatQuery_EQuery";
}

impl StaticVariant for Vec<ZEvergreenMenuValueFloatQuery_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuValueFloatQuery_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuValueFloatQuery_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuValueFloatQuery_EQuery>>";
}

impl Variant for ZEvergreenMenuValueFloatQuery_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuValueFloatQuery_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuValueFloatQuery_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuValueFloatQuery_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuValueFloatQuery_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuValueFloatQuery_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenMenuValueVector3Query_EQuery {
    CENTER_OF_SELECTED_ENTITY,
}

impl Aligned for ZEvergreenMenuValueVector3Query_EQuery {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenMenuValueVector3Query_EQuery {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CENTER_OF_SELECTED_ENTITY => 0i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenMenuValueVector3Query_EQuery {
     const TYPE_ID: &str = "ZEvergreenMenuValueVector3Query_EQuery";
}

impl StaticVariant for Vec<ZEvergreenMenuValueVector3Query_EQuery> {
     const TYPE_ID: &str = "TArray<ZEvergreenMenuValueVector3Query_EQuery>";
}

impl StaticVariant for Vec<Vec<ZEvergreenMenuValueVector3Query_EQuery>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenMenuValueVector3Query_EQuery>>";
}

impl Variant for ZEvergreenMenuValueVector3Query_EQuery {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenMenuValueVector3Query_EQuery")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenMenuValueVector3Query_EQuery".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenMenuValueVector3Query_EQuery>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenMenuValueVector3Query_EQuery>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenMenuValueVector3Query_EQuery>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenVitalInfoEntity_EVitalInfoType {
    Assassin,
    Lookout,
    Territory,
    PrestigeObjective,
}

impl Aligned for ZEvergreenVitalInfoEntity_EVitalInfoType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenVitalInfoEntity_EVitalInfoType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Assassin => 0i32,
            Self::Lookout => 1i32,
            Self::Territory => 2i32,
            Self::PrestigeObjective => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenVitalInfoEntity_EVitalInfoType {
     const TYPE_ID: &str = "ZEvergreenVitalInfoEntity_EVitalInfoType";
}

impl StaticVariant for Vec<ZEvergreenVitalInfoEntity_EVitalInfoType> {
     const TYPE_ID: &str = "TArray<ZEvergreenVitalInfoEntity_EVitalInfoType>";
}

impl StaticVariant for Vec<Vec<ZEvergreenVitalInfoEntity_EVitalInfoType>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenVitalInfoEntity_EVitalInfoType>>";
}

impl Variant for ZEvergreenVitalInfoEntity_EVitalInfoType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenVitalInfoEntity_EVitalInfoType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenVitalInfoEntity_EVitalInfoType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenVitalInfoEntity_EVitalInfoType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenVitalInfoEntity_EVitalInfoType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenVitalInfoEntity_EVitalInfoType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZEvergreenWorldMapTerritoryDataProvider_EVisited {
    NotVisited,
    VisitedAndWon,
    VisitedAndLost,
}

impl Aligned for ZEvergreenWorldMapTerritoryDataProvider_EVisited {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZEvergreenWorldMapTerritoryDataProvider_EVisited {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NotVisited => 0i32,
            Self::VisitedAndWon => 1i32,
            Self::VisitedAndLost => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZEvergreenWorldMapTerritoryDataProvider_EVisited {
     const TYPE_ID: &str = "ZEvergreenWorldMapTerritoryDataProvider_EVisited";
}

impl StaticVariant for Vec<ZEvergreenWorldMapTerritoryDataProvider_EVisited> {
     const TYPE_ID: &str = "TArray<ZEvergreenWorldMapTerritoryDataProvider_EVisited>";
}

impl StaticVariant for Vec<Vec<ZEvergreenWorldMapTerritoryDataProvider_EVisited>> {
     const TYPE_ID: &str = "TArray<TArray<ZEvergreenWorldMapTerritoryDataProvider_EVisited>>";
}

impl Variant for ZEvergreenWorldMapTerritoryDataProvider_EVisited {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZEvergreenWorldMapTerritoryDataProvider_EVisited")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZEvergreenWorldMapTerritoryDataProvider_EVisited".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZEvergreenWorldMapTerritoryDataProvider_EVisited>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZEvergreenWorldMapTerritoryDataProvider_EVisited>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZEvergreenWorldMapTerritoryDataProvider_EVisited>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZGetHelpGroup_EInvestigateGroupState {
    IGS_Acknowledge,
    IGS_WaitForAckDialog,
    IGS_RunToGuard,
    IGS_ReportToHitman,
    IGS_ReportToGuard,
    IGS_StartMoveBack,
    IGS_MoveBack,
    IGS_Investigate,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZGetHelpGroup_EInvestigateGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZGetHelpGroup_EInvestigateGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_Acknowledge => 0i32,
            Self::IGS_WaitForAckDialog => 1i32,
            Self::IGS_RunToGuard => 2i32,
            Self::IGS_ReportToHitman => 3i32,
            Self::IGS_ReportToGuard => 4i32,
            Self::IGS_StartMoveBack => 5i32,
            Self::IGS_MoveBack => 6i32,
            Self::IGS_Investigate => 7i32,
            Self::IGS_Completed => 8i32,
            Self::IGS_Max => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZGetHelpGroup_EInvestigateGroupState {
     const TYPE_ID: &str = "ZGetHelpGroup_EInvestigateGroupState";
}

impl StaticVariant for Vec<ZGetHelpGroup_EInvestigateGroupState> {
     const TYPE_ID: &str = "TArray<ZGetHelpGroup_EInvestigateGroupState>";
}

impl StaticVariant for Vec<Vec<ZGetHelpGroup_EInvestigateGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZGetHelpGroup_EInvestigateGroupState>>";
}

impl Variant for ZGetHelpGroup_EInvestigateGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZGetHelpGroup_EInvestigateGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZGetHelpGroup_EInvestigateGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZGetHelpGroup_EInvestigateGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZGetHelpGroup_EInvestigateGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZGetHelpGroup_EInvestigateGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5AgilityEventConsumer_EEvent {
    EAE_LEFTHAND,
    EAE_RIGHTHAND,
    EAE_LEFTLEG,
    EAE_RIGHTLEG,
}

impl Aligned for ZHM5AgilityEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5AgilityEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EAE_LEFTHAND => 0i32,
            Self::EAE_RIGHTHAND => 1i32,
            Self::EAE_LEFTLEG => 2i32,
            Self::EAE_RIGHTLEG => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5AgilityEventConsumer_EEvent {
     const TYPE_ID: &str = "ZHM5AgilityEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZHM5AgilityEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZHM5AgilityEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5AgilityEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5AgilityEventConsumer_EEvent>>";
}

impl Variant for ZHM5AgilityEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5AgilityEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5AgilityEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5AgilityEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5AgilityEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5AgilityEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5Animator_EBoneAnimator {
    BA_ANIMATION,
    BA_RAGDOLL,
    BA_BLENDING,
    BA_POWEREDRAGDOLL,
    BA_POSE,
}

impl Aligned for ZHM5Animator_EBoneAnimator {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5Animator_EBoneAnimator {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BA_ANIMATION => 0i32,
            Self::BA_RAGDOLL => 1i32,
            Self::BA_BLENDING => 2i32,
            Self::BA_POWEREDRAGDOLL => 3i32,
            Self::BA_POSE => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5Animator_EBoneAnimator {
     const TYPE_ID: &str = "ZHM5Animator_EBoneAnimator";
}

impl StaticVariant for Vec<ZHM5Animator_EBoneAnimator> {
     const TYPE_ID: &str = "TArray<ZHM5Animator_EBoneAnimator>";
}

impl StaticVariant for Vec<Vec<ZHM5Animator_EBoneAnimator>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5Animator_EBoneAnimator>>";
}

impl Variant for ZHM5Animator_EBoneAnimator {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5Animator_EBoneAnimator")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5Animator_EBoneAnimator".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5Animator_EBoneAnimator>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5Animator_EBoneAnimator>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5Animator_EBoneAnimator>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5BodyContainer_EBCAnimSet {
    BC_CONTAINER_STANDARD,
    BC_CONTAINER_WOODCHIPPER,
    BC_CAR_STANDARD_TRUNK,
    BC_CONTAINER_CLOSET,
    BC_CONTAINER_LAUNDRYCHUTE,
}

impl Aligned for ZHM5BodyContainer_EBCAnimSet {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5BodyContainer_EBCAnimSet {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BC_CONTAINER_STANDARD => 0i32,
            Self::BC_CONTAINER_WOODCHIPPER => 1i32,
            Self::BC_CAR_STANDARD_TRUNK => 2i32,
            Self::BC_CONTAINER_CLOSET => 3i32,
            Self::BC_CONTAINER_LAUNDRYCHUTE => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5BodyContainer_EBCAnimSet {
     const TYPE_ID: &str = "ZHM5BodyContainer_EBCAnimSet";
}

impl StaticVariant for Vec<ZHM5BodyContainer_EBCAnimSet> {
     const TYPE_ID: &str = "TArray<ZHM5BodyContainer_EBCAnimSet>";
}

impl StaticVariant for Vec<Vec<ZHM5BodyContainer_EBCAnimSet>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5BodyContainer_EBCAnimSet>>";
}

impl Variant for ZHM5BodyContainer_EBCAnimSet {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5BodyContainer_EBCAnimSet")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5BodyContainer_EBCAnimSet".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5BodyContainer_EBCAnimSet>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5BodyContainer_EBCAnimSet>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5BodyContainer_EBCAnimSet>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5BodyContainer_EBCBodyMode {
    BC_1_VICTIM,
    BC_2_VICTIMS,
    BC_1_VICTIM_FLUSHABLE,
    BC_1_VICTIM_AUTOFLUSHABLE,
}

impl Aligned for ZHM5BodyContainer_EBCBodyMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5BodyContainer_EBCBodyMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BC_1_VICTIM => 0i32,
            Self::BC_2_VICTIMS => 1i32,
            Self::BC_1_VICTIM_FLUSHABLE => 2i32,
            Self::BC_1_VICTIM_AUTOFLUSHABLE => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5BodyContainer_EBCBodyMode {
     const TYPE_ID: &str = "ZHM5BodyContainer_EBCBodyMode";
}

impl StaticVariant for Vec<ZHM5BodyContainer_EBCBodyMode> {
     const TYPE_ID: &str = "TArray<ZHM5BodyContainer_EBCBodyMode>";
}

impl StaticVariant for Vec<Vec<ZHM5BodyContainer_EBCBodyMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5BodyContainer_EBCBodyMode>>";
}

impl Variant for ZHM5BodyContainer_EBCBodyMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5BodyContainer_EBCBodyMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5BodyContainer_EBCBodyMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5BodyContainer_EBCBodyMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5BodyContainer_EBCBodyMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5BodyContainer_EBCBodyMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5BodyContainer_eBCCloseMode {
    BC_AUTOCLOSE,
    BC_MANUALCLOSE,
}

impl Aligned for ZHM5BodyContainer_eBCCloseMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5BodyContainer_eBCCloseMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BC_AUTOCLOSE => 0i32,
            Self::BC_MANUALCLOSE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5BodyContainer_eBCCloseMode {
     const TYPE_ID: &str = "ZHM5BodyContainer_eBCCloseMode";
}

impl StaticVariant for Vec<ZHM5BodyContainer_eBCCloseMode> {
     const TYPE_ID: &str = "TArray<ZHM5BodyContainer_eBCCloseMode>";
}

impl StaticVariant for Vec<Vec<ZHM5BodyContainer_eBCCloseMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5BodyContainer_eBCCloseMode>>";
}

impl Variant for ZHM5BodyContainer_eBCCloseMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5BodyContainer_eBCCloseMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5BodyContainer_eBCCloseMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5BodyContainer_eBCCloseMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5BodyContainer_eBCCloseMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5BodyContainer_eBCCloseMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5BodySoundEventConsumer_EAnimSoundBody {
    eHM5AnimSoundBody_Buttocks,
    eHM5AnimSoundBody_Back,
    eHM5AnimSoundBody_Head,
    eHM5AnimSoundBody_Knee_L,
    eHM5AnimSoundBody_Knee_R,
    eHM5AnimSoundBody_Elbow_L,
    eHM5AnimSoundBody_Elbow_R,
    eHM5AnimSoundBody_Hand_L,
    eHM5AnimSoundBody_Hand_R,
    eHM5AnimSoundBody_Foot_L,
    eHM5AnimSoundBody_Foot_R,
    eHM5AnimSoundBody_Shoulder_L,
    eHM5AnimSoundBody_Shoulder_R,
    eHM5AnimSoundBody_RollFwd,
    eHM5AnimSoundBody_RollSide,
}

impl Aligned for ZHM5BodySoundEventConsumer_EAnimSoundBody {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5BodySoundEventConsumer_EAnimSoundBody {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHM5AnimSoundBody_Buttocks => 0i32,
            Self::eHM5AnimSoundBody_Back => 1i32,
            Self::eHM5AnimSoundBody_Head => 2i32,
            Self::eHM5AnimSoundBody_Knee_L => 3i32,
            Self::eHM5AnimSoundBody_Knee_R => 4i32,
            Self::eHM5AnimSoundBody_Elbow_L => 5i32,
            Self::eHM5AnimSoundBody_Elbow_R => 6i32,
            Self::eHM5AnimSoundBody_Hand_L => 7i32,
            Self::eHM5AnimSoundBody_Hand_R => 8i32,
            Self::eHM5AnimSoundBody_Foot_L => 9i32,
            Self::eHM5AnimSoundBody_Foot_R => 10i32,
            Self::eHM5AnimSoundBody_Shoulder_L => 11i32,
            Self::eHM5AnimSoundBody_Shoulder_R => 12i32,
            Self::eHM5AnimSoundBody_RollFwd => 13i32,
            Self::eHM5AnimSoundBody_RollSide => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5BodySoundEventConsumer_EAnimSoundBody {
     const TYPE_ID: &str = "ZHM5BodySoundEventConsumer_EAnimSoundBody";
}

impl StaticVariant for Vec<ZHM5BodySoundEventConsumer_EAnimSoundBody> {
     const TYPE_ID: &str = "TArray<ZHM5BodySoundEventConsumer_EAnimSoundBody>";
}

impl StaticVariant for Vec<Vec<ZHM5BodySoundEventConsumer_EAnimSoundBody>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5BodySoundEventConsumer_EAnimSoundBody>>";
}

impl Variant for ZHM5BodySoundEventConsumer_EAnimSoundBody {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5BodySoundEventConsumer_EAnimSoundBody")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5BodySoundEventConsumer_EAnimSoundBody".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5BodySoundEventConsumer_EAnimSoundBody>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5BodySoundEventConsumer_EAnimSoundBody>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5BodySoundEventConsumer_EAnimSoundBody>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5ContextActionEntity_EInteraction {
    eIT_RotateLeftStick,
    eIT_AutoComplete,
    eIT_NoInteraction,
}

impl Aligned for ZHM5ContextActionEntity_EInteraction {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5ContextActionEntity_EInteraction {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eIT_RotateLeftStick => 0i32,
            Self::eIT_AutoComplete => 1i32,
            Self::eIT_NoInteraction => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5ContextActionEntity_EInteraction {
     const TYPE_ID: &str = "ZHM5ContextActionEntity_EInteraction";
}

impl StaticVariant for Vec<ZHM5ContextActionEntity_EInteraction> {
     const TYPE_ID: &str = "TArray<ZHM5ContextActionEntity_EInteraction>";
}

impl StaticVariant for Vec<Vec<ZHM5ContextActionEntity_EInteraction>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5ContextActionEntity_EInteraction>>";
}

impl Variant for ZHM5ContextActionEntity_EInteraction {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5ContextActionEntity_EInteraction")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5ContextActionEntity_EInteraction".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5ContextActionEntity_EInteraction>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5ContextActionEntity_EInteraction>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5ContextActionEntity_EInteraction>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5CrowdGenericEventConsumer_EEvent {
    eFootstep,
    eClothRustle,
    ePushReaction,
    ePanic,
    eGeneric00,
    eGeneric01,
    eGeneric02,
    eGeneric03,
}

impl Aligned for ZHM5CrowdGenericEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5CrowdGenericEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFootstep => 0i32,
            Self::eClothRustle => 1i32,
            Self::ePushReaction => 2i32,
            Self::ePanic => 3i32,
            Self::eGeneric00 => 4i32,
            Self::eGeneric01 => 5i32,
            Self::eGeneric02 => 6i32,
            Self::eGeneric03 => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5CrowdGenericEventConsumer_EEvent {
     const TYPE_ID: &str = "ZHM5CrowdGenericEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZHM5CrowdGenericEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZHM5CrowdGenericEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5CrowdGenericEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5CrowdGenericEventConsumer_EEvent>>";
}

impl Variant for ZHM5CrowdGenericEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5CrowdGenericEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5CrowdGenericEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5CrowdGenericEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5CrowdGenericEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5CrowdGenericEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5DynamicRayCastEntity_ECollideType {
    eAll,
    eStaticOnly,
    eDynamicOnly,
    eBaseCharacter,
    eHitman,
    eActor,
}

impl Aligned for ZHM5DynamicRayCastEntity_ECollideType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5DynamicRayCastEntity_ECollideType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAll => 0i32,
            Self::eStaticOnly => 1i32,
            Self::eDynamicOnly => 2i32,
            Self::eBaseCharacter => 3i32,
            Self::eHitman => 4i32,
            Self::eActor => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5DynamicRayCastEntity_ECollideType {
     const TYPE_ID: &str = "ZHM5DynamicRayCastEntity_ECollideType";
}

impl StaticVariant for Vec<ZHM5DynamicRayCastEntity_ECollideType> {
     const TYPE_ID: &str = "TArray<ZHM5DynamicRayCastEntity_ECollideType>";
}

impl StaticVariant for Vec<Vec<ZHM5DynamicRayCastEntity_ECollideType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5DynamicRayCastEntity_ECollideType>>";
}

impl Variant for ZHM5DynamicRayCastEntity_ECollideType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5DynamicRayCastEntity_ECollideType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5DynamicRayCastEntity_ECollideType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5DynamicRayCastEntity_ECollideType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5DynamicRayCastEntity_ECollideType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5DynamicRayCastEntity_ECollideType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5FaceFXReactionEventConsumer_EEvent {
    eHitByBullet,
    eFireRegularWeapon,
    eReloadRegularWeapon,
    eFireHeavyWeapon,
    eReloadHeavyWeapon,
    eCCAttacking,
    eCCGettingHit,
    eCoverDodgebulletLeft,
    eCoverDodgebulletRight,
    eReactToExplosion,
}

impl Aligned for ZHM5FaceFXReactionEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5FaceFXReactionEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHitByBullet => 0i32,
            Self::eFireRegularWeapon => 1i32,
            Self::eReloadRegularWeapon => 2i32,
            Self::eFireHeavyWeapon => 3i32,
            Self::eReloadHeavyWeapon => 4i32,
            Self::eCCAttacking => 5i32,
            Self::eCCGettingHit => 6i32,
            Self::eCoverDodgebulletLeft => 7i32,
            Self::eCoverDodgebulletRight => 8i32,
            Self::eReactToExplosion => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5FaceFXReactionEventConsumer_EEvent {
     const TYPE_ID: &str = "ZHM5FaceFXReactionEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZHM5FaceFXReactionEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZHM5FaceFXReactionEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5FaceFXReactionEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5FaceFXReactionEventConsumer_EEvent>>";
}

impl Variant for ZHM5FaceFXReactionEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5FaceFXReactionEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5FaceFXReactionEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5FaceFXReactionEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5FaceFXReactionEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5FaceFXReactionEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5FaceFXSpecificEventConsumer_EEvent {
    eNone,
    eGetInCombatCoverExhalation,
    eLeaveCombatCoverExhalation,
    eAgilityStrainedInhaleExhale,
    eAgilityGroan,
    eCloseCombatAttackSnarl,
    eCloseCombatStainedGroan,
    eCloseCombatSilentKillShush,
}

impl Aligned for ZHM5FaceFXSpecificEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5FaceFXSpecificEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNone => 0i32,
            Self::eGetInCombatCoverExhalation => 1i32,
            Self::eLeaveCombatCoverExhalation => 2i32,
            Self::eAgilityStrainedInhaleExhale => 3i32,
            Self::eAgilityGroan => 4i32,
            Self::eCloseCombatAttackSnarl => 5i32,
            Self::eCloseCombatStainedGroan => 6i32,
            Self::eCloseCombatSilentKillShush => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5FaceFXSpecificEventConsumer_EEvent {
     const TYPE_ID: &str = "ZHM5FaceFXSpecificEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZHM5FaceFXSpecificEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZHM5FaceFXSpecificEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5FaceFXSpecificEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5FaceFXSpecificEventConsumer_EEvent>>";
}

impl Variant for ZHM5FaceFXSpecificEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5FaceFXSpecificEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5FaceFXSpecificEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5FaceFXSpecificEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5FaceFXSpecificEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5FaceFXSpecificEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5ForceCover_EFaceDirection {
    eFaceLeft,
    eFaceRight,
}

impl Aligned for ZHM5ForceCover_EFaceDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5ForceCover_EFaceDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFaceLeft => 0i32,
            Self::eFaceRight => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5ForceCover_EFaceDirection {
     const TYPE_ID: &str = "ZHM5ForceCover_EFaceDirection";
}

impl StaticVariant for Vec<ZHM5ForceCover_EFaceDirection> {
     const TYPE_ID: &str = "TArray<ZHM5ForceCover_EFaceDirection>";
}

impl StaticVariant for Vec<Vec<ZHM5ForceCover_EFaceDirection>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5ForceCover_EFaceDirection>>";
}

impl Variant for ZHM5ForceCover_EFaceDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5ForceCover_EFaceDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5ForceCover_EFaceDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5ForceCover_EFaceDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5ForceCover_EFaceDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5ForceCover_EFaceDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5GameTimeMultiplierEntity_eTMLDReason {
    eTMLDR_HintMessages,
    eTMLDR_Sequence,
    eTMLDR_ActionKillHeadShot,
    eTMLDR_ActionKillCCProp,
    eTMLDR_ActionKillExplosion,
    eTMLDR_ActionKillLastEnemyInEncounter,
    eTMLDR_ActionKillLastEnemyInCheckPoint,
    eTMLDR_NOTSET,
}

impl Aligned for ZHM5GameTimeMultiplierEntity_eTMLDReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5GameTimeMultiplierEntity_eTMLDReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTMLDR_HintMessages => 0i32,
            Self::eTMLDR_Sequence => 1i32,
            Self::eTMLDR_ActionKillHeadShot => 2i32,
            Self::eTMLDR_ActionKillCCProp => 3i32,
            Self::eTMLDR_ActionKillExplosion => 4i32,
            Self::eTMLDR_ActionKillLastEnemyInEncounter => 5i32,
            Self::eTMLDR_ActionKillLastEnemyInCheckPoint => 6i32,
            Self::eTMLDR_NOTSET => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5GameTimeMultiplierEntity_eTMLDReason {
     const TYPE_ID: &str = "ZHM5GameTimeMultiplierEntity_eTMLDReason";
}

impl StaticVariant for Vec<ZHM5GameTimeMultiplierEntity_eTMLDReason> {
     const TYPE_ID: &str = "TArray<ZHM5GameTimeMultiplierEntity_eTMLDReason>";
}

impl StaticVariant for Vec<Vec<ZHM5GameTimeMultiplierEntity_eTMLDReason>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5GameTimeMultiplierEntity_eTMLDReason>>";
}

impl Variant for ZHM5GameTimeMultiplierEntity_eTMLDReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5GameTimeMultiplierEntity_eTMLDReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5GameTimeMultiplierEntity_eTMLDReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5GameTimeMultiplierEntity_eTMLDReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5GameTimeMultiplierEntity_eTMLDReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5GameTimeMultiplierEntity_eTMLDReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5GenericEventConsumer_EEvent {
    eGeneric00,
    eGeneric01,
    eGeneric02,
    eGeneric03,
    eGeneric04,
    eGeneric05,
    eGeneric06,
    eGeneric07,
}

impl Aligned for ZHM5GenericEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5GenericEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eGeneric00 => 0i32,
            Self::eGeneric01 => 1i32,
            Self::eGeneric02 => 2i32,
            Self::eGeneric03 => 3i32,
            Self::eGeneric04 => 4i32,
            Self::eGeneric05 => 5i32,
            Self::eGeneric06 => 6i32,
            Self::eGeneric07 => 7i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5GenericEventConsumer_EEvent {
     const TYPE_ID: &str = "ZHM5GenericEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZHM5GenericEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZHM5GenericEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5GenericEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5GenericEventConsumer_EEvent>>";
}

impl Variant for ZHM5GenericEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5GenericEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5GenericEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5GenericEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5GenericEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5GenericEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5HIKEventConsumer_EBlend {
    eBlendIn,
    eBlendOut,
    eInstantOn,
    eInstantOff,
}

impl Aligned for ZHM5HIKEventConsumer_EBlend {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5HIKEventConsumer_EBlend {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eBlendIn => 0i32,
            Self::eBlendOut => 1i32,
            Self::eInstantOn => 2i32,
            Self::eInstantOff => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5HIKEventConsumer_EBlend {
     const TYPE_ID: &str = "ZHM5HIKEventConsumer_EBlend";
}

impl StaticVariant for Vec<ZHM5HIKEventConsumer_EBlend> {
     const TYPE_ID: &str = "TArray<ZHM5HIKEventConsumer_EBlend>";
}

impl StaticVariant for Vec<Vec<ZHM5HIKEventConsumer_EBlend>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5HIKEventConsumer_EBlend>>";
}

impl Variant for ZHM5HIKEventConsumer_EBlend {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5HIKEventConsumer_EBlend")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5HIKEventConsumer_EBlend".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5HIKEventConsumer_EBlend>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5HIKEventConsumer_EBlend>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5HIKEventConsumer_EBlend>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5HIKEventConsumer_EEffector {
    eLeftHand,
    eRightHand,
}

impl Aligned for ZHM5HIKEventConsumer_EEffector {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5HIKEventConsumer_EEffector {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLeftHand => 0i32,
            Self::eRightHand => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5HIKEventConsumer_EEffector {
     const TYPE_ID: &str = "ZHM5HIKEventConsumer_EEffector";
}

impl StaticVariant for Vec<ZHM5HIKEventConsumer_EEffector> {
     const TYPE_ID: &str = "TArray<ZHM5HIKEventConsumer_EEffector>";
}

impl StaticVariant for Vec<Vec<ZHM5HIKEventConsumer_EEffector>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5HIKEventConsumer_EEffector>>";
}

impl Variant for ZHM5HIKEventConsumer_EEffector {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5HIKEventConsumer_EEffector")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5HIKEventConsumer_EEffector".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5HIKEventConsumer_EEffector>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5HIKEventConsumer_EEffector>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5HIKEventConsumer_EEffector>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5HitmanHealthModifier_EHealthDrainType {
    eRemoveHealthInstantly,
    eDecreaseHealthToValue,
}

impl Aligned for ZHM5HitmanHealthModifier_EHealthDrainType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5HitmanHealthModifier_EHealthDrainType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eRemoveHealthInstantly => 0i32,
            Self::eDecreaseHealthToValue => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5HitmanHealthModifier_EHealthDrainType {
     const TYPE_ID: &str = "ZHM5HitmanHealthModifier_EHealthDrainType";
}

impl StaticVariant for Vec<ZHM5HitmanHealthModifier_EHealthDrainType> {
     const TYPE_ID: &str = "TArray<ZHM5HitmanHealthModifier_EHealthDrainType>";
}

impl StaticVariant for Vec<Vec<ZHM5HitmanHealthModifier_EHealthDrainType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5HitmanHealthModifier_EHealthDrainType>>";
}

impl Variant for ZHM5HitmanHealthModifier_EHealthDrainType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5HitmanHealthModifier_EHealthDrainType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5HitmanHealthModifier_EHealthDrainType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5HitmanHealthModifier_EHealthDrainType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5HitmanHealthModifier_EHealthDrainType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5HitmanHealthModifier_EHealthDrainType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5HitmanHealthModifier_EHealthValue {
    eHealth0,
    eHealth10,
    eHealth20,
    eHealth30,
    eHealth40,
    eHealth50,
    eHealth60,
    eHealth70,
    eHealth80,
    eHealth90,
    eHealth100,
}

impl Aligned for ZHM5HitmanHealthModifier_EHealthValue {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5HitmanHealthModifier_EHealthValue {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHealth0 => 0i32,
            Self::eHealth10 => 10i32,
            Self::eHealth20 => 20i32,
            Self::eHealth30 => 30i32,
            Self::eHealth40 => 40i32,
            Self::eHealth50 => 50i32,
            Self::eHealth60 => 60i32,
            Self::eHealth70 => 70i32,
            Self::eHealth80 => 80i32,
            Self::eHealth90 => 90i32,
            Self::eHealth100 => 100i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5HitmanHealthModifier_EHealthValue {
     const TYPE_ID: &str = "ZHM5HitmanHealthModifier_EHealthValue";
}

impl StaticVariant for Vec<ZHM5HitmanHealthModifier_EHealthValue> {
     const TYPE_ID: &str = "TArray<ZHM5HitmanHealthModifier_EHealthValue>";
}

impl StaticVariant for Vec<Vec<ZHM5HitmanHealthModifier_EHealthValue>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5HitmanHealthModifier_EHealthValue>>";
}

impl Variant for ZHM5HitmanHealthModifier_EHealthValue {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5HitmanHealthModifier_EHealthValue")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5HitmanHealthModifier_EHealthValue".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5HitmanHealthModifier_EHealthValue>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5HitmanHealthModifier_EHealthValue>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5HitmanHealthModifier_EHealthValue>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5IndicatorManager_EIndicatorType {
    eActorAmbient,
    eActorAlertedLow,
    eActorAlertedHigh,
    eActorArrest,
    eActorCombat,
    eExplosion,
    eObjective,
    ePointOfInterest,
    eContractExit,
    eEasterActor,
}

impl Aligned for ZHM5IndicatorManager_EIndicatorType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5IndicatorManager_EIndicatorType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActorAmbient => 0i32,
            Self::eActorAlertedLow => 1i32,
            Self::eActorAlertedHigh => 2i32,
            Self::eActorArrest => 3i32,
            Self::eActorCombat => 4i32,
            Self::eExplosion => 5i32,
            Self::eObjective => 6i32,
            Self::ePointOfInterest => 7i32,
            Self::eContractExit => 8i32,
            Self::eEasterActor => 9i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5IndicatorManager_EIndicatorType {
     const TYPE_ID: &str = "ZHM5IndicatorManager_EIndicatorType";
}

impl StaticVariant for Vec<ZHM5IndicatorManager_EIndicatorType> {
     const TYPE_ID: &str = "TArray<ZHM5IndicatorManager_EIndicatorType>";
}

impl StaticVariant for Vec<Vec<ZHM5IndicatorManager_EIndicatorType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5IndicatorManager_EIndicatorType>>";
}

impl Variant for ZHM5IndicatorManager_EIndicatorType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5IndicatorManager_EIndicatorType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5IndicatorManager_EIndicatorType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5IndicatorManager_EIndicatorType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5IndicatorManager_EIndicatorType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5IndicatorManager_EIndicatorType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5Item_EKeywordEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZHM5Item_EKeywordEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5Item_EKeywordEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5Item_EKeywordEvaluationType {
     const TYPE_ID: &str = "ZHM5Item_EKeywordEvaluationType";
}

impl StaticVariant for Vec<ZHM5Item_EKeywordEvaluationType> {
     const TYPE_ID: &str = "TArray<ZHM5Item_EKeywordEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZHM5Item_EKeywordEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5Item_EKeywordEvaluationType>>";
}

impl Variant for ZHM5Item_EKeywordEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5Item_EKeywordEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5Item_EKeywordEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5Item_EKeywordEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5Item_EKeywordEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5Item_EKeywordEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5Item_EUseTypes {
    EUT_CantUse,
    EUT_Toggle,
    EUT_TurnOn,
}

impl Aligned for ZHM5Item_EUseTypes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5Item_EUseTypes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EUT_CantUse => 0i32,
            Self::EUT_Toggle => 1i32,
            Self::EUT_TurnOn => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5Item_EUseTypes {
     const TYPE_ID: &str = "ZHM5Item_EUseTypes";
}

impl StaticVariant for Vec<ZHM5Item_EUseTypes> {
     const TYPE_ID: &str = "TArray<ZHM5Item_EUseTypes>";
}

impl StaticVariant for Vec<Vec<ZHM5Item_EUseTypes>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5Item_EUseTypes>>";
}

impl Variant for ZHM5Item_EUseTypes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5Item_EUseTypes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5Item_EUseTypes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5Item_EUseTypes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5Item_EUseTypes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5Item_EUseTypes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent {
    EIIE_ItemImpactBack,
    EIIE_ItemImpactFront,
    EIIE_ImpactLow,
    EIIE_ItemPullOut,
    EIIE_ItemOnDeadlyThrow,
    EIIE_ItemSlitThroat,
    EIIE_ItemSoundGeneric01,
    EIIE_ItemSoundGeneric02,
    EIIE_ItemSoundGeneric03,
}

impl Aligned for ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EIIE_ItemImpactBack => 0i32,
            Self::EIIE_ItemImpactFront => 1i32,
            Self::EIIE_ImpactLow => 2i32,
            Self::EIIE_ItemPullOut => 3i32,
            Self::EIIE_ItemOnDeadlyThrow => 4i32,
            Self::EIIE_ItemSlitThroat => 5i32,
            Self::EIIE_ItemSoundGeneric01 => 6i32,
            Self::EIIE_ItemSoundGeneric02 => 7i32,
            Self::EIIE_ItemSoundGeneric03 => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent {
     const TYPE_ID: &str = "ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent";
}

impl StaticVariant for Vec<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent> {
     const TYPE_ID: &str = "TArray<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>";
}

impl StaticVariant for Vec<Vec<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>>";
}

impl Variant for ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5ItemInteractionEventConsumer_EHM5SoundItemInteractionEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5LedgeMount_EFaceDirection {
    eFaceFront,
    eFaceLeft,
    eFaceRight,
}

impl Aligned for ZHM5LedgeMount_EFaceDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5LedgeMount_EFaceDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFaceFront => 0i32,
            Self::eFaceLeft => 1i32,
            Self::eFaceRight => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5LedgeMount_EFaceDirection {
     const TYPE_ID: &str = "ZHM5LedgeMount_EFaceDirection";
}

impl StaticVariant for Vec<ZHM5LedgeMount_EFaceDirection> {
     const TYPE_ID: &str = "TArray<ZHM5LedgeMount_EFaceDirection>";
}

impl StaticVariant for Vec<Vec<ZHM5LedgeMount_EFaceDirection>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5LedgeMount_EFaceDirection>>";
}

impl Variant for ZHM5LedgeMount_EFaceDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5LedgeMount_EFaceDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5LedgeMount_EFaceDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5LedgeMount_EFaceDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5LedgeMount_EFaceDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5LedgeMount_EFaceDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5LedgeMount_ELedgeEndState {
    eHang,
    eStand,
}

impl Aligned for ZHM5LedgeMount_ELedgeEndState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5LedgeMount_ELedgeEndState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHang => 0i32,
            Self::eStand => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5LedgeMount_ELedgeEndState {
     const TYPE_ID: &str = "ZHM5LedgeMount_ELedgeEndState";
}

impl StaticVariant for Vec<ZHM5LedgeMount_ELedgeEndState> {
     const TYPE_ID: &str = "TArray<ZHM5LedgeMount_ELedgeEndState>";
}

impl StaticVariant for Vec<Vec<ZHM5LedgeMount_ELedgeEndState>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5LedgeMount_ELedgeEndState>>";
}

impl Variant for ZHM5LedgeMount_ELedgeEndState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5LedgeMount_ELedgeEndState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5LedgeMount_ELedgeEndState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5LedgeMount_ELedgeEndState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5LedgeMount_ELedgeEndState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5LedgeMount_ELedgeEndState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5ValueEntity_bool_EForwardRule {
    eAlways,
    eValueChanged,
}

impl Aligned for ZHM5ValueEntity_bool_EForwardRule {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5ValueEntity_bool_EForwardRule {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAlways => 0i32,
            Self::eValueChanged => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5ValueEntity_bool_EForwardRule {
     const TYPE_ID: &str = "ZHM5ValueEntity_bool_EForwardRule";
}

impl StaticVariant for Vec<ZHM5ValueEntity_bool_EForwardRule> {
     const TYPE_ID: &str = "TArray<ZHM5ValueEntity_bool_EForwardRule>";
}

impl StaticVariant for Vec<Vec<ZHM5ValueEntity_bool_EForwardRule>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5ValueEntity_bool_EForwardRule>>";
}

impl Variant for ZHM5ValueEntity_bool_EForwardRule {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5ValueEntity_bool_EForwardRule")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5ValueEntity_bool_EForwardRule".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5ValueEntity_bool_EForwardRule>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5ValueEntity_bool_EForwardRule>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5ValueEntity_bool_EForwardRule>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass {
    eWBC_AudioClass_AssaultRifle,
    eWBC_AudioClass_Pistol,
    eWBC_AudioClass_Shotgun,
    eWBC_AudioClass_SMG,
    eWBC_AudioClass_SniperRifle,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioClass_AssaultRifle => 0i32,
            Self::eWBC_AudioClass_Pistol => 1i32,
            Self::eWBC_AudioClass_Shotgun => 2i32,
            Self::eWBC_AudioClass_SMG => 3i32,
            Self::eWBC_AudioClass_SniperRifle => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioClass>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType {
    eWBC_AudioExoticType_MiniPistol,
    eWBC_AudioExoticType_OneHandSpinReloadShotgun,
    eWBC_AudioExoticType_TranquilizerDartPistol,
    eWBC_AudioExoticType_Walter2000SniperRifle,
    eWBC_AudioExoticType_ShootingRange_NPCAssaultRifle,
    eWBC_AudioExoticType_None,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioExoticType_MiniPistol => 0i32,
            Self::eWBC_AudioExoticType_OneHandSpinReloadShotgun => 1i32,
            Self::eWBC_AudioExoticType_TranquilizerDartPistol => 2i32,
            Self::eWBC_AudioExoticType_Walter2000SniperRifle => 3i32,
            Self::eWBC_AudioExoticType_ShootingRange_NPCAssaultRifle => 4i32,
            Self::eWBC_AudioExoticType_None => 32768i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioExoticType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily {
    eWBC_AudioFamily_Exotics,
    eWBC_AudioFamily_Heavy,
    eWBC_AudioFamily_Light,
    eWBC_AudioFamily_NPC,
    eWBC_AudioFamily_Standard,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioFamily_Exotics => 0i32,
            Self::eWBC_AudioFamily_Heavy => 1i32,
            Self::eWBC_AudioFamily_Light => 2i32,
            Self::eWBC_AudioFamily_NPC => 3i32,
            Self::eWBC_AudioFamily_Standard => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFamily>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType {
    eWBC_AudioFireType_Full_Automatic,
    eWBC_AudioFireType_Single,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioFireType_Full_Automatic => 0i32,
            Self::eWBC_AudioFireType_Single => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioFireType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType {
    eWBC_AudioHeadTailType_DryFire,
    eWBC_AudioHeadTailType_Normal,
    eWBC_AudioHeadTailType_NormalSweetener,
    eWBC_AudioHeadTailType_Silenced,
    eWBC_AudioHeadTailType_SilencedSweetener,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioHeadTailType_DryFire => 0i32,
            Self::eWBC_AudioHeadTailType_Normal => 1i32,
            Self::eWBC_AudioHeadTailType_NormalSweetener => 2i32,
            Self::eWBC_AudioHeadTailType_Silenced => 3i32,
            Self::eWBC_AudioHeadTailType_SilencedSweetener => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioHeadTailType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType {
    eWBC_AudioImpactType_Normal,
    eWBC_AudioImpactType_Sweetener,
}

impl Aligned for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eWBC_AudioImpactType_Normal => 0i32,
            Self::eWBC_AudioImpactType_Sweetener => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType {
     const TYPE_ID: &str = "ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType";
}

impl StaticVariant for Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>>";
}

impl Variant for ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponBasicConfigEntity_EWeaponBasicConfigAudioImpactType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHM5WeaponEventConsumer_EAnimWeapon {
    eHM5Weapon_HideClip,
    eHM5Weapon_ShowClip,
    eHM5Weapon_SpawnPhysicsClip,
    eHM5Weapon_EjectCartridge,
}

impl Aligned for ZHM5WeaponEventConsumer_EAnimWeapon {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHM5WeaponEventConsumer_EAnimWeapon {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHM5Weapon_HideClip => 0i32,
            Self::eHM5Weapon_ShowClip => 1i32,
            Self::eHM5Weapon_SpawnPhysicsClip => 2i32,
            Self::eHM5Weapon_EjectCartridge => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHM5WeaponEventConsumer_EAnimWeapon {
     const TYPE_ID: &str = "ZHM5WeaponEventConsumer_EAnimWeapon";
}

impl StaticVariant for Vec<ZHM5WeaponEventConsumer_EAnimWeapon> {
     const TYPE_ID: &str = "TArray<ZHM5WeaponEventConsumer_EAnimWeapon>";
}

impl StaticVariant for Vec<Vec<ZHM5WeaponEventConsumer_EAnimWeapon>> {
     const TYPE_ID: &str = "TArray<TArray<ZHM5WeaponEventConsumer_EAnimWeapon>>";
}

impl Variant for ZHM5WeaponEventConsumer_EAnimWeapon {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHM5WeaponEventConsumer_EAnimWeapon")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHM5WeaponEventConsumer_EAnimWeapon".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHM5WeaponEventConsumer_EAnimWeapon>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHM5WeaponEventConsumer_EAnimWeapon>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHM5WeaponEventConsumer_EAnimWeapon>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDCamera3DControllerEntity_EMode {
    Auto,
    Mode2D,
    Mode3D,
}

impl Aligned for ZHUDCamera3DControllerEntity_EMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDCamera3DControllerEntity_EMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Auto => 0i32,
            Self::Mode2D => 1i32,
            Self::Mode3D => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDCamera3DControllerEntity_EMode {
     const TYPE_ID: &str = "ZHUDCamera3DControllerEntity_EMode";
}

impl StaticVariant for Vec<ZHUDCamera3DControllerEntity_EMode> {
     const TYPE_ID: &str = "TArray<ZHUDCamera3DControllerEntity_EMode>";
}

impl StaticVariant for Vec<Vec<ZHUDCamera3DControllerEntity_EMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDCamera3DControllerEntity_EMode>>";
}

impl Variant for ZHUDCamera3DControllerEntity_EMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDCamera3DControllerEntity_EMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDCamera3DControllerEntity_EMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDCamera3DControllerEntity_EMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDCamera3DControllerEntity_EMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDCamera3DControllerEntity_EMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDCamera3DControllerEntity_ESpace {
    View,
    Camera,
    Player,
    World,
}

impl Aligned for ZHUDCamera3DControllerEntity_ESpace {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDCamera3DControllerEntity_ESpace {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::View => 0i32,
            Self::Camera => 1i32,
            Self::Player => 2i32,
            Self::World => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDCamera3DControllerEntity_ESpace {
     const TYPE_ID: &str = "ZHUDCamera3DControllerEntity_ESpace";
}

impl StaticVariant for Vec<ZHUDCamera3DControllerEntity_ESpace> {
     const TYPE_ID: &str = "TArray<ZHUDCamera3DControllerEntity_ESpace>";
}

impl StaticVariant for Vec<Vec<ZHUDCamera3DControllerEntity_ESpace>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDCamera3DControllerEntity_ESpace>>";
}

impl Variant for ZHUDCamera3DControllerEntity_ESpace {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDCamera3DControllerEntity_ESpace")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDCamera3DControllerEntity_ESpace".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDCamera3DControllerEntity_ESpace>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDCamera3DControllerEntity_ESpace>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDCamera3DControllerEntity_ESpace>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDCamera3DControllerEntity_EType {
    Menu,
    HUD,
}

impl Aligned for ZHUDCamera3DControllerEntity_EType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDCamera3DControllerEntity_EType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Menu => 0i32,
            Self::HUD => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDCamera3DControllerEntity_EType {
     const TYPE_ID: &str = "ZHUDCamera3DControllerEntity_EType";
}

impl StaticVariant for Vec<ZHUDCamera3DControllerEntity_EType> {
     const TYPE_ID: &str = "TArray<ZHUDCamera3DControllerEntity_EType>";
}

impl StaticVariant for Vec<Vec<ZHUDCamera3DControllerEntity_EType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDCamera3DControllerEntity_EType>>";
}

impl Variant for ZHUDCamera3DControllerEntity_EType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDCamera3DControllerEntity_EType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDCamera3DControllerEntity_EType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDCamera3DControllerEntity_EType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDCamera3DControllerEntity_EType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDCamera3DControllerEntity_EType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDOccluderTriggerEntity_EOccluderTestBit {
    PhysX_Far,
    Crowd_Far,
    PhysX_Middle,
    Crowd_Middle,
    PhysX_LowerLeft,
    Crowd_LowerLeft,
    PhysX_LowerRight,
    Crowd_LowerRight,
    PhysX_UpperLeft,
    PhysX_UpperRight,
    LateralShift,
}

impl Aligned for ZHUDOccluderTriggerEntity_EOccluderTestBit {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDOccluderTriggerEntity_EOccluderTestBit {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PhysX_Far => 1i32,
            Self::Crowd_Far => 2i32,
            Self::PhysX_Middle => 4i32,
            Self::Crowd_Middle => 8i32,
            Self::PhysX_LowerLeft => 16i32,
            Self::Crowd_LowerLeft => 32i32,
            Self::PhysX_LowerRight => 64i32,
            Self::Crowd_LowerRight => 128i32,
            Self::PhysX_UpperLeft => 256i32,
            Self::PhysX_UpperRight => 512i32,
            Self::LateralShift => 1024i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDOccluderTriggerEntity_EOccluderTestBit {
     const TYPE_ID: &str = "ZHUDOccluderTriggerEntity_EOccluderTestBit";
}

impl StaticVariant for Vec<ZHUDOccluderTriggerEntity_EOccluderTestBit> {
     const TYPE_ID: &str = "TArray<ZHUDOccluderTriggerEntity_EOccluderTestBit>";
}

impl StaticVariant for Vec<Vec<ZHUDOccluderTriggerEntity_EOccluderTestBit>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDOccluderTriggerEntity_EOccluderTestBit>>";
}

impl Variant for ZHUDOccluderTriggerEntity_EOccluderTestBit {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDOccluderTriggerEntity_EOccluderTestBit")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDOccluderTriggerEntity_EOccluderTestBit".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDOccluderTriggerEntity_EOccluderTestBit>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDOccluderTriggerEntity_EOccluderTestBit>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDOccluderTriggerEntity_EOccluderTestBit>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy {
    INITIALLY_HIDDEN_POPUP_ON_CHANGE,
    DONT_TOUCH,
}

impl Aligned for ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::INITIALLY_HIDDEN_POPUP_ON_CHANGE => 0i32,
            Self::DONT_TOUCH => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy {
     const TYPE_ID: &str = "ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy";
}

impl StaticVariant for Vec<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy> {
     const TYPE_ID: &str = "TArray<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>";
}

impl StaticVariant for Vec<Vec<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>>";
}

impl Variant for ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDOutfitWidgetControllerEntity_EVisibilityPolicy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDTimerInstance_ETimeFormatChoice {
    YES,
    NO,
    AUTO,
}

impl Aligned for ZHUDTimerInstance_ETimeFormatChoice {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDTimerInstance_ETimeFormatChoice {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::YES => 0i32,
            Self::NO => 1i32,
            Self::AUTO => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDTimerInstance_ETimeFormatChoice {
     const TYPE_ID: &str = "ZHUDTimerInstance_ETimeFormatChoice";
}

impl StaticVariant for Vec<ZHUDTimerInstance_ETimeFormatChoice> {
     const TYPE_ID: &str = "TArray<ZHUDTimerInstance_ETimeFormatChoice>";
}

impl StaticVariant for Vec<Vec<ZHUDTimerInstance_ETimeFormatChoice>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDTimerInstance_ETimeFormatChoice>>";
}

impl Variant for ZHUDTimerInstance_ETimeFormatChoice {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDTimerInstance_ETimeFormatChoice")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDTimerInstance_ETimeFormatChoice".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDTimerInstance_ETimeFormatChoice>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDTimerInstance_ETimeFormatChoice>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDTimerInstance_ETimeFormatChoice>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHUDWorldSpatialAttachEntity_EOrientation {
    ROTATE_WITH_SPATIAL,
    LOOK_AT_CAMERA_POSITION,
    LOOK_AT_CAMERA_POSITION_HORIZ_ONLY,
    LOOK_AT_CAMERAPARENT_POSITION,
    LOOK_AT_CAMERAPARENT_POSITION_HORIZ_ONLY,
    ALIGN_WITH_VIEW_PLANE,
    ALIGN_WITH_VIEW_PLANE_HORIZ_ONLY,
}

impl Aligned for ZHUDWorldSpatialAttachEntity_EOrientation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHUDWorldSpatialAttachEntity_EOrientation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ROTATE_WITH_SPATIAL => 0i32,
            Self::LOOK_AT_CAMERA_POSITION => 1i32,
            Self::LOOK_AT_CAMERA_POSITION_HORIZ_ONLY => 2i32,
            Self::LOOK_AT_CAMERAPARENT_POSITION => 3i32,
            Self::LOOK_AT_CAMERAPARENT_POSITION_HORIZ_ONLY => 4i32,
            Self::ALIGN_WITH_VIEW_PLANE => 5i32,
            Self::ALIGN_WITH_VIEW_PLANE_HORIZ_ONLY => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHUDWorldSpatialAttachEntity_EOrientation {
     const TYPE_ID: &str = "ZHUDWorldSpatialAttachEntity_EOrientation";
}

impl StaticVariant for Vec<ZHUDWorldSpatialAttachEntity_EOrientation> {
     const TYPE_ID: &str = "TArray<ZHUDWorldSpatialAttachEntity_EOrientation>";
}

impl StaticVariant for Vec<Vec<ZHUDWorldSpatialAttachEntity_EOrientation>> {
     const TYPE_ID: &str = "TArray<TArray<ZHUDWorldSpatialAttachEntity_EOrientation>>";
}

impl Variant for ZHUDWorldSpatialAttachEntity_EOrientation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHUDWorldSpatialAttachEntity_EOrientation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHUDWorldSpatialAttachEntity_EOrientation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHUDWorldSpatialAttachEntity_EOrientation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHUDWorldSpatialAttachEntity_EOrientation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHUDWorldSpatialAttachEntity_EOrientation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroBoneAttachEntity_EResetMode {
    eAtBoneOrigin,
    eKeepOffset,
}

impl Aligned for ZHeroBoneAttachEntity_EResetMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroBoneAttachEntity_EResetMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAtBoneOrigin => 0i32,
            Self::eKeepOffset => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroBoneAttachEntity_EResetMode {
     const TYPE_ID: &str = "ZHeroBoneAttachEntity_EResetMode";
}

impl StaticVariant for Vec<ZHeroBoneAttachEntity_EResetMode> {
     const TYPE_ID: &str = "TArray<ZHeroBoneAttachEntity_EResetMode>";
}

impl StaticVariant for Vec<Vec<ZHeroBoneAttachEntity_EResetMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroBoneAttachEntity_EResetMode>>";
}

impl Variant for ZHeroBoneAttachEntity_EResetMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroBoneAttachEntity_EResetMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroBoneAttachEntity_EResetMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroBoneAttachEntity_EResetMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroBoneAttachEntity_EResetMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroBoneAttachEntity_EResetMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroInventoryAction_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZHeroInventoryAction_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroInventoryAction_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroInventoryAction_EEvaluationType {
     const TYPE_ID: &str = "ZHeroInventoryAction_EEvaluationType";
}

impl StaticVariant for Vec<ZHeroInventoryAction_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZHeroInventoryAction_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZHeroInventoryAction_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroInventoryAction_EEvaluationType>>";
}

impl Variant for ZHeroInventoryAction_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroInventoryAction_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroInventoryAction_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroInventoryAction_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroInventoryAction_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroInventoryAction_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHeroKeywordCondition_EEvaluationType {
    ALL,
    NONE,
    ANY,
    ANY_TRUE_IF_NO_REQS,
}

impl Aligned for ZHeroKeywordCondition_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHeroKeywordCondition_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::ANY_TRUE_IF_NO_REQS => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHeroKeywordCondition_EEvaluationType {
     const TYPE_ID: &str = "ZHeroKeywordCondition_EEvaluationType";
}

impl StaticVariant for Vec<ZHeroKeywordCondition_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZHeroKeywordCondition_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZHeroKeywordCondition_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZHeroKeywordCondition_EEvaluationType>>";
}

impl Variant for ZHeroKeywordCondition_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHeroKeywordCondition_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHeroKeywordCondition_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHeroKeywordCondition_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHeroKeywordCondition_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHeroKeywordCondition_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZHttpUrl_EVerb {
    eNONE,
    eGET,
    ePOST,
    ePUT,
    eHEAD,
}

impl Aligned for ZHttpUrl_EVerb {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZHttpUrl_EVerb {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNONE => 0i32,
            Self::eGET => 1i32,
            Self::ePOST => 2i32,
            Self::ePUT => 3i32,
            Self::eHEAD => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZHttpUrl_EVerb {
     const TYPE_ID: &str = "ZHttpUrl_EVerb";
}

impl StaticVariant for Vec<ZHttpUrl_EVerb> {
     const TYPE_ID: &str = "TArray<ZHttpUrl_EVerb>";
}

impl StaticVariant for Vec<Vec<ZHttpUrl_EVerb>> {
     const TYPE_ID: &str = "TArray<TArray<ZHttpUrl_EVerb>>";
}

impl Variant for ZHttpUrl_EVerb {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZHttpUrl_EVerb")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZHttpUrl_EVerb".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZHttpUrl_EVerb>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZHttpUrl_EVerb>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZHttpUrl_EVerb>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInputListenerActorPool_eInputListenerButtons {
    EILB_UP,
    EILB_LEFT,
    EILB_DOWN,
    EILB_RIGHT,
}

impl Aligned for ZInputListenerActorPool_eInputListenerButtons {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInputListenerActorPool_eInputListenerButtons {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EILB_UP => 0i32,
            Self::EILB_LEFT => 1i32,
            Self::EILB_DOWN => 2i32,
            Self::EILB_RIGHT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInputListenerActorPool_eInputListenerButtons {
     const TYPE_ID: &str = "ZInputListenerActorPool_eInputListenerButtons";
}

impl StaticVariant for Vec<ZInputListenerActorPool_eInputListenerButtons> {
     const TYPE_ID: &str = "TArray<ZInputListenerActorPool_eInputListenerButtons>";
}

impl StaticVariant for Vec<Vec<ZInputListenerActorPool_eInputListenerButtons>> {
     const TYPE_ID: &str = "TArray<TArray<ZInputListenerActorPool_eInputListenerButtons>>";
}

impl Variant for ZInputListenerActorPool_eInputListenerButtons {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInputListenerActorPool_eInputListenerButtons")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInputListenerActorPool_eInputListenerButtons".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInputListenerActorPool_eInputListenerButtons>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInputListenerActorPool_eInputListenerButtons>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInputListenerActorPool_eInputListenerButtons>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInputListenerAxisEntity_eInputListenerAxes {
    EILA_HORIZONTAL,
    EILA_VERTICAL,
    EILA_TRIGGER_1,
    EILA_TRIGGER_2,
}

impl Aligned for ZInputListenerAxisEntity_eInputListenerAxes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInputListenerAxisEntity_eInputListenerAxes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EILA_HORIZONTAL => 0i32,
            Self::EILA_VERTICAL => 1i32,
            Self::EILA_TRIGGER_1 => 2i32,
            Self::EILA_TRIGGER_2 => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInputListenerAxisEntity_eInputListenerAxes {
     const TYPE_ID: &str = "ZInputListenerAxisEntity_eInputListenerAxes";
}

impl StaticVariant for Vec<ZInputListenerAxisEntity_eInputListenerAxes> {
     const TYPE_ID: &str = "TArray<ZInputListenerAxisEntity_eInputListenerAxes>";
}

impl StaticVariant for Vec<Vec<ZInputListenerAxisEntity_eInputListenerAxes>> {
     const TYPE_ID: &str = "TArray<TArray<ZInputListenerAxisEntity_eInputListenerAxes>>";
}

impl Variant for ZInputListenerAxisEntity_eInputListenerAxes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInputListenerAxisEntity_eInputListenerAxes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInputListenerAxisEntity_eInputListenerAxes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInputListenerAxisEntity_eInputListenerAxes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInputListenerAxisEntity_eInputListenerAxes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInputListenerAxisEntity_eInputListenerAxes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInputListenerButtonEntity_eInputListenerButtons {
    EILB_UP,
    EILB_LEFT,
    EILB_DOWN,
    EILB_RIGHT,
    EILB_AIM,
    EILB_TRIGGER,
}

impl Aligned for ZInputListenerButtonEntity_eInputListenerButtons {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInputListenerButtonEntity_eInputListenerButtons {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EILB_UP => 0i32,
            Self::EILB_LEFT => 1i32,
            Self::EILB_DOWN => 2i32,
            Self::EILB_RIGHT => 3i32,
            Self::EILB_AIM => 4i32,
            Self::EILB_TRIGGER => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInputListenerButtonEntity_eInputListenerButtons {
     const TYPE_ID: &str = "ZInputListenerButtonEntity_eInputListenerButtons";
}

impl StaticVariant for Vec<ZInputListenerButtonEntity_eInputListenerButtons> {
     const TYPE_ID: &str = "TArray<ZInputListenerButtonEntity_eInputListenerButtons>";
}

impl StaticVariant for Vec<Vec<ZInputListenerButtonEntity_eInputListenerButtons>> {
     const TYPE_ID: &str = "TArray<TArray<ZInputListenerButtonEntity_eInputListenerButtons>>";
}

impl Variant for ZInputListenerButtonEntity_eInputListenerButtons {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInputListenerButtonEntity_eInputListenerButtons")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInputListenerButtonEntity_eInputListenerButtons".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInputListenerButtonEntity_eInputListenerButtons>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInputListenerButtonEntity_eInputListenerButtons>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInputListenerButtonEntity_eInputListenerButtons>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInputListenerDpadEntity_eInputListenerDpad {
    EILDP_UP,
    EILDP_LEFT,
    EILDP_DOWN,
    EILDP_RIGHT,
}

impl Aligned for ZInputListenerDpadEntity_eInputListenerDpad {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInputListenerDpadEntity_eInputListenerDpad {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EILDP_UP => 0i32,
            Self::EILDP_LEFT => 1i32,
            Self::EILDP_DOWN => 2i32,
            Self::EILDP_RIGHT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInputListenerDpadEntity_eInputListenerDpad {
     const TYPE_ID: &str = "ZInputListenerDpadEntity_eInputListenerDpad";
}

impl StaticVariant for Vec<ZInputListenerDpadEntity_eInputListenerDpad> {
     const TYPE_ID: &str = "TArray<ZInputListenerDpadEntity_eInputListenerDpad>";
}

impl StaticVariant for Vec<Vec<ZInputListenerDpadEntity_eInputListenerDpad>> {
     const TYPE_ID: &str = "TArray<TArray<ZInputListenerDpadEntity_eInputListenerDpad>>";
}

impl Variant for ZInputListenerDpadEntity_eInputListenerDpad {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInputListenerDpadEntity_eInputListenerDpad")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInputListenerDpadEntity_eInputListenerDpad".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInputListenerDpadEntity_eInputListenerDpad>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInputListenerDpadEntity_eInputListenerDpad>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInputListenerDpadEntity_eInputListenerDpad>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInteractionData_EFilterResult {
    EFR_REQUESTED,
    EFR_ENABLE_INTERACTION,
    EFR_EXPANDED_NOT_INTERACTABLE,
    EFR_COLLAPSED_CANT_OPERATE,
    EFR_COLLAPSED_PRIORITY,
    EFR_COLLAPSED_GAMESTATE,
    EFR_COLLAPSED_ACTION_FILTER,
    EFR_REJECTED_OTHER,
    EFR_REJECTED_OUTOFRANGE,
    EFR_REJECTED_OCCLUDED,
    EFR_REJECTED_OUTOFVIEW,
    EFR_REJECTED_GAMESTATE,
    EFR_REJECTED_ACTION_FILTER,
    EFR_REJECTED_INVALIDDATA,
    EFR_REJECTED_PRIORITY,
}

impl Aligned for ZInteractionData_EFilterResult {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInteractionData_EFilterResult {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EFR_REQUESTED => 0i32,
            Self::EFR_ENABLE_INTERACTION => 1i32,
            Self::EFR_EXPANDED_NOT_INTERACTABLE => 2i32,
            Self::EFR_COLLAPSED_CANT_OPERATE => 3i32,
            Self::EFR_COLLAPSED_PRIORITY => 4i32,
            Self::EFR_COLLAPSED_GAMESTATE => 5i32,
            Self::EFR_COLLAPSED_ACTION_FILTER => 6i32,
            Self::EFR_REJECTED_OTHER => 7i32,
            Self::EFR_REJECTED_OUTOFRANGE => 8i32,
            Self::EFR_REJECTED_OCCLUDED => 9i32,
            Self::EFR_REJECTED_OUTOFVIEW => 10i32,
            Self::EFR_REJECTED_GAMESTATE => 11i32,
            Self::EFR_REJECTED_ACTION_FILTER => 12i32,
            Self::EFR_REJECTED_INVALIDDATA => 13i32,
            Self::EFR_REJECTED_PRIORITY => 14i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInteractionData_EFilterResult {
     const TYPE_ID: &str = "ZInteractionData_EFilterResult";
}

impl StaticVariant for Vec<ZInteractionData_EFilterResult> {
     const TYPE_ID: &str = "TArray<ZInteractionData_EFilterResult>";
}

impl StaticVariant for Vec<Vec<ZInteractionData_EFilterResult>> {
     const TYPE_ID: &str = "TArray<TArray<ZInteractionData_EFilterResult>>";
}

impl Variant for ZInteractionData_EFilterResult {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInteractionData_EFilterResult")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInteractionData_EFilterResult".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInteractionData_EFilterResult>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInteractionData_EFilterResult>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInteractionData_EFilterResult>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInteractionEventConsumer_EEvent {
    eActivate,
    eRH_Place,
    eRH_Retrieve,
    eRH_Swap,
    eRH_Show,
    eRH_Hide,
    eLH_Place,
    eLH_Retrieve,
    eLH_Swap,
    eLH_Show,
    eLH_Hide,
    eObjectEvent01,
    eObjectEvent02,
    eObjectEvent03,
    eObjectEvent04,
    eSoundEvent01,
    eSoundEvent02,
    eSoundEvent03,
    eSoundEvent04,
}

impl Aligned for ZInteractionEventConsumer_EEvent {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInteractionEventConsumer_EEvent {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eActivate => 0i32,
            Self::eRH_Place => 1i32,
            Self::eRH_Retrieve => 2i32,
            Self::eRH_Swap => 3i32,
            Self::eRH_Show => 4i32,
            Self::eRH_Hide => 5i32,
            Self::eLH_Place => 6i32,
            Self::eLH_Retrieve => 7i32,
            Self::eLH_Swap => 8i32,
            Self::eLH_Show => 9i32,
            Self::eLH_Hide => 10i32,
            Self::eObjectEvent01 => 11i32,
            Self::eObjectEvent02 => 12i32,
            Self::eObjectEvent03 => 13i32,
            Self::eObjectEvent04 => 14i32,
            Self::eSoundEvent01 => 15i32,
            Self::eSoundEvent02 => 16i32,
            Self::eSoundEvent03 => 17i32,
            Self::eSoundEvent04 => 18i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInteractionEventConsumer_EEvent {
     const TYPE_ID: &str = "ZInteractionEventConsumer_EEvent";
}

impl StaticVariant for Vec<ZInteractionEventConsumer_EEvent> {
     const TYPE_ID: &str = "TArray<ZInteractionEventConsumer_EEvent>";
}

impl StaticVariant for Vec<Vec<ZInteractionEventConsumer_EEvent>> {
     const TYPE_ID: &str = "TArray<TArray<ZInteractionEventConsumer_EEvent>>";
}

impl Variant for ZInteractionEventConsumer_EEvent {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInteractionEventConsumer_EEvent")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInteractionEventConsumer_EEvent".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInteractionEventConsumer_EEvent>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInteractionEventConsumer_EEvent>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInteractionEventConsumer_EEvent>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZInteractionGuideData_EDirection {
    UP,
    DOWN,
    LEFT,
    RIGHT,
}

impl Aligned for ZInteractionGuideData_EDirection {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZInteractionGuideData_EDirection {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::UP => 0i32,
            Self::DOWN => 1i32,
            Self::LEFT => 2i32,
            Self::RIGHT => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZInteractionGuideData_EDirection {
     const TYPE_ID: &str = "ZInteractionGuideData_EDirection";
}

impl StaticVariant for Vec<ZInteractionGuideData_EDirection> {
     const TYPE_ID: &str = "TArray<ZInteractionGuideData_EDirection>";
}

impl StaticVariant for Vec<Vec<ZInteractionGuideData_EDirection>> {
     const TYPE_ID: &str = "TArray<TArray<ZInteractionGuideData_EDirection>>";
}

impl Variant for ZInteractionGuideData_EDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZInteractionGuideData_EDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZInteractionGuideData_EDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZInteractionGuideData_EDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZInteractionGuideData_EDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZInteractionGuideData_EDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZItemSpawner_EPhysicsMode {
    EPM_DEFINED_BY_ITEM,
    EPM_DYNAMIC,
    EPM_SLEEPING,
    EPM_KINEMATIC,
}

impl Aligned for ZItemSpawner_EPhysicsMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZItemSpawner_EPhysicsMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EPM_DEFINED_BY_ITEM => 0i32,
            Self::EPM_DYNAMIC => 1i32,
            Self::EPM_SLEEPING => 2i32,
            Self::EPM_KINEMATIC => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZItemSpawner_EPhysicsMode {
     const TYPE_ID: &str = "ZItemSpawner_EPhysicsMode";
}

impl StaticVariant for Vec<ZItemSpawner_EPhysicsMode> {
     const TYPE_ID: &str = "TArray<ZItemSpawner_EPhysicsMode>";
}

impl StaticVariant for Vec<Vec<ZItemSpawner_EPhysicsMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZItemSpawner_EPhysicsMode>>";
}

impl Variant for ZItemSpawner_EPhysicsMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZItemSpawner_EPhysicsMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZItemSpawner_EPhysicsMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZItemSpawner_EPhysicsMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZItemSpawner_EPhysicsMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZItemSpawner_EPhysicsMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZKeywordCondition_EEvaluationType {
    ALL,
    NONE,
    ANY,
    ANY_TRUE_IF_NO_REQS,
    EQUAL,
    GREATER,
    LESS,
}

impl Aligned for ZKeywordCondition_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZKeywordCondition_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::ANY_TRUE_IF_NO_REQS => 3i32,
            Self::EQUAL => 4i32,
            Self::GREATER => 5i32,
            Self::LESS => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZKeywordCondition_EEvaluationType {
     const TYPE_ID: &str = "ZKeywordCondition_EEvaluationType";
}

impl StaticVariant for Vec<ZKeywordCondition_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZKeywordCondition_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZKeywordCondition_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZKeywordCondition_EEvaluationType>>";
}

impl Variant for ZKeywordCondition_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZKeywordCondition_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZKeywordCondition_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZKeywordCondition_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZKeywordCondition_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZKeywordCondition_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZLogicMultipleGate_EGateType {
    eFireEveryTime,
    eFirePortOnce,
    eFireOnce,
}

impl Aligned for ZLogicMultipleGate_EGateType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZLogicMultipleGate_EGateType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFireEveryTime => 0i32,
            Self::eFirePortOnce => 1i32,
            Self::eFireOnce => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZLogicMultipleGate_EGateType {
     const TYPE_ID: &str = "ZLogicMultipleGate_EGateType";
}

impl StaticVariant for Vec<ZLogicMultipleGate_EGateType> {
     const TYPE_ID: &str = "TArray<ZLogicMultipleGate_EGateType>";
}

impl StaticVariant for Vec<Vec<ZLogicMultipleGate_EGateType>> {
     const TYPE_ID: &str = "TArray<TArray<ZLogicMultipleGate_EGateType>>";
}

impl Variant for ZLogicMultipleGate_EGateType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZLogicMultipleGate_EGateType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZLogicMultipleGate_EGateType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZLogicMultipleGate_EGateType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZLogicMultipleGate_EGateType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZLogicMultipleGate_EGateType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZLookAtLogic_EAxisSelect {
    eX,
    eX_NEG,
    eY,
    eY_NEG,
    eZ,
    eZ_NEG,
}

impl Aligned for ZLookAtLogic_EAxisSelect {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZLookAtLogic_EAxisSelect {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eX => 0i32,
            Self::eX_NEG => 1i32,
            Self::eY => 2i32,
            Self::eY_NEG => 3i32,
            Self::eZ => 4i32,
            Self::eZ_NEG => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZLookAtLogic_EAxisSelect {
     const TYPE_ID: &str = "ZLookAtLogic_EAxisSelect";
}

impl StaticVariant for Vec<ZLookAtLogic_EAxisSelect> {
     const TYPE_ID: &str = "TArray<ZLookAtLogic_EAxisSelect>";
}

impl StaticVariant for Vec<Vec<ZLookAtLogic_EAxisSelect>> {
     const TYPE_ID: &str = "TArray<TArray<ZLookAtLogic_EAxisSelect>>";
}

impl Variant for ZLookAtLogic_EAxisSelect {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZLookAtLogic_EAxisSelect")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZLookAtLogic_EAxisSelect".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZLookAtLogic_EAxisSelect>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZLookAtLogic_EAxisSelect>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZLookAtLogic_EAxisSelect>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMenuSliderNavigationEntity_ESliderInputMode {
    E_HORIZONTAL,
    E_VERTICAL,
}

impl Aligned for ZMenuSliderNavigationEntity_ESliderInputMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMenuSliderNavigationEntity_ESliderInputMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_HORIZONTAL => 0i32,
            Self::E_VERTICAL => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMenuSliderNavigationEntity_ESliderInputMode {
     const TYPE_ID: &str = "ZMenuSliderNavigationEntity_ESliderInputMode";
}

impl StaticVariant for Vec<ZMenuSliderNavigationEntity_ESliderInputMode> {
     const TYPE_ID: &str = "TArray<ZMenuSliderNavigationEntity_ESliderInputMode>";
}

impl StaticVariant for Vec<Vec<ZMenuSliderNavigationEntity_ESliderInputMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZMenuSliderNavigationEntity_ESliderInputMode>>";
}

impl Variant for ZMenuSliderNavigationEntity_ESliderInputMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMenuSliderNavigationEntity_ESliderInputMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMenuSliderNavigationEntity_ESliderInputMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMenuSliderNavigationEntity_ESliderInputMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMenuSliderNavigationEntity_ESliderInputMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMenuSliderNavigationEntity_ESliderInputMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMinimapDirectionProvider_EAxis {
    X_POSITIVE,
    X_NEGATIVE,
    Y_POSITIVE,
    Y_NEGATIVE,
    Z_POSITIVE,
    Z_NEGATIVE,
}

impl Aligned for ZMinimapDirectionProvider_EAxis {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMinimapDirectionProvider_EAxis {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X_POSITIVE => 0i32,
            Self::X_NEGATIVE => 1i32,
            Self::Y_POSITIVE => 2i32,
            Self::Y_NEGATIVE => 3i32,
            Self::Z_POSITIVE => 4i32,
            Self::Z_NEGATIVE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMinimapDirectionProvider_EAxis {
     const TYPE_ID: &str = "ZMinimapDirectionProvider_EAxis";
}

impl StaticVariant for Vec<ZMinimapDirectionProvider_EAxis> {
     const TYPE_ID: &str = "TArray<ZMinimapDirectionProvider_EAxis>";
}

impl StaticVariant for Vec<Vec<ZMinimapDirectionProvider_EAxis>> {
     const TYPE_ID: &str = "TArray<TArray<ZMinimapDirectionProvider_EAxis>>";
}

impl Variant for ZMinimapDirectionProvider_EAxis {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMinimapDirectionProvider_EAxis")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMinimapDirectionProvider_EAxis".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMinimapDirectionProvider_EAxis>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMinimapDirectionProvider_EAxis>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMinimapDirectionProvider_EAxis>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMinimapDirectionProvider_EProviderType {
    NAVIGATION,
    HERO_MARKER,
}

impl Aligned for ZMinimapDirectionProvider_EProviderType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMinimapDirectionProvider_EProviderType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NAVIGATION => 0i32,
            Self::HERO_MARKER => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMinimapDirectionProvider_EProviderType {
     const TYPE_ID: &str = "ZMinimapDirectionProvider_EProviderType";
}

impl StaticVariant for Vec<ZMinimapDirectionProvider_EProviderType> {
     const TYPE_ID: &str = "TArray<ZMinimapDirectionProvider_EProviderType>";
}

impl StaticVariant for Vec<Vec<ZMinimapDirectionProvider_EProviderType>> {
     const TYPE_ID: &str = "TArray<TArray<ZMinimapDirectionProvider_EProviderType>>";
}

impl Variant for ZMinimapDirectionProvider_EProviderType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMinimapDirectionProvider_EProviderType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMinimapDirectionProvider_EProviderType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMinimapDirectionProvider_EProviderType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMinimapDirectionProvider_EProviderType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMinimapDirectionProvider_EProviderType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMirrorEntity_EMirrorQuality {
    QUALITY_LOW,
    QUALITY_MEDIUM,
    QUALITY_HIGH,
    QUALITY_LEAVE,
}

impl Aligned for ZMirrorEntity_EMirrorQuality {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMirrorEntity_EMirrorQuality {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::QUALITY_LOW => 0i32,
            Self::QUALITY_MEDIUM => 1i32,
            Self::QUALITY_HIGH => 2i32,
            Self::QUALITY_LEAVE => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMirrorEntity_EMirrorQuality {
     const TYPE_ID: &str = "ZMirrorEntity_EMirrorQuality";
}

impl StaticVariant for Vec<ZMirrorEntity_EMirrorQuality> {
     const TYPE_ID: &str = "TArray<ZMirrorEntity_EMirrorQuality>";
}

impl StaticVariant for Vec<Vec<ZMirrorEntity_EMirrorQuality>> {
     const TYPE_ID: &str = "TArray<TArray<ZMirrorEntity_EMirrorQuality>>";
}

impl Variant for ZMirrorEntity_EMirrorQuality {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMirrorEntity_EMirrorQuality")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMirrorEntity_EMirrorQuality".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMirrorEntity_EMirrorQuality>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMirrorEntity_EMirrorQuality>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMirrorEntity_EMirrorQuality>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZModalDialogCondition_EPriorityBit {
    Critical,
    GDPRConsent,
    MultiplayerSystem,
    Disconnect,
    System,
    Normal,
    Low,
}

impl Aligned for ZModalDialogCondition_EPriorityBit {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZModalDialogCondition_EPriorityBit {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Critical => 1i32,
            Self::GDPRConsent => 2i32,
            Self::MultiplayerSystem => 4i32,
            Self::Disconnect => 8i32,
            Self::System => 16i32,
            Self::Normal => 32i32,
            Self::Low => 64i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZModalDialogCondition_EPriorityBit {
     const TYPE_ID: &str = "ZModalDialogCondition_EPriorityBit";
}

impl StaticVariant for Vec<ZModalDialogCondition_EPriorityBit> {
     const TYPE_ID: &str = "TArray<ZModalDialogCondition_EPriorityBit>";
}

impl StaticVariant for Vec<Vec<ZModalDialogCondition_EPriorityBit>> {
     const TYPE_ID: &str = "TArray<TArray<ZModalDialogCondition_EPriorityBit>>";
}

impl Variant for ZModalDialogCondition_EPriorityBit {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZModalDialogCondition_EPriorityBit")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZModalDialogCondition_EPriorityBit".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZModalDialogCondition_EPriorityBit>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZModalDialogCondition_EPriorityBit>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZModalDialogCondition_EPriorityBit>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMoveToPositionBehaviorEntity_EApproachAlignment {
    AA_STRICT,
    AA_LOOSE,
}

impl Aligned for ZMoveToPositionBehaviorEntity_EApproachAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMoveToPositionBehaviorEntity_EApproachAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AA_STRICT => 0i32,
            Self::AA_LOOSE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMoveToPositionBehaviorEntity_EApproachAlignment {
     const TYPE_ID: &str = "ZMoveToPositionBehaviorEntity_EApproachAlignment";
}

impl StaticVariant for Vec<ZMoveToPositionBehaviorEntity_EApproachAlignment> {
     const TYPE_ID: &str = "TArray<ZMoveToPositionBehaviorEntity_EApproachAlignment>";
}

impl StaticVariant for Vec<Vec<ZMoveToPositionBehaviorEntity_EApproachAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZMoveToPositionBehaviorEntity_EApproachAlignment>>";
}

impl Variant for ZMoveToPositionBehaviorEntity_EApproachAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMoveToPositionBehaviorEntity_EApproachAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMoveToPositionBehaviorEntity_EApproachAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMoveToPositionBehaviorEntity_EApproachAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMoveToPositionBehaviorEntity_EApproachAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMoveToPositionBehaviorEntity_EApproachAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMoveToPositionBehaviorEntity_EMovementType {
    MT_WALK,
    MT_SNAP,
    MT_IGNORE_POSITION,
}

impl Aligned for ZMoveToPositionBehaviorEntity_EMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMoveToPositionBehaviorEntity_EMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MT_WALK => 0i32,
            Self::MT_SNAP => 1i32,
            Self::MT_IGNORE_POSITION => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMoveToPositionBehaviorEntity_EMovementType {
     const TYPE_ID: &str = "ZMoveToPositionBehaviorEntity_EMovementType";
}

impl StaticVariant for Vec<ZMoveToPositionBehaviorEntity_EMovementType> {
     const TYPE_ID: &str = "TArray<ZMoveToPositionBehaviorEntity_EMovementType>";
}

impl StaticVariant for Vec<Vec<ZMoveToPositionBehaviorEntity_EMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<ZMoveToPositionBehaviorEntity_EMovementType>>";
}

impl Variant for ZMoveToPositionBehaviorEntity_EMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMoveToPositionBehaviorEntity_EMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMoveToPositionBehaviorEntity_EMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMoveToPositionBehaviorEntity_EMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMoveToPositionBehaviorEntity_EMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMoveToPositionBehaviorEntity_EMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZMoveToPositionBehaviorEntity_ERotationAlignment {
    RA_NONE,
    RA_LOOSE,
    RA_EXACT,
}

impl Aligned for ZMoveToPositionBehaviorEntity_ERotationAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZMoveToPositionBehaviorEntity_ERotationAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RA_NONE => 0i32,
            Self::RA_LOOSE => 1i32,
            Self::RA_EXACT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZMoveToPositionBehaviorEntity_ERotationAlignment {
     const TYPE_ID: &str = "ZMoveToPositionBehaviorEntity_ERotationAlignment";
}

impl StaticVariant for Vec<ZMoveToPositionBehaviorEntity_ERotationAlignment> {
     const TYPE_ID: &str = "TArray<ZMoveToPositionBehaviorEntity_ERotationAlignment>";
}

impl StaticVariant for Vec<Vec<ZMoveToPositionBehaviorEntity_ERotationAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZMoveToPositionBehaviorEntity_ERotationAlignment>>";
}

impl Variant for ZMoveToPositionBehaviorEntity_ERotationAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZMoveToPositionBehaviorEntity_ERotationAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZMoveToPositionBehaviorEntity_ERotationAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZMoveToPositionBehaviorEntity_ERotationAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZMoveToPositionBehaviorEntity_ERotationAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZMoveToPositionBehaviorEntity_ERotationAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZOnlineManager_EError {
    eNONE,
    eGENERAL,
    eNETWORK_UNKNOWN,
    eNETWORK_SEND_FAILED,
    eAPI_VERSION,
    eAUTHENTICATION_UNAUTHORIZED,
    eAUTHENTICATION_PROXY,
    eAUTHENTICATION_SERVER_ERROR,
    eAUTHENTICATION_SERVER_MAINTENANCE,
    eAUTHENTICATION_SERVER_IN_QUEUE,
    eAUTHENTICATION_USER_GONE,
    eAUTHENTICATION_STEAM_GENERAL,
    eAUTHENTICATION_EPIC_GENERAL,
    eAUTHENTICATION_IZUMO_GENERAL,
    eAUTHENTICATION_GOG_GENERAL,
    eAUTHENTICATION_PSN_GENERAL,
    eAUTHENTICATION_PSN_NP_CHECK,
    eAUTHENTICATION_PSN_ACCOUNT_COLLISION,
    eAUTHENTICATION_NO_PRIMARY_USER,
    eAUTHENTICATION_XBLIVE_GENERAL,
    eAUTHENTICATION_XBLIVE_SIGNED_OUT,
    eAUTHENTICATION_XBLIVE_USER_CHANGED,
    eAUTHENTICATION_STADIA_GENERAL,
    ePLATFORM_USERINFO,
    eCONFIGURATION,
    eENTITLEMENTS,
    ePROFILE,
    eGAME_SESSION,
    eCLIENT_OUTDATED,
    eGENERAL_SERVER_ERROR,
    eGENERAL_SERVER_BUSY,
    eGENERAL_CLIENT_ERROR,
    eDYNAMIC_RESOURCES_CONFIG_ERROR,
    eDYNAMIC_RESOURCES_UPDATEFAILED,
    eDYNAMIC_RESOURCES_OUTDATED,
    eFSP_IOI_ACCOUNT_SIGNUP_REQUIRED,
    eFSP_IOI_ACCOUNT_SIGNUP_ERROR,
    eCANCELLED,
    eERROR_MAX,
}

impl Aligned for ZOnlineManager_EError {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZOnlineManager_EError {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eNONE => 0i32,
            Self::eGENERAL => 1000i32,
            Self::eNETWORK_UNKNOWN => 1001i32,
            Self::eNETWORK_SEND_FAILED => 1002i32,
            Self::eAPI_VERSION => 1003i32,
            Self::eAUTHENTICATION_UNAUTHORIZED => 1004i32,
            Self::eAUTHENTICATION_PROXY => 1005i32,
            Self::eAUTHENTICATION_SERVER_ERROR => 1006i32,
            Self::eAUTHENTICATION_SERVER_MAINTENANCE => 1007i32,
            Self::eAUTHENTICATION_SERVER_IN_QUEUE => 1008i32,
            Self::eAUTHENTICATION_USER_GONE => 1009i32,
            Self::eAUTHENTICATION_STEAM_GENERAL => 1010i32,
            Self::eAUTHENTICATION_EPIC_GENERAL => 1011i32,
            Self::eAUTHENTICATION_IZUMO_GENERAL => 1012i32,
            Self::eAUTHENTICATION_GOG_GENERAL => 1013i32,
            Self::eAUTHENTICATION_PSN_GENERAL => 1014i32,
            Self::eAUTHENTICATION_PSN_NP_CHECK => 1015i32,
            Self::eAUTHENTICATION_PSN_ACCOUNT_COLLISION => 1016i32,
            Self::eAUTHENTICATION_NO_PRIMARY_USER => 1017i32,
            Self::eAUTHENTICATION_XBLIVE_GENERAL => 1018i32,
            Self::eAUTHENTICATION_XBLIVE_SIGNED_OUT => 1019i32,
            Self::eAUTHENTICATION_XBLIVE_USER_CHANGED => 1020i32,
            Self::eAUTHENTICATION_STADIA_GENERAL => 1021i32,
            Self::ePLATFORM_USERINFO => 1022i32,
            Self::eCONFIGURATION => 1023i32,
            Self::eENTITLEMENTS => 1024i32,
            Self::ePROFILE => 1025i32,
            Self::eGAME_SESSION => 1026i32,
            Self::eCLIENT_OUTDATED => 1027i32,
            Self::eGENERAL_SERVER_ERROR => 1028i32,
            Self::eGENERAL_SERVER_BUSY => 1029i32,
            Self::eGENERAL_CLIENT_ERROR => 1030i32,
            Self::eDYNAMIC_RESOURCES_CONFIG_ERROR => 1031i32,
            Self::eDYNAMIC_RESOURCES_UPDATEFAILED => 1032i32,
            Self::eDYNAMIC_RESOURCES_OUTDATED => 1033i32,
            Self::eFSP_IOI_ACCOUNT_SIGNUP_REQUIRED => 1034i32,
            Self::eFSP_IOI_ACCOUNT_SIGNUP_ERROR => 1035i32,
            Self::eCANCELLED => 1036i32,
            Self::eERROR_MAX => 1037i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZOnlineManager_EError {
     const TYPE_ID: &str = "ZOnlineManager_EError";
}

impl StaticVariant for Vec<ZOnlineManager_EError> {
     const TYPE_ID: &str = "TArray<ZOnlineManager_EError>";
}

impl StaticVariant for Vec<Vec<ZOnlineManager_EError>> {
     const TYPE_ID: &str = "TArray<TArray<ZOnlineManager_EError>>";
}

impl Variant for ZOnlineManager_EError {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZOnlineManager_EError")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZOnlineManager_EError".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZOnlineManager_EError>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZOnlineManager_EError>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZOnlineManager_EError>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZOnlineManager_EIoiAccountState {
    eMISSING,
    eUNCONFIRMED,
    eCONFIRMED,
}

impl Aligned for ZOnlineManager_EIoiAccountState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZOnlineManager_EIoiAccountState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eMISSING => 0i32,
            Self::eUNCONFIRMED => 1i32,
            Self::eCONFIRMED => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZOnlineManager_EIoiAccountState {
     const TYPE_ID: &str = "ZOnlineManager_EIoiAccountState";
}

impl StaticVariant for Vec<ZOnlineManager_EIoiAccountState> {
     const TYPE_ID: &str = "TArray<ZOnlineManager_EIoiAccountState>";
}

impl StaticVariant for Vec<Vec<ZOnlineManager_EIoiAccountState>> {
     const TYPE_ID: &str = "TArray<TArray<ZOnlineManager_EIoiAccountState>>";
}

impl Variant for ZOnlineManager_EIoiAccountState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZOnlineManager_EIoiAccountState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZOnlineManager_EIoiAccountState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZOnlineManager_EIoiAccountState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZOnlineManager_EIoiAccountState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZOnlineManager_EIoiAccountState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZOnlineManager_EState {
    eTRIGGER_FLOW,
    eOFFLINE,
    eSUSPEND,
    eDISCONNECTED,
    eBEGIN_CONNECTION_FLOW,
    ePREAUTHENTICATE,
    eFETCH_API_VERSION,
    eFETCHING_API_VERSION,
    eAPI_VERSION_RECEIVED,
    eFETCHING_CONFIGURATION,
    eCONFIGURATION_RECEIVED,
    eONLINE_CONSENT_CONFIRMATION,
    ePREAUTHENTICATION_ENTITLEMENTS_SYNCHRONIZE_INPROGRESS,
    ePREAUTHENTICATION_ENTITLEMENTS_SYNCHRONIZE_DONE,
    eAUTHENTICATING,
    eAUTHENTICATION_RECEIVED,
    eENTITLEMENTS_SYNCHRONIZE_INPROGRESS,
    eENTITLEMENTS_SYNCHRONIZE_DONE,
    eAUTHENTICATING_GAMESERVICE,
    eAUTHENTICATION_GAMESERVICE_RECEIVED,
    eFSP_IOI_ACCOUNT_SIGNUP,
    eFETCHING_OFFLINE_CACHE_DB_DIFF,
    eFETCHING_OFFLINE_CACHE_DB_DIFF_RECEIVED,
    eFETCHING_DYNAMIC_RESOURCES,
    eDYNAMIC_RESOURCES_MOUNTED,
    eCHECK_FOR_DLC_UPDATES,
    eFETCHING_PLATFORM_USERINFO,
    ePLATFORM_USERINFO_RECEIVED,
    eFETCHING_USER_CONFIGURATION,
    eUSER_CONFIGURATION_RECEIEVED,
    eFETCHING_PROFILE,
    ePROFILE_RECEIVED,
    eSYNCHRONIZING_PROFILE,
    ePROFILE_SYNCHRONIZED,
    eRETRIEVING_EVENTS,
    eEVENTS_RETRIEVED,
    eWAITING_FOR_SYNCHRONIZING_EVENTS,
    eCONNECTED,
    eCONNECT_TO_GAME_SESSION,
    eCONNECTING_TO_GAME_SESSION,
    eRETRY_SAVE_EVENTS,
    eRETRY_SAVE_EVENTS_INTERNAL,
    eREAUTHENTICATE,
    ePLATFORM_SESSION_RECONNECT,
    eSTATE_MAX,
}

impl Aligned for ZOnlineManager_EState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZOnlineManager_EState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTRIGGER_FLOW => 1i32,
            Self::eOFFLINE => 2i32,
            Self::eSUSPEND => 3i32,
            Self::eDISCONNECTED => 4i32,
            Self::eBEGIN_CONNECTION_FLOW => 5i32,
            Self::ePREAUTHENTICATE => 6i32,
            Self::eFETCH_API_VERSION => 7i32,
            Self::eFETCHING_API_VERSION => 8i32,
            Self::eAPI_VERSION_RECEIVED => 9i32,
            Self::eFETCHING_CONFIGURATION => 10i32,
            Self::eCONFIGURATION_RECEIVED => 11i32,
            Self::eONLINE_CONSENT_CONFIRMATION => 12i32,
            Self::ePREAUTHENTICATION_ENTITLEMENTS_SYNCHRONIZE_INPROGRESS => 13i32,
            Self::ePREAUTHENTICATION_ENTITLEMENTS_SYNCHRONIZE_DONE => 14i32,
            Self::eAUTHENTICATING => 15i32,
            Self::eAUTHENTICATION_RECEIVED => 16i32,
            Self::eENTITLEMENTS_SYNCHRONIZE_INPROGRESS => 17i32,
            Self::eENTITLEMENTS_SYNCHRONIZE_DONE => 18i32,
            Self::eAUTHENTICATING_GAMESERVICE => 19i32,
            Self::eAUTHENTICATION_GAMESERVICE_RECEIVED => 20i32,
            Self::eFSP_IOI_ACCOUNT_SIGNUP => 21i32,
            Self::eFETCHING_OFFLINE_CACHE_DB_DIFF => 22i32,
            Self::eFETCHING_OFFLINE_CACHE_DB_DIFF_RECEIVED => 23i32,
            Self::eFETCHING_DYNAMIC_RESOURCES => 24i32,
            Self::eDYNAMIC_RESOURCES_MOUNTED => 25i32,
            Self::eCHECK_FOR_DLC_UPDATES => 26i32,
            Self::eFETCHING_PLATFORM_USERINFO => 27i32,
            Self::ePLATFORM_USERINFO_RECEIVED => 28i32,
            Self::eFETCHING_USER_CONFIGURATION => 29i32,
            Self::eUSER_CONFIGURATION_RECEIEVED => 30i32,
            Self::eFETCHING_PROFILE => 31i32,
            Self::ePROFILE_RECEIVED => 32i32,
            Self::eSYNCHRONIZING_PROFILE => 33i32,
            Self::ePROFILE_SYNCHRONIZED => 34i32,
            Self::eRETRIEVING_EVENTS => 35i32,
            Self::eEVENTS_RETRIEVED => 36i32,
            Self::eWAITING_FOR_SYNCHRONIZING_EVENTS => 37i32,
            Self::eCONNECTED => 38i32,
            Self::eCONNECT_TO_GAME_SESSION => 39i32,
            Self::eCONNECTING_TO_GAME_SESSION => 40i32,
            Self::eRETRY_SAVE_EVENTS => 41i32,
            Self::eRETRY_SAVE_EVENTS_INTERNAL => 42i32,
            Self::eREAUTHENTICATE => 43i32,
            Self::ePLATFORM_SESSION_RECONNECT => 44i32,
            Self::eSTATE_MAX => 45i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZOnlineManager_EState {
     const TYPE_ID: &str = "ZOnlineManager_EState";
}

impl StaticVariant for Vec<ZOnlineManager_EState> {
     const TYPE_ID: &str = "TArray<ZOnlineManager_EState>";
}

impl StaticVariant for Vec<Vec<ZOnlineManager_EState>> {
     const TYPE_ID: &str = "TArray<TArray<ZOnlineManager_EState>>";
}

impl Variant for ZOnlineManager_EState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZOnlineManager_EState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZOnlineManager_EState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZOnlineManager_EState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZOnlineManager_EState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZOnlineManager_EState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZOperatorBool_EEvaluationType {
    ALL,
    NONE,
    ANY,
}

impl Aligned for ZOperatorBool_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZOperatorBool_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZOperatorBool_EEvaluationType {
     const TYPE_ID: &str = "ZOperatorBool_EEvaluationType";
}

impl StaticVariant for Vec<ZOperatorBool_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZOperatorBool_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZOperatorBool_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZOperatorBool_EEvaluationType>>";
}

impl Variant for ZOperatorBool_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZOperatorBool_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZOperatorBool_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZOperatorBool_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZOperatorBool_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZOperatorBool_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPIPMessageEntity_EIcon {
    IconStart,
    MagnifyingGlass,
    ArrowRight,
    ExclamationMark,
    Target,
    SurveillanceCamera,
    Concealed,
    QuestionMark,
    IconEnd,
}

impl Aligned for ZPIPMessageEntity_EIcon {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPIPMessageEntity_EIcon {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IconStart => 0i32,
            Self::MagnifyingGlass => 1i32,
            Self::ArrowRight => 2i32,
            Self::ExclamationMark => 3i32,
            Self::Target => 4i32,
            Self::SurveillanceCamera => 5i32,
            Self::Concealed => 6i32,
            Self::QuestionMark => 7i32,
            Self::IconEnd => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPIPMessageEntity_EIcon {
     const TYPE_ID: &str = "ZPIPMessageEntity_EIcon";
}

impl StaticVariant for Vec<ZPIPMessageEntity_EIcon> {
     const TYPE_ID: &str = "TArray<ZPIPMessageEntity_EIcon>";
}

impl StaticVariant for Vec<Vec<ZPIPMessageEntity_EIcon>> {
     const TYPE_ID: &str = "TArray<TArray<ZPIPMessageEntity_EIcon>>";
}

impl Variant for ZPIPMessageEntity_EIcon {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPIPMessageEntity_EIcon")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPIPMessageEntity_EIcon".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPIPMessageEntity_EIcon>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPIPMessageEntity_EIcon>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPIPMessageEntity_EIcon>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPathfinderDebugEntity_EDebugTestType {
    PATHFINDER,
    TRACELINE,
    MAP_LOCATION,
    REGION_MASK_WITHIN_RADIUS,
}

impl Aligned for ZPathfinderDebugEntity_EDebugTestType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPathfinderDebugEntity_EDebugTestType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::PATHFINDER => 0i32,
            Self::TRACELINE => 1i32,
            Self::MAP_LOCATION => 2i32,
            Self::REGION_MASK_WITHIN_RADIUS => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPathfinderDebugEntity_EDebugTestType {
     const TYPE_ID: &str = "ZPathfinderDebugEntity_EDebugTestType";
}

impl StaticVariant for Vec<ZPathfinderDebugEntity_EDebugTestType> {
     const TYPE_ID: &str = "TArray<ZPathfinderDebugEntity_EDebugTestType>";
}

impl StaticVariant for Vec<Vec<ZPathfinderDebugEntity_EDebugTestType>> {
     const TYPE_ID: &str = "TArray<TArray<ZPathfinderDebugEntity_EDebugTestType>>";
}

impl Variant for ZPathfinderDebugEntity_EDebugTestType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPathfinderDebugEntity_EDebugTestType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPathfinderDebugEntity_EDebugTestType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPathfinderDebugEntity_EDebugTestType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPathfinderDebugEntity_EDebugTestType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPathfinderDebugEntity_EDebugTestType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPatrolBehaviorEntity_EMovementType {
    MT_WALK,
    MT_SNAP,
    MT_IGNORE_POSITION,
}

impl Aligned for ZPatrolBehaviorEntity_EMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPatrolBehaviorEntity_EMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MT_WALK => 0i32,
            Self::MT_SNAP => 1i32,
            Self::MT_IGNORE_POSITION => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPatrolBehaviorEntity_EMovementType {
     const TYPE_ID: &str = "ZPatrolBehaviorEntity_EMovementType";
}

impl StaticVariant for Vec<ZPatrolBehaviorEntity_EMovementType> {
     const TYPE_ID: &str = "TArray<ZPatrolBehaviorEntity_EMovementType>";
}

impl StaticVariant for Vec<Vec<ZPatrolBehaviorEntity_EMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<ZPatrolBehaviorEntity_EMovementType>>";
}

impl Variant for ZPatrolBehaviorEntity_EMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPatrolBehaviorEntity_EMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPatrolBehaviorEntity_EMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPatrolBehaviorEntity_EMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPatrolBehaviorEntity_EMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPatrolBehaviorEntity_EMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPatrolBehaviorEntity_ERotationAlignment {
    RA_NONE,
    RA_LOOSE,
    RA_EXACT,
}

impl Aligned for ZPatrolBehaviorEntity_ERotationAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPatrolBehaviorEntity_ERotationAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::RA_NONE => 0i32,
            Self::RA_LOOSE => 1i32,
            Self::RA_EXACT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPatrolBehaviorEntity_ERotationAlignment {
     const TYPE_ID: &str = "ZPatrolBehaviorEntity_ERotationAlignment";
}

impl StaticVariant for Vec<ZPatrolBehaviorEntity_ERotationAlignment> {
     const TYPE_ID: &str = "TArray<ZPatrolBehaviorEntity_ERotationAlignment>";
}

impl StaticVariant for Vec<Vec<ZPatrolBehaviorEntity_ERotationAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZPatrolBehaviorEntity_ERotationAlignment>>";
}

impl Variant for ZPatrolBehaviorEntity_ERotationAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPatrolBehaviorEntity_ERotationAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPatrolBehaviorEntity_ERotationAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPatrolBehaviorEntity_ERotationAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPatrolBehaviorEntity_ERotationAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPatrolBehaviorEntity_ERotationAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPhotoModeMenuDataProvider_EMenuEntryType {
    Toggle,
    Slider,
    List,
}

impl Aligned for ZPhotoModeMenuDataProvider_EMenuEntryType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPhotoModeMenuDataProvider_EMenuEntryType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Toggle => 1i32,
            Self::Slider => 2i32,
            Self::List => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPhotoModeMenuDataProvider_EMenuEntryType {
     const TYPE_ID: &str = "ZPhotoModeMenuDataProvider_EMenuEntryType";
}

impl StaticVariant for Vec<ZPhotoModeMenuDataProvider_EMenuEntryType> {
     const TYPE_ID: &str = "TArray<ZPhotoModeMenuDataProvider_EMenuEntryType>";
}

impl StaticVariant for Vec<Vec<ZPhotoModeMenuDataProvider_EMenuEntryType>> {
     const TYPE_ID: &str = "TArray<TArray<ZPhotoModeMenuDataProvider_EMenuEntryType>>";
}

impl Variant for ZPhotoModeMenuDataProvider_EMenuEntryType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPhotoModeMenuDataProvider_EMenuEntryType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPhotoModeMenuDataProvider_EMenuEntryType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPhotoModeMenuDataProvider_EMenuEntryType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPhotoModeMenuDataProvider_EMenuEntryType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPhotoModeMenuDataProvider_EMenuEntryType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPointOfInterestEntity_EPOIType {
    ePOIT_Invalid,
    ePOIT_Glance,
    ePOIT_Inspect,
    ePOIT_Stare,
}

impl Aligned for ZPointOfInterestEntity_EPOIType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPointOfInterestEntity_EPOIType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ePOIT_Invalid => 0i32,
            Self::ePOIT_Glance => 1i32,
            Self::ePOIT_Inspect => 2i32,
            Self::ePOIT_Stare => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPointOfInterestEntity_EPOIType {
     const TYPE_ID: &str = "ZPointOfInterestEntity_EPOIType";
}

impl StaticVariant for Vec<ZPointOfInterestEntity_EPOIType> {
     const TYPE_ID: &str = "TArray<ZPointOfInterestEntity_EPOIType>";
}

impl StaticVariant for Vec<Vec<ZPointOfInterestEntity_EPOIType>> {
     const TYPE_ID: &str = "TArray<TArray<ZPointOfInterestEntity_EPOIType>>";
}

impl Variant for ZPointOfInterestEntity_EPOIType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPointOfInterestEntity_EPOIType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPointOfInterestEntity_EPOIType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPointOfInterestEntity_EPOIType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPointOfInterestEntity_EPOIType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPointOfInterestEntity_EPOIType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZPreferenceItemEntity_EBoolOptions {
    EBO_INVERTVERTICAL,
    EBO_FIXEDMAP,
}

impl Aligned for ZPreferenceItemEntity_EBoolOptions {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZPreferenceItemEntity_EBoolOptions {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EBO_INVERTVERTICAL => 0i32,
            Self::EBO_FIXEDMAP => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZPreferenceItemEntity_EBoolOptions {
     const TYPE_ID: &str = "ZPreferenceItemEntity_EBoolOptions";
}

impl StaticVariant for Vec<ZPreferenceItemEntity_EBoolOptions> {
     const TYPE_ID: &str = "TArray<ZPreferenceItemEntity_EBoolOptions>";
}

impl StaticVariant for Vec<Vec<ZPreferenceItemEntity_EBoolOptions>> {
     const TYPE_ID: &str = "TArray<TArray<ZPreferenceItemEntity_EBoolOptions>>";
}

impl Variant for ZPreferenceItemEntity_EBoolOptions {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZPreferenceItemEntity_EBoolOptions")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZPreferenceItemEntity_EBoolOptions".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZPreferenceItemEntity_EBoolOptions>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZPreferenceItemEntity_EBoolOptions>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZPreferenceItemEntity_EBoolOptions>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRagdollAttacherEntity_EResetMode {
    eAtBoneOrigin,
    eKeepOffset,
}

impl Aligned for ZRagdollAttacherEntity_EResetMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRagdollAttacherEntity_EResetMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eAtBoneOrigin => 0i32,
            Self::eKeepOffset => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRagdollAttacherEntity_EResetMode {
     const TYPE_ID: &str = "ZRagdollAttacherEntity_EResetMode";
}

impl StaticVariant for Vec<ZRagdollAttacherEntity_EResetMode> {
     const TYPE_ID: &str = "TArray<ZRagdollAttacherEntity_EResetMode>";
}

impl StaticVariant for Vec<Vec<ZRagdollAttacherEntity_EResetMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZRagdollAttacherEntity_EResetMode>>";
}

impl Variant for ZRagdollAttacherEntity_EResetMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRagdollAttacherEntity_EResetMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRagdollAttacherEntity_EResetMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRagdollAttacherEntity_EResetMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRagdollAttacherEntity_EResetMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRagdollAttacherEntity_EResetMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRecoverUnconsciousGroup_EInvestigateGroupState {
    IGS_InitialState,
    IGS_WaitingForVictim,
    IGS_Recovering,
    IGS_Relocating,
    IGS_Reporting,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZRecoverUnconsciousGroup_EInvestigateGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRecoverUnconsciousGroup_EInvestigateGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_InitialState => 0i32,
            Self::IGS_WaitingForVictim => 1i32,
            Self::IGS_Recovering => 2i32,
            Self::IGS_Relocating => 3i32,
            Self::IGS_Reporting => 4i32,
            Self::IGS_Completed => 5i32,
            Self::IGS_Max => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRecoverUnconsciousGroup_EInvestigateGroupState {
     const TYPE_ID: &str = "ZRecoverUnconsciousGroup_EInvestigateGroupState";
}

impl StaticVariant for Vec<ZRecoverUnconsciousGroup_EInvestigateGroupState> {
     const TYPE_ID: &str = "TArray<ZRecoverUnconsciousGroup_EInvestigateGroupState>";
}

impl StaticVariant for Vec<Vec<ZRecoverUnconsciousGroup_EInvestigateGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZRecoverUnconsciousGroup_EInvestigateGroupState>>";
}

impl Variant for ZRecoverUnconsciousGroup_EInvestigateGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRecoverUnconsciousGroup_EInvestigateGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRecoverUnconsciousGroup_EInvestigateGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRecoverUnconsciousGroup_EInvestigateGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRecoverUnconsciousGroup_EInvestigateGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRecoverUnconsciousGroup_EInvestigateGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRenderPostfilterParametersEntity_EDOFBlurType {
    eFastest,
    eLowRezLensBlur,
    eLowRezLensBlurSoft,
    eHighRezLensBlur,
}

impl Aligned for ZRenderPostfilterParametersEntity_EDOFBlurType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRenderPostfilterParametersEntity_EDOFBlurType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eFastest => 0i32,
            Self::eLowRezLensBlur => 1i32,
            Self::eLowRezLensBlurSoft => 2i32,
            Self::eHighRezLensBlur => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRenderPostfilterParametersEntity_EDOFBlurType {
     const TYPE_ID: &str = "ZRenderPostfilterParametersEntity_EDOFBlurType";
}

impl StaticVariant for Vec<ZRenderPostfilterParametersEntity_EDOFBlurType> {
     const TYPE_ID: &str = "TArray<ZRenderPostfilterParametersEntity_EDOFBlurType>";
}

impl StaticVariant for Vec<Vec<ZRenderPostfilterParametersEntity_EDOFBlurType>> {
     const TYPE_ID: &str = "TArray<TArray<ZRenderPostfilterParametersEntity_EDOFBlurType>>";
}

impl Variant for ZRenderPostfilterParametersEntity_EDOFBlurType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRenderPostfilterParametersEntity_EDOFBlurType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRenderPostfilterParametersEntity_EDOFBlurType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRenderPostfilterParametersEntity_EDOFBlurType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRenderPostfilterParametersEntity_EDOFBlurType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRenderPostfilterParametersEntity_EDOFBlurType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRenderPostfilterParametersEntity_EHDRAdaptationType {
    eMedian,
    eGeometricMean,
}

impl Aligned for ZRenderPostfilterParametersEntity_EHDRAdaptationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRenderPostfilterParametersEntity_EHDRAdaptationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eMedian => 0i32,
            Self::eGeometricMean => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRenderPostfilterParametersEntity_EHDRAdaptationType {
     const TYPE_ID: &str = "ZRenderPostfilterParametersEntity_EHDRAdaptationType";
}

impl StaticVariant for Vec<ZRenderPostfilterParametersEntity_EHDRAdaptationType> {
     const TYPE_ID: &str = "TArray<ZRenderPostfilterParametersEntity_EHDRAdaptationType>";
}

impl StaticVariant for Vec<Vec<ZRenderPostfilterParametersEntity_EHDRAdaptationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZRenderPostfilterParametersEntity_EHDRAdaptationType>>";
}

impl Variant for ZRenderPostfilterParametersEntity_EHDRAdaptationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRenderPostfilterParametersEntity_EHDRAdaptationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRenderPostfilterParametersEntity_EHDRAdaptationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRenderPostfilterParametersEntity_EHDRAdaptationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRenderPostfilterParametersEntity_EHDRAdaptationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRenderPostfilterParametersEntity_EHDRAdaptationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRenderPostfilterParametersEntity_EHDRGlareType {
    eCamera,
    eNatural,
    eCheapLens,
    eFilterCrossScreen,
    eFilterCrossScreenSpectral,
    eFilterSnowCross,
    eFilterSnowCrossSpectral,
    eFilterSunnyCross,
    eFilterSunnyCrossSpectral,
    eCinecamVerticalSlits,
    eCinecamHorizontalSlits,
}

impl Aligned for ZRenderPostfilterParametersEntity_EHDRGlareType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRenderPostfilterParametersEntity_EHDRGlareType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCamera => 0i32,
            Self::eNatural => 1i32,
            Self::eCheapLens => 2i32,
            Self::eFilterCrossScreen => 3i32,
            Self::eFilterCrossScreenSpectral => 4i32,
            Self::eFilterSnowCross => 5i32,
            Self::eFilterSnowCrossSpectral => 6i32,
            Self::eFilterSunnyCross => 7i32,
            Self::eFilterSunnyCrossSpectral => 8i32,
            Self::eCinecamVerticalSlits => 9i32,
            Self::eCinecamHorizontalSlits => 10i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRenderPostfilterParametersEntity_EHDRGlareType {
     const TYPE_ID: &str = "ZRenderPostfilterParametersEntity_EHDRGlareType";
}

impl StaticVariant for Vec<ZRenderPostfilterParametersEntity_EHDRGlareType> {
     const TYPE_ID: &str = "TArray<ZRenderPostfilterParametersEntity_EHDRGlareType>";
}

impl StaticVariant for Vec<Vec<ZRenderPostfilterParametersEntity_EHDRGlareType>> {
     const TYPE_ID: &str = "TArray<TArray<ZRenderPostfilterParametersEntity_EHDRGlareType>>";
}

impl Variant for ZRenderPostfilterParametersEntity_EHDRGlareType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRenderPostfilterParametersEntity_EHDRGlareType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRenderPostfilterParametersEntity_EHDRGlareType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRenderPostfilterParametersEntity_EHDRGlareType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRenderPostfilterParametersEntity_EHDRGlareType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRenderPostfilterParametersEntity_EHDRGlareType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZRenderPostfilterParametersEntity_EHDRToneMapType {
    eLinear,
    eReinhardRGB,
    eFilmicRGB,
}

impl Aligned for ZRenderPostfilterParametersEntity_EHDRToneMapType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZRenderPostfilterParametersEntity_EHDRToneMapType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLinear => 0i32,
            Self::eReinhardRGB => 1i32,
            Self::eFilmicRGB => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZRenderPostfilterParametersEntity_EHDRToneMapType {
     const TYPE_ID: &str = "ZRenderPostfilterParametersEntity_EHDRToneMapType";
}

impl StaticVariant for Vec<ZRenderPostfilterParametersEntity_EHDRToneMapType> {
     const TYPE_ID: &str = "TArray<ZRenderPostfilterParametersEntity_EHDRToneMapType>";
}

impl StaticVariant for Vec<Vec<ZRenderPostfilterParametersEntity_EHDRToneMapType>> {
     const TYPE_ID: &str = "TArray<TArray<ZRenderPostfilterParametersEntity_EHDRToneMapType>>";
}

impl Variant for ZRenderPostfilterParametersEntity_EHDRToneMapType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZRenderPostfilterParametersEntity_EHDRToneMapType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZRenderPostfilterParametersEntity_EHDRToneMapType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZRenderPostfilterParametersEntity_EHDRToneMapType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZRenderPostfilterParametersEntity_EHDRToneMapType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZRenderPostfilterParametersEntity_EHDRToneMapType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSecuritySystemCameraConfiguration_ECameraEscalationSituations {
    eCES_Arrest,
    eCES_Combat,
}

impl Aligned for ZSecuritySystemCameraConfiguration_ECameraEscalationSituations {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSecuritySystemCameraConfiguration_ECameraEscalationSituations {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eCES_Arrest => 0i32,
            Self::eCES_Combat => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSecuritySystemCameraConfiguration_ECameraEscalationSituations {
     const TYPE_ID: &str = "ZSecuritySystemCameraConfiguration_ECameraEscalationSituations";
}

impl StaticVariant for Vec<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations> {
     const TYPE_ID: &str = "TArray<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>";
}

impl StaticVariant for Vec<Vec<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>> {
     const TYPE_ID: &str = "TArray<TArray<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>>";
}

impl Variant for ZSecuritySystemCameraConfiguration_ECameraEscalationSituations {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSecuritySystemCameraConfiguration_ECameraEscalationSituations")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSecuritySystemCameraConfiguration_ECameraEscalationSituations".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSecuritySystemCameraConfiguration_ECameraEscalationSituations>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSequenceEntity_ELetterBoxAspect {
    LETTERBOXASPECT_WIDESCREEN,
    LETTERBOXASPECT_CINEMASCOPE,
}

impl Aligned for ZSequenceEntity_ELetterBoxAspect {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSequenceEntity_ELetterBoxAspect {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::LETTERBOXASPECT_WIDESCREEN => 0i32,
            Self::LETTERBOXASPECT_CINEMASCOPE => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSequenceEntity_ELetterBoxAspect {
     const TYPE_ID: &str = "ZSequenceEntity_ELetterBoxAspect";
}

impl StaticVariant for Vec<ZSequenceEntity_ELetterBoxAspect> {
     const TYPE_ID: &str = "TArray<ZSequenceEntity_ELetterBoxAspect>";
}

impl StaticVariant for Vec<Vec<ZSequenceEntity_ELetterBoxAspect>> {
     const TYPE_ID: &str = "TArray<TArray<ZSequenceEntity_ELetterBoxAspect>>";
}

impl Variant for ZSequenceEntity_ELetterBoxAspect {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSequenceEntity_ELetterBoxAspect")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSequenceEntity_ELetterBoxAspect".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSequenceEntity_ELetterBoxAspect>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSequenceEntity_ELetterBoxAspect>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSequenceEntity_ELetterBoxAspect>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSetUIControlDisplayInfoEntity_EProjectionOp {
    NoOp,
    SetPerspective,
}

impl Aligned for ZSetUIControlDisplayInfoEntity_EProjectionOp {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSetUIControlDisplayInfoEntity_EProjectionOp {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NoOp => 0i32,
            Self::SetPerspective => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSetUIControlDisplayInfoEntity_EProjectionOp {
     const TYPE_ID: &str = "ZSetUIControlDisplayInfoEntity_EProjectionOp";
}

impl StaticVariant for Vec<ZSetUIControlDisplayInfoEntity_EProjectionOp> {
     const TYPE_ID: &str = "TArray<ZSetUIControlDisplayInfoEntity_EProjectionOp>";
}

impl StaticVariant for Vec<Vec<ZSetUIControlDisplayInfoEntity_EProjectionOp>> {
     const TYPE_ID: &str = "TArray<TArray<ZSetUIControlDisplayInfoEntity_EProjectionOp>>";
}

impl Variant for ZSetUIControlDisplayInfoEntity_EProjectionOp {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSetUIControlDisplayInfoEntity_EProjectionOp")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSetUIControlDisplayInfoEntity_EProjectionOp".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSetUIControlDisplayInfoEntity_EProjectionOp>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSetUIControlDisplayInfoEntity_EProjectionOp>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSetUIControlDisplayInfoEntity_EProjectionOp>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSetUIControlDisplayInfoEntity_EVisibilityOp {
    NoOp,
    SetTrue,
    SetFalse,
}

impl Aligned for ZSetUIControlDisplayInfoEntity_EVisibilityOp {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSetUIControlDisplayInfoEntity_EVisibilityOp {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::NoOp => 0i32,
            Self::SetTrue => 1i32,
            Self::SetFalse => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSetUIControlDisplayInfoEntity_EVisibilityOp {
     const TYPE_ID: &str = "ZSetUIControlDisplayInfoEntity_EVisibilityOp";
}

impl StaticVariant for Vec<ZSetUIControlDisplayInfoEntity_EVisibilityOp> {
     const TYPE_ID: &str = "TArray<ZSetUIControlDisplayInfoEntity_EVisibilityOp>";
}

impl StaticVariant for Vec<Vec<ZSetUIControlDisplayInfoEntity_EVisibilityOp>> {
     const TYPE_ID: &str = "TArray<TArray<ZSetUIControlDisplayInfoEntity_EVisibilityOp>>";
}

impl Variant for ZSetUIControlDisplayInfoEntity_EVisibilityOp {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSetUIControlDisplayInfoEntity_EVisibilityOp")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSetUIControlDisplayInfoEntity_EVisibilityOp".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSetUIControlDisplayInfoEntity_EVisibilityOp>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSetUIControlDisplayInfoEntity_EVisibilityOp>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSetUIControlDisplayInfoEntity_EVisibilityOp>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSetVisibleEntity_StartBehavior {
    SB_Nothing,
    SB_MakeVisible,
    SB_MakeInvisible,
}

impl Aligned for ZSetVisibleEntity_StartBehavior {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSetVisibleEntity_StartBehavior {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SB_Nothing => 0i32,
            Self::SB_MakeVisible => 1i32,
            Self::SB_MakeInvisible => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSetVisibleEntity_StartBehavior {
     const TYPE_ID: &str = "ZSetVisibleEntity_StartBehavior";
}

impl StaticVariant for Vec<ZSetVisibleEntity_StartBehavior> {
     const TYPE_ID: &str = "TArray<ZSetVisibleEntity_StartBehavior>";
}

impl StaticVariant for Vec<Vec<ZSetVisibleEntity_StartBehavior>> {
     const TYPE_ID: &str = "TArray<TArray<ZSetVisibleEntity_StartBehavior>>";
}

impl Variant for ZSetVisibleEntity_StartBehavior {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSetVisibleEntity_StartBehavior")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSetVisibleEntity_StartBehavior".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSetVisibleEntity_StartBehavior>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSetVisibleEntity_StartBehavior>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSetVisibleEntity_StartBehavior>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSniperCombatGroup_EGroupState {
    IGS_WaitingForActors,
    IGS_Move,
    IGS_Siege,
    IGS_Completed,
    IGS_Max,
}

impl Aligned for ZSniperCombatGroup_EGroupState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSniperCombatGroup_EGroupState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IGS_WaitingForActors => 0i32,
            Self::IGS_Move => 1i32,
            Self::IGS_Siege => 2i32,
            Self::IGS_Completed => 3i32,
            Self::IGS_Max => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSniperCombatGroup_EGroupState {
     const TYPE_ID: &str = "ZSniperCombatGroup_EGroupState";
}

impl StaticVariant for Vec<ZSniperCombatGroup_EGroupState> {
     const TYPE_ID: &str = "TArray<ZSniperCombatGroup_EGroupState>";
}

impl StaticVariant for Vec<Vec<ZSniperCombatGroup_EGroupState>> {
     const TYPE_ID: &str = "TArray<TArray<ZSniperCombatGroup_EGroupState>>";
}

impl Variant for ZSniperCombatGroup_EGroupState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSniperCombatGroup_EGroupState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSniperCombatGroup_EGroupState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSniperCombatGroup_EGroupState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSniperCombatGroup_EGroupState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSniperCombatGroup_EGroupState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSniperCombatSituation_ESituationState {
    SS_Main,
    SS_StandDown,
    SS_InvalidSituation,
}

impl Aligned for ZSniperCombatSituation_ESituationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSniperCombatSituation_ESituationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SS_Main => 0i32,
            Self::SS_StandDown => 1i32,
            Self::SS_InvalidSituation => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSniperCombatSituation_ESituationState {
     const TYPE_ID: &str = "ZSniperCombatSituation_ESituationState";
}

impl StaticVariant for Vec<ZSniperCombatSituation_ESituationState> {
     const TYPE_ID: &str = "TArray<ZSniperCombatSituation_ESituationState>";
}

impl StaticVariant for Vec<Vec<ZSniperCombatSituation_ESituationState>> {
     const TYPE_ID: &str = "TArray<TArray<ZSniperCombatSituation_ESituationState>>";
}

impl Variant for ZSniperCombatSituation_ESituationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSniperCombatSituation_ESituationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSniperCombatSituation_ESituationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSniperCombatSituation_ESituationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSniperCombatSituation_ESituationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSniperCombatSituation_ESituationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSoundAmbienceGroup_ESoundCollisionType {
    SCT_Box,
    SCT_Cylinder,
    SCT_Sphere,
    SCT_Volume,
}

impl Aligned for ZSoundAmbienceGroup_ESoundCollisionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSoundAmbienceGroup_ESoundCollisionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SCT_Box => 0i32,
            Self::SCT_Cylinder => 1i32,
            Self::SCT_Sphere => 2i32,
            Self::SCT_Volume => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSoundAmbienceGroup_ESoundCollisionType {
     const TYPE_ID: &str = "ZSoundAmbienceGroup_ESoundCollisionType";
}

impl StaticVariant for Vec<ZSoundAmbienceGroup_ESoundCollisionType> {
     const TYPE_ID: &str = "TArray<ZSoundAmbienceGroup_ESoundCollisionType>";
}

impl StaticVariant for Vec<Vec<ZSoundAmbienceGroup_ESoundCollisionType>> {
     const TYPE_ID: &str = "TArray<TArray<ZSoundAmbienceGroup_ESoundCollisionType>>";
}

impl Variant for ZSoundAmbienceGroup_ESoundCollisionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSoundAmbienceGroup_ESoundCollisionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSoundAmbienceGroup_ESoundCollisionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSoundAmbienceGroup_ESoundCollisionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSoundAmbienceGroup_ESoundCollisionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSoundAmbienceGroup_ESoundCollisionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSpatialEntity_ERoomBehaviour {
    ROOM_STATIC,
    ROOM_DYNAMIC,
    ROOM_STATIC_OUTSIDE_CLIENT,
}

impl Aligned for ZSpatialEntity_ERoomBehaviour {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSpatialEntity_ERoomBehaviour {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ROOM_STATIC => 0i32,
            Self::ROOM_DYNAMIC => 1i32,
            Self::ROOM_STATIC_OUTSIDE_CLIENT => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSpatialEntity_ERoomBehaviour {
     const TYPE_ID: &str = "ZSpatialEntity_ERoomBehaviour";
}

impl StaticVariant for Vec<ZSpatialEntity_ERoomBehaviour> {
     const TYPE_ID: &str = "TArray<ZSpatialEntity_ERoomBehaviour>";
}

impl StaticVariant for Vec<Vec<ZSpatialEntity_ERoomBehaviour>> {
     const TYPE_ID: &str = "TArray<TArray<ZSpatialEntity_ERoomBehaviour>>";
}

impl Variant for ZSpatialEntity_ERoomBehaviour {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSpatialEntity_ERoomBehaviour")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSpatialEntity_ERoomBehaviour".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSpatialEntity_ERoomBehaviour>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSpatialEntity_ERoomBehaviour>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSpatialEntity_ERoomBehaviour>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZStandOffSituation_EDialogState {
    eDS_ReportTarget,
    eDS_ArrestReason,
    eDS_ArrestReasonWait,
    eDS_Warning,
    eDS_WarningWait,
    eDS_WeaponWarning,
    eDS_WeaponWarningWait,
    eDS_StopWait,
    eDS_Done,
}

impl Aligned for ZStandOffSituation_EDialogState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZStandOffSituation_EDialogState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eDS_ReportTarget => 0i32,
            Self::eDS_ArrestReason => 1i32,
            Self::eDS_ArrestReasonWait => 2i32,
            Self::eDS_Warning => 3i32,
            Self::eDS_WarningWait => 4i32,
            Self::eDS_WeaponWarning => 5i32,
            Self::eDS_WeaponWarningWait => 6i32,
            Self::eDS_StopWait => 7i32,
            Self::eDS_Done => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZStandOffSituation_EDialogState {
     const TYPE_ID: &str = "ZStandOffSituation_EDialogState";
}

impl StaticVariant for Vec<ZStandOffSituation_EDialogState> {
     const TYPE_ID: &str = "TArray<ZStandOffSituation_EDialogState>";
}

impl StaticVariant for Vec<Vec<ZStandOffSituation_EDialogState>> {
     const TYPE_ID: &str = "TArray<TArray<ZStandOffSituation_EDialogState>>";
}

impl Variant for ZStandOffSituation_EDialogState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZStandOffSituation_EDialogState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZStandOffSituation_EDialogState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZStandOffSituation_EDialogState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZStandOffSituation_EDialogState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZStandOffSituation_EDialogState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZStandOffSituation_ESituationState {
    SS_Uncertain,
    SS_Main,
    SS_Arresting,
    SS_GetHelp,
    SS_Escalate,
    SS_Investigate,
    SS_GetHelpFromFleeingCivilian,
}

impl Aligned for ZStandOffSituation_ESituationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZStandOffSituation_ESituationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SS_Uncertain => 0i32,
            Self::SS_Main => 1i32,
            Self::SS_Arresting => 2i32,
            Self::SS_GetHelp => 3i32,
            Self::SS_Escalate => 4i32,
            Self::SS_Investigate => 5i32,
            Self::SS_GetHelpFromFleeingCivilian => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZStandOffSituation_ESituationState {
     const TYPE_ID: &str = "ZStandOffSituation_ESituationState";
}

impl StaticVariant for Vec<ZStandOffSituation_ESituationState> {
     const TYPE_ID: &str = "TArray<ZStandOffSituation_ESituationState>";
}

impl StaticVariant for Vec<Vec<ZStandOffSituation_ESituationState>> {
     const TYPE_ID: &str = "TArray<TArray<ZStandOffSituation_ESituationState>>";
}

impl Variant for ZStandOffSituation_ESituationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZStandOffSituation_ESituationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZStandOffSituation_ESituationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZStandOffSituation_ESituationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZStandOffSituation_ESituationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZStandOffSituation_ESituationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZStateControllerEntity_WrapMode {
    WM_Loop,
    WM_Clamp,
}

impl Aligned for ZStateControllerEntity_WrapMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZStateControllerEntity_WrapMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WM_Loop => 0i32,
            Self::WM_Clamp => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZStateControllerEntity_WrapMode {
     const TYPE_ID: &str = "ZStateControllerEntity_WrapMode";
}

impl StaticVariant for Vec<ZStateControllerEntity_WrapMode> {
     const TYPE_ID: &str = "TArray<ZStateControllerEntity_WrapMode>";
}

impl StaticVariant for Vec<Vec<ZStateControllerEntity_WrapMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZStateControllerEntity_WrapMode>>";
}

impl Variant for ZStateControllerEntity_WrapMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZStateControllerEntity_WrapMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZStateControllerEntity_WrapMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZStateControllerEntity_WrapMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZStateControllerEntity_WrapMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZStateControllerEntity_WrapMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZSubtitleSpeakerAliasEntity_EApplicabilityBit {
    Realtime,
    PreRendered,
}

impl Aligned for ZSubtitleSpeakerAliasEntity_EApplicabilityBit {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZSubtitleSpeakerAliasEntity_EApplicabilityBit {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Realtime => 1i32,
            Self::PreRendered => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZSubtitleSpeakerAliasEntity_EApplicabilityBit {
     const TYPE_ID: &str = "ZSubtitleSpeakerAliasEntity_EApplicabilityBit";
}

impl StaticVariant for Vec<ZSubtitleSpeakerAliasEntity_EApplicabilityBit> {
     const TYPE_ID: &str = "TArray<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>";
}

impl StaticVariant for Vec<Vec<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>> {
     const TYPE_ID: &str = "TArray<TArray<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>>";
}

impl Variant for ZSubtitleSpeakerAliasEntity_EApplicabilityBit {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZSubtitleSpeakerAliasEntity_EApplicabilityBit")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZSubtitleSpeakerAliasEntity_EApplicabilityBit".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZSubtitleSpeakerAliasEntity_EApplicabilityBit>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZTestGroupPath_EModifierType {
    EMT_PushCorners,
    EMT_PushCornersAlt,
}

impl Aligned for ZTestGroupPath_EModifierType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZTestGroupPath_EModifierType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EMT_PushCorners => 0i32,
            Self::EMT_PushCornersAlt => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZTestGroupPath_EModifierType {
     const TYPE_ID: &str = "ZTestGroupPath_EModifierType";
}

impl StaticVariant for Vec<ZTestGroupPath_EModifierType> {
     const TYPE_ID: &str = "TArray<ZTestGroupPath_EModifierType>";
}

impl StaticVariant for Vec<Vec<ZTestGroupPath_EModifierType>> {
     const TYPE_ID: &str = "TArray<TArray<ZTestGroupPath_EModifierType>>";
}

impl Variant for ZTestGroupPath_EModifierType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZTestGroupPath_EModifierType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZTestGroupPath_EModifierType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZTestGroupPath_EModifierType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZTestGroupPath_EModifierType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZTestGroupPath_EModifierType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZTrackDollyControllerQueryEntity_ETrackPointQueryType {
    Closest,
    ClosestNext,
    ClosestPrevious,
}

impl Aligned for ZTrackDollyControllerQueryEntity_ETrackPointQueryType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZTrackDollyControllerQueryEntity_ETrackPointQueryType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Closest => 0i32,
            Self::ClosestNext => 1i32,
            Self::ClosestPrevious => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZTrackDollyControllerQueryEntity_ETrackPointQueryType {
     const TYPE_ID: &str = "ZTrackDollyControllerQueryEntity_ETrackPointQueryType";
}

impl StaticVariant for Vec<ZTrackDollyControllerQueryEntity_ETrackPointQueryType> {
     const TYPE_ID: &str = "TArray<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>";
}

impl StaticVariant for Vec<Vec<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>> {
     const TYPE_ID: &str = "TArray<TArray<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>>";
}

impl Variant for ZTrackDollyControllerQueryEntity_ETrackPointQueryType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZTrackDollyControllerQueryEntity_ETrackPointQueryType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZTrackDollyControllerQueryEntity_ETrackPointQueryType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZTrackDollyControllerQueryEntity_ETrackPointQueryType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZTrespassingSituation_ESituationState {
    SS_Main,
    SS_StandDown,
    SS_Escalate,
}

impl Aligned for ZTrespassingSituation_ESituationState {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZTrespassingSituation_ESituationState {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SS_Main => 1i32,
            Self::SS_StandDown => 2i32,
            Self::SS_Escalate => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZTrespassingSituation_ESituationState {
     const TYPE_ID: &str = "ZTrespassingSituation_ESituationState";
}

impl StaticVariant for Vec<ZTrespassingSituation_ESituationState> {
     const TYPE_ID: &str = "TArray<ZTrespassingSituation_ESituationState>";
}

impl StaticVariant for Vec<Vec<ZTrespassingSituation_ESituationState>> {
     const TYPE_ID: &str = "TArray<TArray<ZTrespassingSituation_ESituationState>>";
}

impl Variant for ZTrespassingSituation_ESituationState {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZTrespassingSituation_ESituationState")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZTrespassingSituation_ESituationState".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZTrespassingSituation_ESituationState>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZTrespassingSituation_ESituationState>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZTrespassingSituation_ESituationState>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIControlEntity_EAlignment {
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight,
    StretchCenter,
    StretchHorizontalTop,
    StretchHorizontalCenter,
    StretchHorizontalBottom,
    StretchVerticalLeft,
    StretchVerticalCenter,
    StretchVerticalRight,
}

impl Aligned for ZUIControlEntity_EAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIControlEntity_EAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::TopLeft => 0i32,
            Self::TopCenter => 1i32,
            Self::TopRight => 2i32,
            Self::CenterLeft => 3i32,
            Self::Center => 4i32,
            Self::CenterRight => 5i32,
            Self::BottomLeft => 6i32,
            Self::BottomCenter => 7i32,
            Self::BottomRight => 8i32,
            Self::StretchCenter => 9i32,
            Self::StretchHorizontalTop => 10i32,
            Self::StretchHorizontalCenter => 11i32,
            Self::StretchHorizontalBottom => 12i32,
            Self::StretchVerticalLeft => 13i32,
            Self::StretchVerticalCenter => 14i32,
            Self::StretchVerticalRight => 15i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlEntity_EAlignment {
     const TYPE_ID: &str = "ZUIControlEntity_EAlignment";
}

impl StaticVariant for Vec<ZUIControlEntity_EAlignment> {
     const TYPE_ID: &str = "TArray<ZUIControlEntity_EAlignment>";
}

impl StaticVariant for Vec<Vec<ZUIControlEntity_EAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlEntity_EAlignment>>";
}

impl Variant for ZUIControlEntity_EAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlEntity_EAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlEntity_EAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlEntity_EAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlEntity_EAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlEntity_EAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIControlEntity_EScaleMode {
    Manual,
    ResolutionScale,
    ResolutionScaleAspect,
    ResolutionScaleAspectFill,
}

impl Aligned for ZUIControlEntity_EScaleMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIControlEntity_EScaleMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Manual => 0i32,
            Self::ResolutionScale => 1i32,
            Self::ResolutionScaleAspect => 2i32,
            Self::ResolutionScaleAspectFill => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlEntity_EScaleMode {
     const TYPE_ID: &str = "ZUIControlEntity_EScaleMode";
}

impl StaticVariant for Vec<ZUIControlEntity_EScaleMode> {
     const TYPE_ID: &str = "TArray<ZUIControlEntity_EScaleMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlEntity_EScaleMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlEntity_EScaleMode>>";
}

impl Variant for ZUIControlEntity_EScaleMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlEntity_EScaleMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlEntity_EScaleMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlEntity_EScaleMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlEntity_EScaleMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlEntity_EScaleMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIControlLayoutLegacyAspect_EAlignmentType {
    E_ALIGNMENT_TYPE_Center,
    E_ALIGNMENT_TYPE_TopCenter,
    E_ALIGNMENT_TYPE_BottomCenter,
    E_ALIGNMENT_TYPE_CenterLeft,
    E_ALIGNMENT_TYPE_CenterRight,
    E_ALIGNMENT_TYPE_TopLeft,
    E_ALIGNMENT_TYPE_TopRight,
    E_ALIGNMENT_TYPE_BottomLeft,
    E_ALIGNMENT_TYPE_BottomRight,
}

impl Aligned for ZUIControlLayoutLegacyAspect_EAlignmentType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIControlLayoutLegacyAspect_EAlignmentType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_ALIGNMENT_TYPE_Center => 0i32,
            Self::E_ALIGNMENT_TYPE_TopCenter => 1i32,
            Self::E_ALIGNMENT_TYPE_BottomCenter => 2i32,
            Self::E_ALIGNMENT_TYPE_CenterLeft => 3i32,
            Self::E_ALIGNMENT_TYPE_CenterRight => 4i32,
            Self::E_ALIGNMENT_TYPE_TopLeft => 5i32,
            Self::E_ALIGNMENT_TYPE_TopRight => 6i32,
            Self::E_ALIGNMENT_TYPE_BottomLeft => 7i32,
            Self::E_ALIGNMENT_TYPE_BottomRight => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlLayoutLegacyAspect_EAlignmentType {
     const TYPE_ID: &str = "ZUIControlLayoutLegacyAspect_EAlignmentType";
}

impl StaticVariant for Vec<ZUIControlLayoutLegacyAspect_EAlignmentType> {
     const TYPE_ID: &str = "TArray<ZUIControlLayoutLegacyAspect_EAlignmentType>";
}

impl StaticVariant for Vec<Vec<ZUIControlLayoutLegacyAspect_EAlignmentType>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlLayoutLegacyAspect_EAlignmentType>>";
}

impl Variant for ZUIControlLayoutLegacyAspect_EAlignmentType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlLayoutLegacyAspect_EAlignmentType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlLayoutLegacyAspect_EAlignmentType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlLayoutLegacyAspect_EAlignmentType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlLayoutLegacyAspect_EAlignmentType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlLayoutLegacyAspect_EAlignmentType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIControlLayoutLegacyAspect_ELayoutMode {
    E_LAYOUT_MODE_Absolute,
    E_LAYOUT_MODE_Proportional,
    E_LAYOUT_MODE_Proportional_MaintainAspect,
    E_LAYOUT_MODE_Proportional_MaintainAspect_Fill,
    E_LAYOUT_MODE_Proportional_Scale_Fit,
    E_LAYOUT_MODE_Proportional_Scale_MaintainAspect,
    E_LAYOUT_MODE_Proportional_Scale_MaintainAspect_Fill,
}

impl Aligned for ZUIControlLayoutLegacyAspect_ELayoutMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIControlLayoutLegacyAspect_ELayoutMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_LAYOUT_MODE_Absolute => 0i32,
            Self::E_LAYOUT_MODE_Proportional => 1i32,
            Self::E_LAYOUT_MODE_Proportional_MaintainAspect => 2i32,
            Self::E_LAYOUT_MODE_Proportional_MaintainAspect_Fill => 3i32,
            Self::E_LAYOUT_MODE_Proportional_Scale_Fit => 4i32,
            Self::E_LAYOUT_MODE_Proportional_Scale_MaintainAspect => 5i32,
            Self::E_LAYOUT_MODE_Proportional_Scale_MaintainAspect_Fill => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlLayoutLegacyAspect_ELayoutMode {
     const TYPE_ID: &str = "ZUIControlLayoutLegacyAspect_ELayoutMode";
}

impl StaticVariant for Vec<ZUIControlLayoutLegacyAspect_ELayoutMode> {
     const TYPE_ID: &str = "TArray<ZUIControlLayoutLegacyAspect_ELayoutMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlLayoutLegacyAspect_ELayoutMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlLayoutLegacyAspect_ELayoutMode>>";
}

impl Variant for ZUIControlLayoutLegacyAspect_ELayoutMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlLayoutLegacyAspect_ELayoutMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlLayoutLegacyAspect_ELayoutMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlLayoutLegacyAspect_ELayoutMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlLayoutLegacyAspect_ELayoutMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlLayoutLegacyAspect_ELayoutMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZUIControlPositionLayoutFlowListAspect_EFlowMode {
    Fill,
    Fit,
}

impl Aligned for ZUIControlPositionLayoutFlowListAspect_EFlowMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZUIControlPositionLayoutFlowListAspect_EFlowMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Fill => 0i8,
            Self::Fit => 1i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlPositionLayoutFlowListAspect_EFlowMode {
     const TYPE_ID: &str = "ZUIControlPositionLayoutFlowListAspect_EFlowMode";
}

impl StaticVariant for Vec<ZUIControlPositionLayoutFlowListAspect_EFlowMode> {
     const TYPE_ID: &str = "TArray<ZUIControlPositionLayoutFlowListAspect_EFlowMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlPositionLayoutFlowListAspect_EFlowMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlPositionLayoutFlowListAspect_EFlowMode>>";
}

impl Variant for ZUIControlPositionLayoutFlowListAspect_EFlowMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlPositionLayoutFlowListAspect_EFlowMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlPositionLayoutFlowListAspect_EFlowMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlPositionLayoutFlowListAspect_EFlowMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlPositionLayoutFlowListAspect_EFlowMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlPositionLayoutFlowListAspect_EFlowMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZUIControlPositionLayoutListBaseAspect_EDirection {
    Vertical,
    Horizontal,
    VerticalReversed,
    HorizontalReversed,
}

impl Aligned for ZUIControlPositionLayoutListBaseAspect_EDirection {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZUIControlPositionLayoutListBaseAspect_EDirection {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Vertical => 0i8,
            Self::Horizontal => 1i8,
            Self::VerticalReversed => 2i8,
            Self::HorizontalReversed => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlPositionLayoutListBaseAspect_EDirection {
     const TYPE_ID: &str = "ZUIControlPositionLayoutListBaseAspect_EDirection";
}

impl StaticVariant for Vec<ZUIControlPositionLayoutListBaseAspect_EDirection> {
     const TYPE_ID: &str = "TArray<ZUIControlPositionLayoutListBaseAspect_EDirection>";
}

impl StaticVariant for Vec<Vec<ZUIControlPositionLayoutListBaseAspect_EDirection>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlPositionLayoutListBaseAspect_EDirection>>";
}

impl Variant for ZUIControlPositionLayoutListBaseAspect_EDirection {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlPositionLayoutListBaseAspect_EDirection")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlPositionLayoutListBaseAspect_EDirection".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlPositionLayoutListBaseAspect_EDirection>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlPositionLayoutListBaseAspect_EDirection>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlPositionLayoutListBaseAspect_EDirection>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZUIControlPositionLayoutListBaseAspect_EItemSizeMode {
    BiggestChild,
    Fit,
    Override,
}

impl Aligned for ZUIControlPositionLayoutListBaseAspect_EItemSizeMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZUIControlPositionLayoutListBaseAspect_EItemSizeMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BiggestChild => 0i8,
            Self::Fit => 1i8,
            Self::Override => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlPositionLayoutListBaseAspect_EItemSizeMode {
     const TYPE_ID: &str = "ZUIControlPositionLayoutListBaseAspect_EItemSizeMode";
}

impl StaticVariant for Vec<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode> {
     const TYPE_ID: &str = "TArray<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>>";
}

impl Variant for ZUIControlPositionLayoutListBaseAspect_EItemSizeMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlPositionLayoutListBaseAspect_EItemSizeMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlPositionLayoutListBaseAspect_EItemSizeMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlPositionLayoutListBaseAspect_EItemSizeMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode {
    BiggestChild,
    ChildBoundingBox,
    Override,
}

impl Aligned for ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BiggestChild => 0i8,
            Self::ChildBoundingBox => 1i8,
            Self::Override => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode {
     const TYPE_ID: &str = "ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode";
}

impl StaticVariant for Vec<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode> {
     const TYPE_ID: &str = "TArray<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>>";
}

impl Variant for ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlSizeLayoutScaleboxAspect_EContentSizeMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode {
    Fill,
    Fit,
    FitX,
    FitY,
}

impl Aligned for ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Fill => 0i8,
            Self::Fit => 1i8,
            Self::FitX => 2i8,
            Self::FitY => 3i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode {
     const TYPE_ID: &str = "ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode";
}

impl StaticVariant for Vec<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode> {
     const TYPE_ID: &str = "TArray<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>";
}

impl StaticVariant for Vec<Vec<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>>";
}

impl Variant for ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIControlSizeLayoutScaleboxAspect_EScaleboxMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIFlowLayoutEntity_EFlowType {
    E_FLOW_TYPE_HORIZONTAL,
    E_FLOW_TYPE_VERTICAL,
}

impl Aligned for ZUIFlowLayoutEntity_EFlowType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIFlowLayoutEntity_EFlowType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_FLOW_TYPE_HORIZONTAL => 0i32,
            Self::E_FLOW_TYPE_VERTICAL => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIFlowLayoutEntity_EFlowType {
     const TYPE_ID: &str = "ZUIFlowLayoutEntity_EFlowType";
}

impl StaticVariant for Vec<ZUIFlowLayoutEntity_EFlowType> {
     const TYPE_ID: &str = "TArray<ZUIFlowLayoutEntity_EFlowType>";
}

impl StaticVariant for Vec<Vec<ZUIFlowLayoutEntity_EFlowType>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIFlowLayoutEntity_EFlowType>>";
}

impl Variant for ZUIFlowLayoutEntity_EFlowType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIFlowLayoutEntity_EFlowType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIFlowLayoutEntity_EFlowType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIFlowLayoutEntity_EFlowType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIFlowLayoutEntity_EFlowType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIFlowLayoutEntity_EFlowType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIGlobalSubtitleCondition_ESpatialType {
    Any,
    Audio2D,
    Volumetric,
    Point,
}

impl Aligned for ZUIGlobalSubtitleCondition_ESpatialType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIGlobalSubtitleCondition_ESpatialType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Any => 0i32,
            Self::Audio2D => 1i32,
            Self::Volumetric => 2i32,
            Self::Point => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIGlobalSubtitleCondition_ESpatialType {
     const TYPE_ID: &str = "ZUIGlobalSubtitleCondition_ESpatialType";
}

impl StaticVariant for Vec<ZUIGlobalSubtitleCondition_ESpatialType> {
     const TYPE_ID: &str = "TArray<ZUIGlobalSubtitleCondition_ESpatialType>";
}

impl StaticVariant for Vec<Vec<ZUIGlobalSubtitleCondition_ESpatialType>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIGlobalSubtitleCondition_ESpatialType>>";
}

impl Variant for ZUIGlobalSubtitleCondition_ESpatialType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIGlobalSubtitleCondition_ESpatialType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIGlobalSubtitleCondition_ESpatialType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIGlobalSubtitleCondition_ESpatialType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIGlobalSubtitleCondition_ESpatialType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIGlobalSubtitleCondition_ESpatialType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIListNavigationEntity_ENavigationInputMode {
    E_MODE_UP_DOWN,
    E_MODE_LEFT_RIGHT,
    E_MODE_PGPREV_PGNEXT,
    E_MODE_SMART_2D,
}

impl Aligned for ZUIListNavigationEntity_ENavigationInputMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIListNavigationEntity_ENavigationInputMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::E_MODE_UP_DOWN => 0i32,
            Self::E_MODE_LEFT_RIGHT => 1i32,
            Self::E_MODE_PGPREV_PGNEXT => 2i32,
            Self::E_MODE_SMART_2D => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIListNavigationEntity_ENavigationInputMode {
     const TYPE_ID: &str = "ZUIListNavigationEntity_ENavigationInputMode";
}

impl StaticVariant for Vec<ZUIListNavigationEntity_ENavigationInputMode> {
     const TYPE_ID: &str = "TArray<ZUIListNavigationEntity_ENavigationInputMode>";
}

impl StaticVariant for Vec<Vec<ZUIListNavigationEntity_ENavigationInputMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIListNavigationEntity_ENavigationInputMode>>";
}

impl Variant for ZUIListNavigationEntity_ENavigationInputMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIListNavigationEntity_ENavigationInputMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIListNavigationEntity_ENavigationInputMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIListNavigationEntity_ENavigationInputMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIListNavigationEntity_ENavigationInputMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIListNavigationEntity_ENavigationInputMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy {
    None,
    ForceOff,
    Force60,
    Force30,
}

impl Aligned for ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::None => -1i32,
            Self::ForceOff => 0i32,
            Self::Force60 => 1i32,
            Self::Force30 => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy {
     const TYPE_ID: &str = "ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy";
}

impl StaticVariant for Vec<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy> {
     const TYPE_ID: &str = "TArray<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>";
}

impl StaticVariant for Vec<Vec<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>> {
     const TYPE_ID: &str = "TArray<TArray<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>>";
}

impl Variant for ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUIPerformanceTestMetricsCollectorEntity_EVsyncPolicy>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUISplashHintDataProviderEntity_ESplashHintType {
    SHT_GlobalHint,
    SHT_TutorialHint,
    SHT_ControlHint,
}

impl Aligned for ZUISplashHintDataProviderEntity_ESplashHintType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUISplashHintDataProviderEntity_ESplashHintType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::SHT_GlobalHint => 0i32,
            Self::SHT_TutorialHint => 1i32,
            Self::SHT_ControlHint => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUISplashHintDataProviderEntity_ESplashHintType {
     const TYPE_ID: &str = "ZUISplashHintDataProviderEntity_ESplashHintType";
}

impl StaticVariant for Vec<ZUISplashHintDataProviderEntity_ESplashHintType> {
     const TYPE_ID: &str = "TArray<ZUISplashHintDataProviderEntity_ESplashHintType>";
}

impl StaticVariant for Vec<Vec<ZUISplashHintDataProviderEntity_ESplashHintType>> {
     const TYPE_ID: &str = "TArray<TArray<ZUISplashHintDataProviderEntity_ESplashHintType>>";
}

impl Variant for ZUISplashHintDataProviderEntity_ESplashHintType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUISplashHintDataProviderEntity_ESplashHintType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUISplashHintDataProviderEntity_ESplashHintType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUISplashHintDataProviderEntity_ESplashHintType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUISplashHintDataProviderEntity_ESplashHintType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUISplashHintDataProviderEntity_ESplashHintType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUISubtitleDataProvider_EAlignment {
    ALIGN_BOTTOM,
    ALIGN_TOP,
}

impl Aligned for ZUISubtitleDataProvider_EAlignment {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUISubtitleDataProvider_EAlignment {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALIGN_BOTTOM => 0i32,
            Self::ALIGN_TOP => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUISubtitleDataProvider_EAlignment {
     const TYPE_ID: &str = "ZUISubtitleDataProvider_EAlignment";
}

impl StaticVariant for Vec<ZUISubtitleDataProvider_EAlignment> {
     const TYPE_ID: &str = "TArray<ZUISubtitleDataProvider_EAlignment>";
}

impl StaticVariant for Vec<Vec<ZUISubtitleDataProvider_EAlignment>> {
     const TYPE_ID: &str = "TArray<TArray<ZUISubtitleDataProvider_EAlignment>>";
}

impl Variant for ZUISubtitleDataProvider_EAlignment {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUISubtitleDataProvider_EAlignment")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUISubtitleDataProvider_EAlignment".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUISubtitleDataProvider_EAlignment>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUISubtitleDataProvider_EAlignment>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUISubtitleDataProvider_EAlignment>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode {
    Gameplay,
    Cinematic,
}

impl Aligned for ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Gameplay => 0i32,
            Self::Cinematic => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode {
     const TYPE_ID: &str = "ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode";
}

impl StaticVariant for Vec<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode> {
     const TYPE_ID: &str = "TArray<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>";
}

impl StaticVariant for Vec<Vec<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>>";
}

impl Variant for ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUISubtitleSpeakerCinematicModeOverrideEntity_EMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZUISubtitleSpeakerDefaultIconEntity_EEmitterType {
    Audio2D,
    Volumetric,
}

impl Aligned for ZUISubtitleSpeakerDefaultIconEntity_EEmitterType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZUISubtitleSpeakerDefaultIconEntity_EEmitterType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::Audio2D => 1i32,
            Self::Volumetric => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZUISubtitleSpeakerDefaultIconEntity_EEmitterType {
     const TYPE_ID: &str = "ZUISubtitleSpeakerDefaultIconEntity_EEmitterType";
}

impl StaticVariant for Vec<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType> {
     const TYPE_ID: &str = "TArray<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>";
}

impl StaticVariant for Vec<Vec<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>> {
     const TYPE_ID: &str = "TArray<TArray<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>>";
}

impl Variant for ZUISubtitleSpeakerDefaultIconEntity_EEmitterType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZUISubtitleSpeakerDefaultIconEntity_EEmitterType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZUISubtitleSpeakerDefaultIconEntity_EEmitterType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZUISubtitleSpeakerDefaultIconEntity_EEmitterType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZVRCameraEntity_EEye {
    eLeftEye,
    eRightEye,
}

impl Aligned for ZVRCameraEntity_EEye {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZVRCameraEntity_EEye {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eLeftEye => 0i32,
            Self::eRightEye => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZVRCameraEntity_EEye {
     const TYPE_ID: &str = "ZVRCameraEntity_EEye";
}

impl StaticVariant for Vec<ZVRCameraEntity_EEye> {
     const TYPE_ID: &str = "TArray<ZVRCameraEntity_EEye>";
}

impl StaticVariant for Vec<Vec<ZVRCameraEntity_EEye>> {
     const TYPE_ID: &str = "TArray<TArray<ZVRCameraEntity_EEye>>";
}

impl Variant for ZVRCameraEntity_EEye {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZVRCameraEntity_EEye")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZVRCameraEntity_EEye".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZVRCameraEntity_EEye>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZVRCameraEntity_EEye>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZVRCameraEntity_EEye>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZVRCameraEntity_ETurnMode {
    eSmooth,
    eSnap,
    eSmoothSnap,
}

impl Aligned for ZVRCameraEntity_ETurnMode {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZVRCameraEntity_ETurnMode {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eSmooth => 0i8,
            Self::eSnap => 1i8,
            Self::eSmoothSnap => 2i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZVRCameraEntity_ETurnMode {
     const TYPE_ID: &str = "ZVRCameraEntity_ETurnMode";
}

impl StaticVariant for Vec<ZVRCameraEntity_ETurnMode> {
     const TYPE_ID: &str = "TArray<ZVRCameraEntity_ETurnMode>";
}

impl StaticVariant for Vec<Vec<ZVRCameraEntity_ETurnMode>> {
     const TYPE_ID: &str = "TArray<TArray<ZVRCameraEntity_ETurnMode>>";
}

impl Variant for ZVRCameraEntity_ETurnMode {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZVRCameraEntity_ETurnMode")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZVRCameraEntity_ETurnMode".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZVRCameraEntity_ETurnMode>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZVRCameraEntity_ETurnMode>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZVRCameraEntity_ETurnMode>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZVRHUDWristAlignmentController_EAxis {
    X_AXIS,
    Y_AXIS,
    Z_AXIS,
}

impl Aligned for ZVRHUDWristAlignmentController_EAxis {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZVRHUDWristAlignmentController_EAxis {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::X_AXIS => 0i32,
            Self::Y_AXIS => 1i32,
            Self::Z_AXIS => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZVRHUDWristAlignmentController_EAxis {
     const TYPE_ID: &str = "ZVRHUDWristAlignmentController_EAxis";
}

impl StaticVariant for Vec<ZVRHUDWristAlignmentController_EAxis> {
     const TYPE_ID: &str = "TArray<ZVRHUDWristAlignmentController_EAxis>";
}

impl StaticVariant for Vec<Vec<ZVRHUDWristAlignmentController_EAxis>> {
     const TYPE_ID: &str = "TArray<TArray<ZVRHUDWristAlignmentController_EAxis>>";
}

impl Variant for ZVRHUDWristAlignmentController_EAxis {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZVRHUDWristAlignmentController_EAxis")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZVRHUDWristAlignmentController_EAxis".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZVRHUDWristAlignmentController_EAxis>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZVRHUDWristAlignmentController_EAxis>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZVRHUDWristAlignmentController_EAxis>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueBool_Operation_EEvaluationType {
    ALL,
    NONE,
    ANY,
    NOT_ALL,
    ALL_EQUAL,
    ONE_TRUE,
}

impl Aligned for ZValueBool_Operation_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueBool_Operation_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::NOT_ALL => 3i32,
            Self::ALL_EQUAL => 4i32,
            Self::ONE_TRUE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueBool_Operation_EEvaluationType {
     const TYPE_ID: &str = "ZValueBool_Operation_EEvaluationType";
}

impl StaticVariant for Vec<ZValueBool_Operation_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueBool_Operation_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueBool_Operation_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueBool_Operation_EEvaluationType>>";
}

impl Variant for ZValueBool_Operation_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueBool_Operation_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueBool_Operation_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueBool_Operation_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueBool_Operation_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueBool_Operation_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueBool_OperationRecalc_EEvaluationType {
    ALL,
    NONE,
    ANY,
    NOT_ALL,
    ALL_EQUAL,
    ONE_TRUE,
}

impl Aligned for ZValueBool_OperationRecalc_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueBool_OperationRecalc_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::NOT_ALL => 3i32,
            Self::ALL_EQUAL => 4i32,
            Self::ONE_TRUE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueBool_OperationRecalc_EEvaluationType {
     const TYPE_ID: &str = "ZValueBool_OperationRecalc_EEvaluationType";
}

impl StaticVariant for Vec<ZValueBool_OperationRecalc_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueBool_OperationRecalc_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueBool_OperationRecalc_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueBool_OperationRecalc_EEvaluationType>>";
}

impl Variant for ZValueBool_OperationRecalc_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueBool_OperationRecalc_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueBool_OperationRecalc_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueBool_OperationRecalc_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueBool_OperationRecalc_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueBool_OperationRecalc_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueBool_Operation_Signal_EEvaluationType {
    ALL,
    NONE,
    ANY,
    NOT_ALL,
    ALL_EQUAL,
    ONE_TRUE,
}

impl Aligned for ZValueBool_Operation_Signal_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueBool_Operation_Signal_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ALL => 0i32,
            Self::NONE => 1i32,
            Self::ANY => 2i32,
            Self::NOT_ALL => 3i32,
            Self::ALL_EQUAL => 4i32,
            Self::ONE_TRUE => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueBool_Operation_Signal_EEvaluationType {
     const TYPE_ID: &str = "ZValueBool_Operation_Signal_EEvaluationType";
}

impl StaticVariant for Vec<ZValueBool_Operation_Signal_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueBool_Operation_Signal_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueBool_Operation_Signal_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueBool_Operation_Signal_EEvaluationType>>";
}

impl Variant for ZValueBool_Operation_Signal_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueBool_Operation_Signal_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueBool_Operation_Signal_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueBool_Operation_Signal_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueBool_Operation_Signal_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueBool_Operation_Signal_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueInt_Comparator_EEvaluationType {
    EQUAL,
    NOT_EQUAL,
    LESS,
    LESS_OR_EQUAL,
    HIGHER,
    HIGHER_OR_EQUAL,
}

impl Aligned for ZValueInt_Comparator_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueInt_Comparator_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EQUAL => 0i32,
            Self::NOT_EQUAL => 1i32,
            Self::LESS => 2i32,
            Self::LESS_OR_EQUAL => 3i32,
            Self::HIGHER => 4i32,
            Self::HIGHER_OR_EQUAL => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueInt_Comparator_EEvaluationType {
     const TYPE_ID: &str = "ZValueInt_Comparator_EEvaluationType";
}

impl StaticVariant for Vec<ZValueInt_Comparator_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueInt_Comparator_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueInt_Comparator_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueInt_Comparator_EEvaluationType>>";
}

impl Variant for ZValueInt_Comparator_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueInt_Comparator_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueInt_Comparator_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueInt_Comparator_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueInt_Comparator_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueInt_Comparator_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueInt_Comparator_Poll_EEvaluationType {
    EQUAL,
    NOT_EQUAL,
    LESS,
    LESS_OR_EQUAL,
    HIGHER,
    HIGHER_OR_EQUAL,
}

impl Aligned for ZValueInt_Comparator_Poll_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueInt_Comparator_Poll_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EQUAL => 0i32,
            Self::NOT_EQUAL => 1i32,
            Self::LESS => 2i32,
            Self::LESS_OR_EQUAL => 3i32,
            Self::HIGHER => 4i32,
            Self::HIGHER_OR_EQUAL => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueInt_Comparator_Poll_EEvaluationType {
     const TYPE_ID: &str = "ZValueInt_Comparator_Poll_EEvaluationType";
}

impl StaticVariant for Vec<ZValueInt_Comparator_Poll_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueInt_Comparator_Poll_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueInt_Comparator_Poll_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueInt_Comparator_Poll_EEvaluationType>>";
}

impl Variant for ZValueInt_Comparator_Poll_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueInt_Comparator_Poll_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueInt_Comparator_Poll_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueInt_Comparator_Poll_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueInt_Comparator_Poll_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueInt_Comparator_Poll_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZValueInt_Evaluation_EEvaluationType {
    EQUAL,
    NOT_EQUAL,
    LESS,
    LESS_OR_EQUAL,
    HIGHER,
    HIGHER_OR_EQUAL,
}

impl Aligned for ZValueInt_Evaluation_EEvaluationType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZValueInt_Evaluation_EEvaluationType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EQUAL => 0i32,
            Self::NOT_EQUAL => 1i32,
            Self::LESS => 2i32,
            Self::LESS_OR_EQUAL => 3i32,
            Self::HIGHER => 4i32,
            Self::HIGHER_OR_EQUAL => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZValueInt_Evaluation_EEvaluationType {
     const TYPE_ID: &str = "ZValueInt_Evaluation_EEvaluationType";
}

impl StaticVariant for Vec<ZValueInt_Evaluation_EEvaluationType> {
     const TYPE_ID: &str = "TArray<ZValueInt_Evaluation_EEvaluationType>";
}

impl StaticVariant for Vec<Vec<ZValueInt_Evaluation_EEvaluationType>> {
     const TYPE_ID: &str = "TArray<TArray<ZValueInt_Evaluation_EEvaluationType>>";
}

impl Variant for ZValueInt_Evaluation_EEvaluationType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZValueInt_Evaluation_EEvaluationType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZValueInt_Evaluation_EEvaluationType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZValueInt_Evaluation_EEvaluationType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZValueInt_Evaluation_EEvaluationType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZValueInt_Evaluation_EEvaluationType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZVsTargetPicker_ETargetSelectionType {
    eTST_Random,
    eTST_Fair,
    eTST_Max,
}

impl Aligned for ZVsTargetPicker_ETargetSelectionType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZVsTargetPicker_ETargetSelectionType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eTST_Random => 0i32,
            Self::eTST_Fair => 1i32,
            Self::eTST_Max => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZVsTargetPicker_ETargetSelectionType {
     const TYPE_ID: &str = "ZVsTargetPicker_ETargetSelectionType";
}

impl StaticVariant for Vec<ZVsTargetPicker_ETargetSelectionType> {
     const TYPE_ID: &str = "TArray<ZVsTargetPicker_ETargetSelectionType>";
}

impl StaticVariant for Vec<Vec<ZVsTargetPicker_ETargetSelectionType>> {
     const TYPE_ID: &str = "TArray<TArray<ZVsTargetPicker_ETargetSelectionType>>";
}

impl Variant for ZVsTargetPicker_ETargetSelectionType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZVsTargetPicker_ETargetSelectionType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZVsTargetPicker_ETargetSelectionType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZVsTargetPicker_ETargetSelectionType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZVsTargetPicker_ETargetSelectionType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZVsTargetPicker_ETargetSelectionType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u8)]
pub enum ZWaveformGeneratorEntity_ECurveType {
    CURVE_TYPE_SINE,
    CURVE_TYPE_SQUARE,
    CURVE_TYPE_TRIANGLE,
    CURVE_TYPE_SAWTOOTH,
    CURVE_TYPE_REVERSE_SAWTOOTH,
}

impl Aligned for ZWaveformGeneratorEntity_ECurveType {
     const ALIGNMENT: usize = 1;
}

impl Bin1Serialize for ZWaveformGeneratorEntity_ECurveType {
    fn alignment(&self) -> usize {
        1
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::CURVE_TYPE_SINE => 0i8,
            Self::CURVE_TYPE_SQUARE => 1i8,
            Self::CURVE_TYPE_TRIANGLE => 2i8,
            Self::CURVE_TYPE_SAWTOOTH => 3i8,
            Self::CURVE_TYPE_REVERSE_SAWTOOTH => 4i8,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZWaveformGeneratorEntity_ECurveType {
     const TYPE_ID: &str = "ZWaveformGeneratorEntity_ECurveType";
}

impl StaticVariant for Vec<ZWaveformGeneratorEntity_ECurveType> {
     const TYPE_ID: &str = "TArray<ZWaveformGeneratorEntity_ECurveType>";
}

impl StaticVariant for Vec<Vec<ZWaveformGeneratorEntity_ECurveType>> {
     const TYPE_ID: &str = "TArray<TArray<ZWaveformGeneratorEntity_ECurveType>>";
}

impl Variant for ZWaveformGeneratorEntity_ECurveType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZWaveformGeneratorEntity_ECurveType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZWaveformGeneratorEntity_ECurveType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZWaveformGeneratorEntity_ECurveType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZWaveformGeneratorEntity_ECurveType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZWaveformGeneratorEntity_ECurveType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZWaypointEntity_EMovementType {
    MT_WALK,
    MT_WALK_IF_NOT_IN_SEQUENCE,
    MT_SNAP,
    MT_IGNORE_POSITION,
}

impl Aligned for ZWaypointEntity_EMovementType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZWaypointEntity_EMovementType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MT_WALK => 0i32,
            Self::MT_WALK_IF_NOT_IN_SEQUENCE => 1i32,
            Self::MT_SNAP => 2i32,
            Self::MT_IGNORE_POSITION => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZWaypointEntity_EMovementType {
     const TYPE_ID: &str = "ZWaypointEntity_EMovementType";
}

impl StaticVariant for Vec<ZWaypointEntity_EMovementType> {
     const TYPE_ID: &str = "TArray<ZWaypointEntity_EMovementType>";
}

impl StaticVariant for Vec<Vec<ZWaypointEntity_EMovementType>> {
     const TYPE_ID: &str = "TArray<TArray<ZWaypointEntity_EMovementType>>";
}

impl Variant for ZWaypointEntity_EMovementType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZWaypointEntity_EMovementType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZWaypointEntity_EMovementType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZWaypointEntity_EMovementType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZWaypointEntity_EMovementType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZWaypointEntity_EMovementType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum ZWorldUIElementInstanceBase_EVisibility {
    EVIS_ALWAYS,
    EVIS_POSY,
    EVIS_NEGY,
    EVIS_POSX,
    EVIS_NEGX,
}

impl Aligned for ZWorldUIElementInstanceBase_EVisibility {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for ZWorldUIElementInstanceBase_EVisibility {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::EVIS_ALWAYS => 0i32,
            Self::EVIS_POSY => 1i32,
            Self::EVIS_NEGY => 2i32,
            Self::EVIS_POSX => 3i32,
            Self::EVIS_NEGX => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for ZWorldUIElementInstanceBase_EVisibility {
     const TYPE_ID: &str = "ZWorldUIElementInstanceBase_EVisibility";
}

impl StaticVariant for Vec<ZWorldUIElementInstanceBase_EVisibility> {
     const TYPE_ID: &str = "TArray<ZWorldUIElementInstanceBase_EVisibility>";
}

impl StaticVariant for Vec<Vec<ZWorldUIElementInstanceBase_EVisibility>> {
     const TYPE_ID: &str = "TArray<TArray<ZWorldUIElementInstanceBase_EVisibility>>";
}

impl Variant for ZWorldUIElementInstanceBase_EVisibility {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("ZWorldUIElementInstanceBase_EVisibility")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("ZWorldUIElementInstanceBase_EVisibility".into()))
    }
}

inventory::submit!(&VariantDeserializer::<ZWorldUIElementInstanceBase_EVisibility>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<ZWorldUIElementInstanceBase_EVisibility>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<ZWorldUIElementInstanceBase_EVisibility>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eActionRewardType {
    AR_None,
    AR_QuestItem,
    AR_Keycard,
    AR_Key,
}

impl Aligned for eActionRewardType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eActionRewardType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::AR_None => 0i32,
            Self::AR_QuestItem => 1i32,
            Self::AR_Keycard => 2i32,
            Self::AR_Key => 3i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eActionRewardType {
     const TYPE_ID: &str = "eActionRewardType";
}

impl StaticVariant for Vec<eActionRewardType> {
     const TYPE_ID: &str = "TArray<eActionRewardType>";
}

impl StaticVariant for Vec<Vec<eActionRewardType>> {
     const TYPE_ID: &str = "TArray<TArray<eActionRewardType>>";
}

impl Variant for eActionRewardType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eActionRewardType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eActionRewardType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eActionRewardType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eActionRewardType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eActionRewardType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eBurstPatternType {
    eEBP_None,
    eEBP_Circular3Rings,
    eEBP_Box,
}

impl Aligned for eBurstPatternType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eBurstPatternType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eEBP_None => 0i32,
            Self::eEBP_Circular3Rings => 1i32,
            Self::eEBP_Box => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eBurstPatternType {
     const TYPE_ID: &str = "eBurstPatternType";
}

impl StaticVariant for Vec<eBurstPatternType> {
     const TYPE_ID: &str = "TArray<eBurstPatternType>";
}

impl StaticVariant for Vec<Vec<eBurstPatternType>> {
     const TYPE_ID: &str = "TArray<TArray<eBurstPatternType>>";
}

impl Variant for eBurstPatternType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eBurstPatternType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eBurstPatternType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eBurstPatternType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eBurstPatternType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eBurstPatternType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eContractSessionStartError {
    ERROR_NONE,
    ERROR_MISSING_CONTENT,
    ERROR_SERVER_UNREACHABLE,
    ERROR_SERVER_ERROR,
    ERROR_CONTRACT_NOT_PLAYABLE_YET,
    ERROR_CONTRACT_NOT_PLAYABLE_ANYMORE,
    ERROR_CANCELED,
    ERROR_ALREADY_STARTING,
    ERROR_UNKNOWN,
}

impl Aligned for eContractSessionStartError {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eContractSessionStartError {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ERROR_NONE => 0i32,
            Self::ERROR_MISSING_CONTENT => 1i32,
            Self::ERROR_SERVER_UNREACHABLE => 2i32,
            Self::ERROR_SERVER_ERROR => 3i32,
            Self::ERROR_CONTRACT_NOT_PLAYABLE_YET => 4i32,
            Self::ERROR_CONTRACT_NOT_PLAYABLE_ANYMORE => 5i32,
            Self::ERROR_CANCELED => 6i32,
            Self::ERROR_ALREADY_STARTING => 7i32,
            Self::ERROR_UNKNOWN => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eContractSessionStartError {
     const TYPE_ID: &str = "eContractSessionStartError";
}

impl StaticVariant for Vec<eContractSessionStartError> {
     const TYPE_ID: &str = "TArray<eContractSessionStartError>";
}

impl StaticVariant for Vec<Vec<eContractSessionStartError>> {
     const TYPE_ID: &str = "TArray<TArray<eContractSessionStartError>>";
}

impl Variant for eContractSessionStartError {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eContractSessionStartError")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eContractSessionStartError".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eContractSessionStartError>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eContractSessionStartError>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eContractSessionStartError>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eHitmanPermissionReason {
    eHPReason_MovementContext,
    eHPReason_ItemHandlingInProcess,
    eHPReason_SniperMode,
    eHPReason_CrippleBox,
    eHPReason_LevelDesign,
    eHPReason_PlayerInput,
    eHPReason_InstinctBlendIn,
    eHPReason_FocusInteraction,
    eHPReason_NUM,
    eHPReason_ALLReasons,
}

impl Aligned for eHitmanPermissionReason {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eHitmanPermissionReason {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eHPReason_MovementContext => 1i32,
            Self::eHPReason_ItemHandlingInProcess => 2i32,
            Self::eHPReason_SniperMode => 4i32,
            Self::eHPReason_CrippleBox => 8i32,
            Self::eHPReason_LevelDesign => 16i32,
            Self::eHPReason_PlayerInput => 32i32,
            Self::eHPReason_InstinctBlendIn => 64i32,
            Self::eHPReason_FocusInteraction => 128i32,
            Self::eHPReason_NUM => 7i32,
            Self::eHPReason_ALLReasons => -1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eHitmanPermissionReason {
     const TYPE_ID: &str = "eHitmanPermissionReason";
}

impl StaticVariant for Vec<eHitmanPermissionReason> {
     const TYPE_ID: &str = "TArray<eHitmanPermissionReason>";
}

impl StaticVariant for Vec<Vec<eHitmanPermissionReason>> {
     const TYPE_ID: &str = "TArray<TArray<eHitmanPermissionReason>>";
}

impl Variant for eHitmanPermissionReason {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eHitmanPermissionReason")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eHitmanPermissionReason".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eHitmanPermissionReason>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eHitmanPermissionReason>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eHitmanPermissionReason>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eHolsterAbility {
    eUndecided,
    eHolsteringAllowed,
    eHolsterTemporarilyOnly,
    eHolsterSecondaryOnly,
    eHolsterQuestStorage,
    eCanNotBeHolstered,
}

impl Aligned for eHolsterAbility {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eHolsterAbility {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::eUndecided => 0i32,
            Self::eHolsteringAllowed => 1i32,
            Self::eHolsterTemporarilyOnly => 2i32,
            Self::eHolsterSecondaryOnly => 3i32,
            Self::eHolsterQuestStorage => 4i32,
            Self::eCanNotBeHolstered => 5i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eHolsterAbility {
     const TYPE_ID: &str = "eHolsterAbility";
}

impl StaticVariant for Vec<eHolsterAbility> {
     const TYPE_ID: &str = "TArray<eHolsterAbility>";
}

impl StaticVariant for Vec<Vec<eHolsterAbility>> {
     const TYPE_ID: &str = "TArray<TArray<eHolsterAbility>>";
}

impl Variant for eHolsterAbility {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eHolsterAbility")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eHolsterAbility".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eHolsterAbility>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eHolsterAbility>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eHolsterAbility>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eItemHands {
    IH_NONE,
    IH_ONEHANDED,
    IH_TWOHANDED,
}

impl Aligned for eItemHands {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eItemHands {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::IH_NONE => 0i32,
            Self::IH_ONEHANDED => 1i32,
            Self::IH_TWOHANDED => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eItemHands {
     const TYPE_ID: &str = "eItemHands";
}

impl StaticVariant for Vec<eItemHands> {
     const TYPE_ID: &str = "TArray<eItemHands>";
}

impl StaticVariant for Vec<Vec<eItemHands>> {
     const TYPE_ID: &str = "TArray<TArray<eItemHands>>";
}

impl Variant for eItemHands {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eItemHands")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eItemHands".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eItemHands>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eItemHands>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eItemHands>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eItemRarity {
    ITEMRARITY_COMMON,
    ITEMRARITY_UNCOMMON,
    ITEMRARITY_RARE,
}

impl Aligned for eItemRarity {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eItemRarity {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ITEMRARITY_COMMON => 0i32,
            Self::ITEMRARITY_UNCOMMON => 1i32,
            Self::ITEMRARITY_RARE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eItemRarity {
     const TYPE_ID: &str = "eItemRarity";
}

impl StaticVariant for Vec<eItemRarity> {
     const TYPE_ID: &str = "TArray<eItemRarity>";
}

impl StaticVariant for Vec<Vec<eItemRarity>> {
     const TYPE_ID: &str = "TArray<TArray<eItemRarity>>";
}

impl Variant for eItemRarity {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eItemRarity")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eItemRarity".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eItemRarity>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eItemRarity>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eItemRarity>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eItemSize {
    ITEMSIZE_SMALL,
    ITEMSIZE_MEDIUM,
    ITEMSIZE_LARGE,
}

impl Aligned for eItemSize {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eItemSize {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::ITEMSIZE_SMALL => 0i32,
            Self::ITEMSIZE_MEDIUM => 1i32,
            Self::ITEMSIZE_LARGE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eItemSize {
     const TYPE_ID: &str = "eItemSize";
}

impl StaticVariant for Vec<eItemSize> {
     const TYPE_ID: &str = "TArray<eItemSize>";
}

impl StaticVariant for Vec<Vec<eItemSize>> {
     const TYPE_ID: &str = "TArray<TArray<eItemSize>>";
}

impl Variant for eItemSize {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eItemSize")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eItemSize".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eItemSize>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eItemSize>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eItemSize>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eParticleEmitterBoxEntity_SpawnModes {
    BOX_SPAWNMODE_INSIDE,
    BOX_SPAWNMODE_EDGE,
    BOX_SPAWNMODE_FACE,
    BOX_SPAWNMODE_ELLIPSOID_INSIDE,
    BOX_SPAWNMODE_ELLIPSOID,
}

impl Aligned for eParticleEmitterBoxEntity_SpawnModes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eParticleEmitterBoxEntity_SpawnModes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::BOX_SPAWNMODE_INSIDE => 0i32,
            Self::BOX_SPAWNMODE_EDGE => 1i32,
            Self::BOX_SPAWNMODE_FACE => 2i32,
            Self::BOX_SPAWNMODE_ELLIPSOID_INSIDE => 3i32,
            Self::BOX_SPAWNMODE_ELLIPSOID => 4i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eParticleEmitterBoxEntity_SpawnModes {
     const TYPE_ID: &str = "eParticleEmitterBoxEntity_SpawnModes";
}

impl StaticVariant for Vec<eParticleEmitterBoxEntity_SpawnModes> {
     const TYPE_ID: &str = "TArray<eParticleEmitterBoxEntity_SpawnModes>";
}

impl StaticVariant for Vec<Vec<eParticleEmitterBoxEntity_SpawnModes>> {
     const TYPE_ID: &str = "TArray<TArray<eParticleEmitterBoxEntity_SpawnModes>>";
}

impl Variant for eParticleEmitterBoxEntity_SpawnModes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eParticleEmitterBoxEntity_SpawnModes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eParticleEmitterBoxEntity_SpawnModes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eParticleEmitterBoxEntity_SpawnModes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eParticleEmitterBoxEntity_SpawnModes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eParticleEmitterBoxEntity_SpawnModes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eParticleEmitterMeshEntity_SpawnModes {
    MESH_SPAWNMODE_VERTEX,
    MESH_SPAWNMODE_EDGE,
    MESH_SPAWNMODE_FACE,
}

impl Aligned for eParticleEmitterMeshEntity_SpawnModes {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eParticleEmitterMeshEntity_SpawnModes {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::MESH_SPAWNMODE_VERTEX => 0i32,
            Self::MESH_SPAWNMODE_EDGE => 1i32,
            Self::MESH_SPAWNMODE_FACE => 2i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eParticleEmitterMeshEntity_SpawnModes {
     const TYPE_ID: &str = "eParticleEmitterMeshEntity_SpawnModes";
}

impl StaticVariant for Vec<eParticleEmitterMeshEntity_SpawnModes> {
     const TYPE_ID: &str = "TArray<eParticleEmitterMeshEntity_SpawnModes>";
}

impl StaticVariant for Vec<Vec<eParticleEmitterMeshEntity_SpawnModes>> {
     const TYPE_ID: &str = "TArray<TArray<eParticleEmitterMeshEntity_SpawnModes>>";
}

impl Variant for eParticleEmitterMeshEntity_SpawnModes {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eParticleEmitterMeshEntity_SpawnModes")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eParticleEmitterMeshEntity_SpawnModes".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eParticleEmitterMeshEntity_SpawnModes>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eParticleEmitterMeshEntity_SpawnModes>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eParticleEmitterMeshEntity_SpawnModes>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eVRFadeType {
    FadeToGame,
    FadeToBlack,
    FadeToGame_HighPriority,
    FadeToBlack_HighPriority,
    CutToGame,
    CutToBlack,
    KeepCurrent,
}

impl Aligned for eVRFadeType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eVRFadeType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::FadeToGame => 0i32,
            Self::FadeToBlack => 1i32,
            Self::FadeToGame_HighPriority => 2i32,
            Self::FadeToBlack_HighPriority => 3i32,
            Self::CutToGame => 4i32,
            Self::CutToBlack => 5i32,
            Self::KeepCurrent => 6i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eVRFadeType {
     const TYPE_ID: &str = "eVRFadeType";
}

impl StaticVariant for Vec<eVRFadeType> {
     const TYPE_ID: &str = "TArray<eVRFadeType>";
}

impl StaticVariant for Vec<Vec<eVRFadeType>> {
     const TYPE_ID: &str = "TArray<TArray<eVRFadeType>>";
}

impl Variant for eVRFadeType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eVRFadeType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eVRFadeType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eVRFadeType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eVRFadeType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eVRFadeType>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eWeaponOperation {
    WO_SEMI_AUTO,
    WO_FULL_AUTO,
}

impl Aligned for eWeaponOperation {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eWeaponOperation {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WO_SEMI_AUTO => 0i32,
            Self::WO_FULL_AUTO => 1i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eWeaponOperation {
     const TYPE_ID: &str = "eWeaponOperation";
}

impl StaticVariant for Vec<eWeaponOperation> {
     const TYPE_ID: &str = "TArray<eWeaponOperation>";
}

impl StaticVariant for Vec<Vec<eWeaponOperation>> {
     const TYPE_ID: &str = "TArray<TArray<eWeaponOperation>>";
}

impl Variant for eWeaponOperation {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eWeaponOperation")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eWeaponOperation".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eWeaponOperation>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eWeaponOperation>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eWeaponOperation>>>::new() as &dyn DeserializeVariant);

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[repr(u32)]
pub enum eWeaponType {
    WT_HANDGUN,
    WT_SLOWGUN,
    WT_ASSAULTRIFLE,
    WT_SMG,
    WT_SNIPER,
    WT_RPG,
    WT_KNIFE,
    WT_SHOTGUN,
    WT_SPOTTER,
}

impl Aligned for eWeaponType {
     const ALIGNMENT: usize = 4;
}

impl Bin1Serialize for eWeaponType {
    fn alignment(&self) -> usize {
        4
    }

    fn write(&self, ser: &mut Bin1Serializer) -> Result<(), SerializeError> {
        ser.write_unaligned(&match self {
            Self::WT_HANDGUN => 0i32,
            Self::WT_SLOWGUN => 1i32,
            Self::WT_ASSAULTRIFLE => 2i32,
            Self::WT_SMG => 3i32,
            Self::WT_SNIPER => 4i32,
            Self::WT_RPG => 5i32,
            Self::WT_KNIFE => 6i32,
            Self::WT_SHOTGUN => 7i32,
            Self::WT_SPOTTER => 8i32,
        }.to_le_bytes());
        Ok(())
    }
}

impl StaticVariant for eWeaponType {
     const TYPE_ID: &str = "eWeaponType";
}

impl StaticVariant for Vec<eWeaponType> {
     const TYPE_ID: &str = "TArray<eWeaponType>";
}

impl StaticVariant for Vec<Vec<eWeaponType>> {
     const TYPE_ID: &str = "TArray<TArray<eWeaponType>>";
}

impl Variant for eWeaponType {
    fn type_id(&self, interner: &mut string_interner::StringInterner<string_interner::backend::BucketBackend>) -> string_interner::DefaultSymbol {
        interner.get_or_intern_static("eWeaponType")
    }

    fn to_serde(&self) -> Result<serde_json::Value, serde_json::Error> {
        Ok(serde_json::Value::String("eWeaponType".into()))
    }
}

inventory::submit!(&VariantDeserializer::<eWeaponType>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<eWeaponType>>::new() as &dyn DeserializeVariant);

inventory::submit!(&VariantDeserializer::<Vec<Vec<eWeaponType>>>::new() as &dyn DeserializeVariant);